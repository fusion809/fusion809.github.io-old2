---
date:         2016-07-09 +1000
title:        "How to Create Your Own Arch Linux Package Repository"
permalink:    /how-to-create-archlinux-repository/
categories:   archlinux, package-development, software-repositories
---

.DRAFT
****
This post is only a draft. 
****

*Arch Linux* is my favourite Linux distribution (LD), especially when it comes to building packages. This is because the PKGBUILD format is very intuitive, simple and written in my favourite programming language &mdash; Shell. Writing a PKGBUILD also does not require an awful lot of preliminary knowledge, unlike the other Linux packaging source file written in Shell, that I have a fair amount of experience with, ebuilds. They require you understand eclasses, in a fair degree of detail, in order to effectively and efficiently write them. The fact that Arch Linux package development only requires that you have a functioning PKGBUILD and does not require a whole intricate directory of syntactically-correct source files to be written by you, the packager, makes Arch Linux packages easier to develop compared to say Debian packages. The packaging source files they most closely resemble is SlackBuilds for Slackware packages, which I have fairly minimal experience with.

Shell is my favourite programming language as it is the one that is the most intuitive to me. I have found Python to be too touchy,footnoteref:[python,That is, it does not take much of an error to stuff an entire script up.] and challenging to debug, while I have found JavaScript (JS) too non-intuitive and challenging to pick up. Granted, I work best by trying out some practical examples and the only examples I can come up with for myself, when it comes to JS and Python, are those in a previous area of study of mine &mdash; technical computing. Unfortunately, I have no clear concept of a program I want to write, besides from examples from technical computing, so it is challenging for me to feel motivated to keep persevering when trying to learn these languages and obstacles arise. If you have a way around this for me, that is free,footnoteref:[free,As I will mention later in this post, I am a cheap so-and-so, always opting for the free option where possible.] I would love to hear it, so please email these suggestions to link:mailto:brentonhorne77@gmail.com[brentonhorne77@gmail.com].

== PKGBUILD Format
:icons: font

NOTE: *NOTE*: This is a brief introduction, but if you want any degree of detail I would probably see the link:https://wiki.archlinux.org/index.php/PKGBUILD[PKGBUILD] article at _Arch Wiki_. Alternatively, refer to the link:/man/PKGBUILD.5.html[PKGBUILD(5)] man page.


PKGBUILDs are fairly simple shell scripts, usually no longer than 50 lines long, but it is still important that their formatting is correct, as otherwise they will fail to build when `makepkg` is run, or they will produce unexpected results. PKGBUILDs have the following components to them, in order:

* *Header* &mdash; these are comments that, while not strictly necessary for the PKGBUILD to work, they can be handy to define important information about the PKGBUILD like who is maintaining it, who has contributed to it and their contact information. For example, my PKGBUILDs usually have the header:

:source-highlighter: coderay
[source,shell]
----
# Maintainer: Brenton Horne <brentonhorne77 at gmail dot com>
----

* *Variable definitions* &mdash; these are specified in the first ten or so lines after the header. The default fields include:footnoteref:[var-order,Presented in their _usual_, but *not* mandatory order. Not every single default variable is listed, if you want a list see the link:/man/PKGBUILD.5.html[PKGBUILD(5)] man page.]footnoteref:[A-superscript,An ^A^ superscript denotes that this variable can be an *array*.]footnoteref:[M-superscript,Mandatory field]footnoteref:[P-superscript,A ^P^ superscript denotes that this variable should be defined under the individual package's `package_...()` function, *if* the `pkgname` variable is an array. If the variable is defined outside of the package's individual package_...() function, then it will be applied to *all* packages specified in the PKGBUILD.]

  - `pkgname` ^AM^ &mdash; the name of the package(s). Sometimes a PKGBUILD will build more than one package, in these instances the packages are usually interconnected and often use the same sources.
  - `pkgdesc` ^P^ &mdash; a description of the package. Usually no longer than one sentence long.
  - `pkgver` ^MP^ &mdash; the upstream version of the package. No hyphems or whitespaces are allowed here,
  - `pkgrel` ^MP^ &mdash; the revision number of the Arch Linux package,footnoteref:[pkgrel,This version number does *not* come from the upstream source, it is a revision number for the PKGBUILD] since the last `pkgver` update.
  - `arch` ^AMP^ &mdash; the supported architecture(s) for the package. Only `i686` and `x86_64` are officially supported, although a project to port Arch Linux to Raspberry Pi PCs is underway and packages for these PCs have support for `arm` family processors. Architecture-independent packages (which are mostly themes and small packages) will have `any` in the `arch` field.
  - `url` ^A^ &mdash; the website of the package. Its source link:https://en.wikipedia.org/wiki/Version_control[Version Control System] (VCS) repository can also be used. For example, the `atom-editor` package uses the URL of Atom's GitHub repository &mdash; `https://github.com/atom/atom`.
  - `depends` ^AP^ &mdash; where the run-time dependency(s) of the package are defined.
  - `makedepends` ^AP^ &mdash; where the build (or make) dependency(s) of the package are defined, *if* they are _not_ also run-time dependencies.
  - `license` ^AP^ &mdash; the license of the package's upstream source(s). Not strictly mandatory but `makepkg` will whinge if you leave it undefined and your package will not be accepted if you upload it to the Arch User Repository (AUR). Run `ls /usr/share/licenses/common` to list the licenses available by default. The copy of other licenses (e.g., BSD, MIT, _etc._) that comes with your package's upstream source(s) will need to be installed in your `package()` function to `/usr/share/licenses/${pkgname}`.
  - `conflicts` ^AP^ &mdash; package(s) that conflict with the package being built.
  - `provides` ^AP^ &mdash; what does this package provide?footnoteref:[provides,*Excluding* `$pkgname` &mdash; this is automatically added to this array when `makepkg` is run.] For example, `efl` would be an appropriate field for `efl-git`.
  - `replaces` ^AP^ &mdash; which package(s) does this package replace? This is appropriate when naming changes between package versions, or when a program is renamed. For example, the Electron framework on which the Atom text editor and Visual Studio Code are built was previously called "Atom Shell". So it would be appropriate for an Electron PKGBUILD to include `atom-shell` in its `replaces` field.
  - `source` ^A^ &mdash; the upstream source(s) for the package, along with any patches, desktop configuration files, _etc._ you intend to use to build the package.
  - `md5sums/sha1sums/sha256sums/sha512sums` ^A^ &mdash; checksums for the sources specified in `source`. If you are wondering how to fill out this field, just pick one checksum type (e.g., `md5sums`) and write it as `md5sums=('SKIP')` and then run `updpkgsums` in the PKGBUILDs repository and it will generate the checksums for you.
  - `install` ^A^ &mdash; install file for the package, which contains functions run before, during and after installation of the package(s). Most of these relate to icon caches and desktop configuration databases.

* *Function definitions* &mdash; these are lines that come after variable definitions wherein functions recognized by `makepkg` are defined. Some extra variables are available for use in these functions, such as `$srcdir`, `$pkgdir`, _etc._. `$srcdir` is the directory where the sources are to be extracted, prepared and compiled. `$pkgdir` is where the package's files are stored before they are compressed, metadata files created and added to the package archive and finally the package is built. `$pkgdir` has the structure `pkg/$pkgname/<FS>` where `<FS>` is like a map where all your package's contents will be placed on your live file system when it is installed. Such functions include, in order of their usual appearance:

  - `pkgver()` &mdash; a function that nearly only ever appears in packages that are built from VCS sources. Whatever it returns will be used to replace the `pkgver` value defined earlier in the PKGBUILD.
  - `prepare()` &mdash; a function that prepares the package sources, making them ready for the functions that come afterwards. `makepkg` will automatically extract any archives (including `.deb` and `.rpm` archives, although it will *not* decompress any archives contained within them) for you before running what you define in your `prepare()` function. Usually this involves applying patches, editing source files (like with `sed`), decompressing source contents, _etc._
  - `build()` &mdash; a function that compiles the source code. This usually involves running `./autogen.sh ...` and/or `./configure ...` and `make` in the source directory.
  - `package()` &mdash; a function that moves the package components to the appropriate locations in the `$pkgdir` directory. If your PKGBUILD builds more than one package there should be more than one `package()` function. Named `package_<PKG1>()`, `package_<PKG2>()`, `package_<PKG3>()`, _etc._ Where `<PKG1>` is the name of the first package in the `pkgname` array, `<PKG2>` is the name of the second package, _etc._

== Writing a PKGBUILD
Now that we understand the basics of a PKGBUILD's layout, I will discuss some best practises for writing them, which text editors are best adept at writing them, where to get help, _etc._ Most modern text editors have in-built syntax-highlighting support for Shell, a few of them even automatically syntax-highlight PKGBUILDs are shell scripts. Open-source text editors that I knowfootnoteref:[editor-extras,If there are some open-source text editors I am missing that you know for a fact can run on Arch Linux (that is, you have installed them yourself and they run fine) and have automatic syntax-highlighting for PKGBUILDs] that automatically syntax-highlight opened PKGBUILDs are shell scripts, include:footnoteref:[editor-hyperlinks,Hyperlinks are to the editor's Arch Linux package description page.]

* link:https://aur.archlinux.org/packages/atom-editor[Atom]
*

== Building a Package
After you have written a PKGBUILD you would like to build a package from (beware odds are you will encounter the odd error while doing this, especially if you are new to Arch Linux packaging) run `makepkg` from the directory in which your PKGBUILD is stored. If your package has some build dependencies that you do not have installed you will need to run `makepkg -s` instead, provided these packages are in your presently-enabled (in `/etc/pacman.conf`) list of package repositories. This will, if successful, build a binary package for your current PC architecture in your present working directory. It will be called:

```bash
$pkgname-$pkgver-$pkgrel-$ARCH.pkg.tar.xz
```

where all these variables are as they were defined in the previous section, except `$ARCH` which is your current system's architecture. If the package is architecture-independent `$ARCH` will be replaced with `any`. If your package builds successfully I recommend you run `namcap` on it, to search for some common packaging errors you may have made. This may include missing dependencies, or dependencies included that are not needed, missing license files, _etc._ You can also run `namcap` on your PKGBUILD, to check if it is correctly-written.

== Setup A Repository
You can set up an unofficial Arch Linux package repository, given that you can provide the following:

* A *server* you have reliablefootnoteref:[reliable,That is, one you can communicate with easily, without fear that the server will be down for server hours at a time and not available for you to communicate with.] write access to, but that no one else, aside from some trusted individuals that may be collaborating on your repository with you, has write access to. This server should have a reliable and high-speed network connection, so that packages can be easily and rapidly downloaded from it.
* An *Arch Linux system*, or some other Linux distribution with the required tools (such as pacman's `makepkg` and `updpkgsums` utilities) for building Arch Linux packages. This system is one you need to have easy access to and it must be easily possible to transfer your package files (which may be quite large in some instances) to your server. An Arch Linux `namcap` can be handy for checking packages for common errors.

Now this post is about setting up a free Arch Linux package repository, and there are only two ways of doing this that I have experience with and are aware of (if there are more ways of doing this, especially ones that can be managed from the command-line and have great download speeds, please do tell me in an email link:mailto:brentonhorne77@gmail.com[brentonhorne77@gmail.com]). These methods are:

* Via the *Open Build Service* (*OBS*) &mdash; this is a great method if you are packaging free softwarefootnoteref:[free,It cannot be licensed under a proprietary software, even if it is a freeware license!], that is infrequently updated, does not require a network connection in the `build()` function and if you are only building a small number of packages. The OBS itself requires you to gain some extra knowledge, in order to use it effectively. The main advantage of this method over the GH method, in my opinion, is that it can be managed from the command-line, so you can automate package updates using shell scripts. It can also be accessed from a web interface (https://build.opensuse.org), which is mostly handy when you are on system where the command-line client, `osc`, is either not available or not working. The major disadvantages are that:
  1. It does not provide internet access during the `build()`, or any other function.
  2. It does not have access to the `[community]` repository (for satisfying build dependencies), which means that sometimes you will have to build some extra packages from the `[community]` repository in order to satisfy your package's build dependencies. When it comes to Python packages this can become particularly ugly with circular dependencies.
  3. Package databases can take awfully long to update after a package is updated. This is especially true if you have quite a few packages you are building.
  4. If you have more than a small handful of packages to build, the download speeds and build speeds of your packages can really lag behind what you would likely expect or want. Sometimes packages will fail to download altogether!
  5. The help available for OBS-related issues is via the link:https://forums.opensuse.org/forumdisplay.php/692-Open-Build-Service-(OBS)[OBS Forums] (which is hosted by the openSUSE Forums) and while they try to helpfootnoteref:[help,Keeping in mind that these people are all volunteers &mdash; they are not being paid a dime for this!], I have found that unless your issue also affects the building of openSUSE packages, they are unlikely to be of much help.
* Via *GitHub* (*GH*) &mdash; this is my favourite method of hosting binary packages. You can tag a release in GitHub and add binary packages to a tagged release (link:https://help.github.com/articles/creating-releases/[here] is the official GitHub documentation on how to do this from a web-browser). Although it is important to remember to include your Arch Linux package database files (of which there should be four). These are files generated using the command: `repo-add <ALRN>.db.tar.gz <PACKAGES>`. Where `<ALRN>` is the name of your Arch Linux repositoryfootnoteref:[repo-name,Which, for your information, can be different from your GitHub repository's name.] and `<PACKAGES>` is the relative (or absolute, but relative is good enough) path of each of your binary package(s). Then your Arch repository will have the `Server=` field (for your `/etc/pacman.conf` file):

```bash
Server = https://github.com/<USER>/<REPO>/releases/download/<TAG>/
```

where `<USER>` is the username field of the repo (that is, who owns it, or if it belongs to an organization, which organization owns it). `<REPO>` is the name of the repository. `<TAG>` is the name of the tag. For example for my (fusion809) `PKGBUILDs` repo's `current` tag I would use the `Server` field:

```bash
Server = https://github.com/fusion809/PKGBUILDs/releases/download/current/
```

A natural question is, "How do I update my tagged release so that it is for the latest commit, without loosing the binary packages I have already attached?" The answer is that I do not know. I do not think it is possible, especially considering link:http://stackoverflow.com/a/8044605/1876983[this StackOverflow Answer], which seems to indicate that to do this you need to delete your original tag and create a new tag of the same name. I have found their download speeds amazing (up to 3 MB/s), and they have no specific limit on the total size of the packages you upload to a release. The maximum size of an individual package is capped at 2 GB and quite frankly I have never heard of an individual Arch Linux package that is even 1 GB in size.

GH package databases are updated as soon as your binaries and database files have been uploaded, so this is certainly an efficient means of disseminating your packages to your friends, colleages and others.
