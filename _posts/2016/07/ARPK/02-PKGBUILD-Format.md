## PKGBUILD Format
{% include Layouts/notei.md note1="This is a brief introduction, but if you want any degree of detail I would probably see the [PKGBUILD](https://wiki.archlinux.org/index.php/PKGBUILD) article at _The Arch Wiki_. Alternatively, refer to the [PKGBUILD(5)](/man/PKGBUILD.5.html) man page." %}

PKGBUILDs are fairly simple shell scripts, usually no longer than 50 lines long, but it is still important that their formatting is correct, as otherwise they will fail to build when `makepkg` is run, or they will produce unexpected results. PKGBUILDs have the following components to them, in order:

* **Header** &mdash; these are comments that, while not strictly necessary for the PKGBUILD to work, they can be handy to define important information about the PKGBUILD like who is maintaining it, who has contributed to it and their contact information. For example, my PKGBUILDs usually have the header:

<div class="language-bash highlighter-rouge"><pre class="highlight"><span class="c"># Maintainer: Brenton Horne &lt;brentonhorne77 at gmail dot com&gt;</span></pre></div>

* **Variable definitions** &mdash; these are specified in the first ten or so lines after the header. The default fields include:[^3]<sup>,</sup>[^4]<sup>,</sup>[^5]<sup>,</sup>[^6]

  - `pkgname` <sup>AM</sup> &mdash; the name of the package(s). Sometimes a PKGBUILD will build more than one package, in these instances the packages are usually interconnected and often use the same sources.
  - `pkgdesc` <sup>P</sup> &mdash; a description of the package. Usually no longer than one sentence long.
  - `pkgver` <sup>MP</sup> &mdash; the upstream version of the package. No hyphems or whitespaces are allowed here,
  - `pkgrel` <sup>MP</sup> &mdash; the revision number of the Arch Linux package,[^7] since the last `pkgver` update.
  - `arch` <sup>AMP</sup> &mdash; the supported architecture(s) for the package. Only `i686` and `x86_64` are officially supported, although a project to port Arch Linux to Raspberry Pi PCs is underway and packages for these PCs have support for `arm` family processors. Architecture-independent packages (which are mostly themes and small packages) will have `any` in the `arch` field.
  - `url` <sup>A</sup> &mdash; the website of the package. Its source [Version Control System](https://en.wikipedia.org/wiki/Version*control) (VCS) repository can also be used. For example, the `atom-editor` package uses the URL of Atom's GitHub repository &mdash; `https://github.com/atom/atom`.
  - `depends` <sup>AP</sup> &mdash; where the run-time dependency(s) of the package are defined.
  - `makedepends` <sup>AP</sup> &mdash; where the build (or make) dependency(s) of the package are defined, **if** they are *not* also run-time dependencies.
  - `license` <sup>AP</sup> &mdash; the license of the package's upstream source(s). Not strictly mandatory but `makepkg` will whinge if you leave it undefined and your package will not be accepted if you upload it to the Arch User Repository (AUR). Run `ls /usr/share/licenses/common` to list the licenses available by default. The copy of other licenses (e.g., BSD, MIT, *etc.*) that comes with your package's upstream source(s) will need to be installed in your `package()` function to `/usr/share/licenses/${pkgname}`.
  - `conflicts` <sup>AP</sup> &mdash; package(s) that conflict with the package being built.
  - `provides` <sup>AP</sup> &mdash; what does this package provide?[^8] For example, `efl` would be an appropriate field for `efl-git`.
  - `replaces` <sup>AP</sup> &mdash; which package(s) does this package replace? This is appropriate when naming changes between package versions, or when a program is renamed. For example, the Electron framework on which the Atom text editor and Visual Studio Code are built was previously called "Atom Shell". So it would be appropriate for an Electron PKGBUILD to include `atom-shell` in its `replaces` field.
  - `source` <sup>A</sup> &mdash; the upstream source(s) for the package, along with any patches, desktop configuration files, *etc.* you intend to use to build the package.
  - `md5sums/sha1sums/sha256sums/sha512sums` <sup>A</sup> &mdash; checksums for the sources specified in `source`. If you are wondering how to fill out this field, just pick one checksum type (e.g., `md5sums`) and write it as `md5sums=('SKIP')` and then run `updpkgsums` in the PKGBUILD's directory and it will generate the checksums for you.
  - `validpgpkeys` <sup>A</sup> &mdash; this is very much an optional field and is seldom ever included, except for in packages that pose significant security threats if invalid, or for core system components (like the kernel). If used the upstream source likely provides the signing files (usually with the `.asc` or `.sig` file extensions), which must be specified in the `source` array.
  - `install` <sup>A</sup> &mdash; install file(s) for the package(s), which contains functions run before, during and after the installation of the package(s). Most of these relate to icon caches and desktop configuration databases.

* **Function definitions** &mdash; these are lines that come after variable definitions wherein functions recognized by `makepkg` are defined. Some extra variables are available for use in these functions, such as `$srcdir`, `$pkgdir`, *etc.*. `$srcdir` is the directory where the sources are to be extracted, prepared and compiled. `$pkgdir` is where the package's files are stored before they are compressed, metadata files created and added to the package archive and finally the package is built. `$pkgdir` has the structure `pkg/$pkgname/<FS>` where `<FS>` are the contents of the package in the location relative to `pkg/$pkgname` they are to be installed to your live file system. Such functions include, in order of their usual appearance:

  - `pkgver()` &mdash; a function that nearly only ever appears in packages that are built from VCS sources. Whatever it returns will be used to replace the `pkgver` value defined earlier in the PKGBUILD.
  - `prepare()` &mdash; a function that prepares the package sources, making them ready for the functions that come afterwards. `makepkg` will automatically extract any archives (including `.deb` and `.rpm` archives, although it will **not** decompress any archives contained within them) for you before running what you define in your `prepare()` function. Usually the `prepare()` involves applying patches, editing source files (like with `sed`), decompressing source contents, *etc.*
  - `build()` &mdash; a function that compiles the source code. This usually involves running `./autogen.sh ...` and/or `./configure ...` and `make` in the source directory.
  - `package()` &mdash; a function that moves the package components to the appropriate locations in the `$pkgdir` directory. If your PKGBUILD builds more than one package there should be more than one `package()` function. Named `package_<PKG1>()`, `package_<PKG2>()`, `package_<PKG3>()`, *etc.* Where `<PKG1>` is the name of the first package in the `pkgname` array, `<PKG2>` is the name of the second package, *etc.*
