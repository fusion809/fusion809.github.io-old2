---
date:         2016-07-08 +1000
title:        "How to Create Your Own Arch Linux Package Repository"
permalink:    /how-to-create-archlinux-repository/
categories:   archlinux, package-development, software-repositories
---

*Arch Linux* is my favourite Linux distribution (LD), especially when it comes to building packages. This is because the PKGBUILD format is very intuitive, simple and written in my favourite programming language &mdash; Shell. Writing a PKGBUILD also does not require an awful lot of preliminary knowledge, unlike the other Linux packaging source file written in Shell, that I have a fair amount of experience with, ebuilds. They require you understand eclasses, in a fair degree of detail, in order to effectively and efficiently write them. The fact that Arch Linux package development only requires that you have a functioning PKGBUILD and does not require a whole intricate directory of syntactically-correct source files to be written by you, the packager, makes Arch Linux packages easier to develop compared to say Debian packages. The packaging source files they most closely resemble is SlackBuilds for Slackware packages, which I have fairly minimal experience with.

Shell is my favourite programming language as it is the one that is the most intuitive to me. I have found Python to be too touchy,footnoteref:[python,That is, it does not take much of an error to stuff an entire script up.] and challenging to debug, while I have found JavaScript (JS) too non-intuitive and challenging to pick up. Granted, I work best by trying out some practical examples and the only examples I can come up with for myself, when it comes to JS and Python, are those in a previous area of study of mine &mdash; technical computing. Unfortunately, I have no clear concept of a program I want to write, besides from examples from technical computing, so it is challenging for me to feel motivated to keep persevering when trying to learn these languages and obstacles arise. If you have a way around this for me, that is free,footnoteref:[free,As I will mention later in this post, I am a cheap so-and-so, always opting for the free option where possible.] I would love to hear it, so please email these suggestions to link:mailto:brentonhorne77@gmail.com[brentonhorne77@gmail.com].

== PKGBUILD Format
:icons: font

NOTE: *NOTE*: This is a brief introduction, but if you want any degree of detail I would probably see the link:https://wiki.archlinux.org/index.php/PKGBUILD[PKGBUILD] article at _Arch Wiki_. Alternatively, refer to the link:/man/PKGBUILD.5.html[PKGBUILD(5)] man page.


PKGBUILDs are fairly simple shell scripts, usually no longer than 50 lines long, but it is still important that their formatting is correct, as otherwise they will fail to build when `makepkg` is run, or they will produce unexpected results. PKGBUILDs have the following components to them, in order:

* *Header* &mdash; these are comments that, while not strictly necessary for the PKGBUILD to work, they can be handy to define important information about the PKGBUILD like who is maintaining it, who has contributed to it and their contact information. For example, my PKGBUILDs usually have the header:

:source-highlighter: coderay
[source,shell]
----
# Maintainer: Brenton Horne <brentonhorne77 at gmail dot com>
----

* *Variable definitions* &mdash; these are specified in the first ten or so lines after the header. The default fields include:footnoteref:[var-order,Presented in their _usual_, but *not* mandatory order. Not every single default variable is listed, if you want a list see the link:/man/PKGBUILD.5.html[PKGBUILD(5)] man page.]footnoteref:[A-superscript,An ^A^ superscript denotes that this variable can be an *array*.]footnoteref:[M-superscript,Mandatory field]footnoteref:[P-superscript,A ^P^ superscript denotes that this variable should be defined under the individual package's `package_...()` function, *if* the `pkgname` variable is an array. If the variable is defined outside of the package's individual package_...() function, then it will be applied to *all* packages specified in the PKGBUILD.]

  - `pkgname` ^AM^ &mdash; the name of the package(s). Sometimes a PKGBUILD will build more than one package, in these instances the packages are usually interconnected and often use the same sources.
  - `pkgdesc` ^P^ &mdash; a description of the package. Usually no longer than one sentence long.
  - `pkgver` ^MP^ &mdash; the upstream version of the package. No hyphems or whitespaces are allowed here,
  - `pkgrel` ^MP^ &mdash; the revision number of the Arch Linux package,footnoteref:[pkgrel,This version number does *not* come from the upstream source, it is a revision number for the PKGBUILD] since the last `pkgver` update.
  - `arch` ^AMP^ &mdash; the supported architecture(s) for the package. Allowed architectures include: `arm`, `i686` and `x86_64`.
  - `url` ^A^ &mdash; the website of the package. Its source link:https://en.wikipedia.org/wiki/Version_control[Version Control System] (VCS) repository can also be used. For example, the `atom-editor` package uses the URL of Atom's GitHub repository &mdash; `https://github.com/atom/atom`.
  - `depends` ^AP^ &mdash; where the run-time dependency(s) of the package are defined.
  - `makedepends` ^AP^ &mdash; where the build (or make) dependency(s) of the package are defined, *if* they are _not_ also run-time dependencies.
  - `license` ^AP^ &mdash; the license of the package's upstream source(s). Not strictly mandatory but `makepkg` will whinge if you leave it undefined and your package will not be accepted if you upload it to the Arch User Repository (AUR). Run `ls /usr/share/licenses/common` to list the licenses available by default. The copy of other licenses (e.g., BSD, MIT, _etc._) that comes with your package's upstream source(s) will need to be installed in your `package()` function to `/usr/share/licenses/${pkgname}`.
  - `conflicts` ^AP^ &mdash; package(s) that conflict with the package being built.
  - `provides` ^AP^ &mdash; what does this package provide?footnoteref:[provides,*Excluding* `$pkgname` &mdash; this is automatically added to this array when `makepkg` is run.] For example, `efl` would be an appropriate field for `efl-git`.
  - `replaces` ^AP^ &mdash; which package(s) does this package replace? This is appropriate when naming changes between package versions, or when a program is renamed. For example, the Electron framework on which the Atom text editor and Visual Studio Code are built was previously called "Atom Shell". So it would be appropriate for an Electron PKGBUILD to include `atom-shell` in its `replaces` field.
  - `source` ^A^ &mdash; the upstream source(s) for the package, along with any patches, desktop configuration files, _etc._ you intend to use to build the package.
  - `md5sums/sha1sums/sha256sums/sha512sums` ^A^ &mdash; checksums for the sources specified in `source`.
  - `install` ^A^ &mdash; install file for the package, which contains functions run before, during and after installation of the package(s). Most of these relate to icon caches and desktop configuration databases.

* *Function definitions* &mdash; these are lines that come after variable definitions wherein functions recognized by `makepkg` are defined. Some extra variables are available for use in these functions, such as `$srcdir`, `$pkgdir`, _etc._. Such functions include, in order of their usual appearance:

  - `pkgver()` &mdash; a function that nearly only ever appears in packages that are built from VCS sources. Whatever it returns will be used to replace the `pkgver` value defined earlier in the PKGBUILD.
  - `prepare()` &mdash; a function that prepares the package sources, making them ready for the functions that come afterwards. `makepkg` will automatically extract any archives (including `.deb` and `.rpm` archives, although it will *not* decompress any archives contained within them) for you before running what you define in your `prepare()` function. Usually this involves applying patches, editing source files (like with `sed`), decompressing source contents, _etc._
  - `build()` &mdash; a function that compiles the source code. This usually involves running `./autogen.sh ...` and/or `./configure ...` and `make` in the source directory.
  - `package()` &mdash; a function that moves the package components to the `$pkgdir` directory.
