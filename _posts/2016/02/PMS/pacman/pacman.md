## pacman
[**pacman**](https://www.archlinux.org/pacman/) is the default package manager of Arch Linux and its various derivatives as well as at least two supposedly &ldquo;independent&rdquo; distributions, Frugalware Linux and KaOS. It adheres quite strictly to the Arch philosophy of keeping it simple, at least to those that understand it well enough. See, its syntax is far from intuitive or straight-forward to a beginner, in fact, it can quite easily become confusing, but once one understands pacman and how it works well enough, it becomes clearer. It is written almost entirely in C and this likely contributes to the fact that it is probably the fastest Linux package manager available today. pacman's first stable release was in February 2002.[^2] It is not a front-end for any other lower-level package managers.

Its packages have the `.pkg.tar.xz` file extension and are generated by running the [`makepkg`](/man/makepkg.8.html) command (which is provided by the `pacman` package) in a directory in which a specialized Bash script called a PKGBUILD is located. The PKGBUILD, analogous to an RPM file's specfile, contains instructions read by `makepkg` to build the package.

Arch Linux has two main types of repository: the pacman repositories which pacman accesses and uses to install software and the [Arch User Repository](https://aur.archlinux.org/) (AUR). The AUR is managed by git and presently contains over 30,000 different PKGBUILDs for packages that are not in the pacman repositories and as pacman itself does not have access to this repository this leaves one with far fewer packages to choose from. Fortunately, however, several [&ldquo;AUR helpers&rdquo;](https://wiki.archlinux.org/index.php/AUR_helpers) exist that have access to both the AUR and the pacman repositories. When it comes to installing packages in the AUR what many of these helpers will do is they will download the PKGBUILD (either by git cloning the AUR repository in which it lies or downloading a tarball snapshot of this repository), install any missing dependencies with either pacman or from the AUR, then build the package with `makepkg` and install it with pacman.

The most popular AUR helper, which is also the one I have the greatest experience with, is Yaourt, which is written in Bash script and has a pacman-like syntax. So running {% include Code/coders.html line1="yaourt -S atom-editor" %} should build and install `atom-editor` from the AUR. Trizen is another AUR helper I have used, it has a pacman-like syntax, but unlike Yaourt it is written in Perl.

### Beginner-Friendliness
As previously mentioned pacman has a syntax that is non-intuitive to newcomers, for example, to install a package one runs {% include Code/coders.html line1="pacman -S $package" %} while to remove it one runs {% include Code/coders-fs.html line1="pacman -Rs $package" %} If you are interested in making the transition from another package manager to pacman, I suggest you read the [Pacman/Rosetta](https://wiki.archlinux.org/index.php/Pacman/Rosetta) article at *The ArchWiki*, along with the [`pacman`](/man/pacman.8.html) man page. pacman has no officially-supported graphical front-end, although unofficial front-ends (such as Octopi and Pamac) exist and are included, by default, in the Arch derivative, Manjaro Linux.

Its basic syntax is:
{% include Code/coder.html line1="pacman [<em>options</em>] [action] [<b>target</b>(<b>s</b>)]" no="3" space="60" %}

### Customizability
pacman's settings (like a list of enabled repositories) are stored in `/etc/pacman.conf`, but as pacman is a binary package manager some freedom is taken away from the user, in terms of customizing their system. Despite this, Arch Linux has the [Arch Build System](https://wiki.archlinux.org/index.php/Arch_Build_System) (ABS), a Portage Tree-like set of subdirectories found in `/var/abs/` that contain the PKGBUILDs and associated other files used to build the software in the pacman repositories. The ABS is not included, by default, on Arch Linux, however, it has to be installed by the user and setup. Once installed, it is possible that the user can use it to customize all packages installed on their system to their liking and any extra packages they would like to install.

### Development
Developing pacman packages is far simpler than developing any other packages mentioned in this post. See it involves just writing PKGBUILDs, which are easier to write, in my opinion, than ebuilds, rules files and spec files. Once one is written or desired adjustments are made to one, the user can test it by running {% include Code/codeus.html line1="makepkg -s" %} from within the PKGBUILD's directory. This will download the upstream source code packages required, if they are not already in the PKGBUILD's directory, install any required build dependencies for the package and build it, by following the instructions within the PKGBUILD.

### Features
pacman's feature set is fairly limited compared to other package managers mentioned in this post, with respect to previously mentioned features, at least. It does not have an `autoremove` (it is possible to do an autoremove though, by piping the output of one pacman command through another, namely by running {% include Code/coders-rb.html line1="pacman -Qdtq | pacman -Rs" %} or `builddep` action (although the `makepkg` command can be passed the `-s` option to get it to install all required build dependencies, prior to making a package), nor does it support the use of wildcards. It also provides fewer details in its output than DNF or Entropy. It does support the use of meta-packages or package groups to automate the installation of a large group of related packages. For example, {% include Code/coders.html line1="pacman -S gnome" %} should install all the basic components of the GNOME desktop. While {% include Code/coders.html line1="pacman -S gnome-extra" %} installs assorted extra packages related to GNOME like its core application suite.

pacman does have several actions that can be built into a single pacman command, though, giving it more power and compactness in its syntax than more beginner-friendly package managers like APT or DNF. For example, {% include Code/coders.html line1="pacman -Syyu $package" %} can be used to synchronize local repositories, upgrade all installed packages on the system (note this will not upgrade packages installed via the AUR or custom PKGBUILDs) and install the package(s) specified in `$package`. This is as opposed to {% include Code/coders.html line1="apt-get update && apt-get upgrade && apt-get install $package" %} for APT and {% include Code/coders.html line1="dnf update && dnf install $package" %} for DNF.

### Speed
From {% include Code/coders.html line1="time pacman -S vim --noconfirm" %} I received the output:

~~~
warning: vim-7.4.1294-1 is up to date -- reinstalling
resolving dependencies...
looking for conflicting packages...

Packages (1) vim-7.4.1294-1

Total Installed Size:  2.70 MiB
Net Upgrade Size:      0.00 MiB

:: Proceed with installation? [Y/n]
(1/1) checking keys in keyring                     [######################] 100%
(1/1) checking package integrity                   [######################] 100%
(1/1) loading package files                        [######################] 100%
(1/1) checking for file conflicts                  [######################] 100%
(1/1) checking available disk space                [######################] 100%
:: Processing package changes...
(1/1) reinstalling vim                             [######################] 100%

real	0m0.464s
user	0m0.227s
sys	0m0.067s
~~~

so it took **0.464s** total to reinstall this package. I think this time is very fair, as in my experience pacman is the fastest Linux package manager I have ever used.

{% include_relative pacman/table-4-basic-usage-examples.html %}
