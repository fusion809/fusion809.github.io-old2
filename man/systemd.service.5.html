<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
SYSTEMD.SERVICE(5)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SYSTEMD.SERVICE(5)</td>
<td class="head-vol">
systemd.service</td>
<td class="head-rtitle">
SYSTEMD.SERVICE(5)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> systemd.service - Service unit configuration</div>
<div class="section">
<h1>SYNOPSIS</h1>  <i>service</i>.service</div>
<div class="section">
<h1>DESCRIPTION</h1> A unit configuration file whose name ends in .service encodes information about a process controlled and supervised by systemd.<div class="spacer">
</div>
This man page lists the configuration options specific to this unit type. See  <b>systemd.unit</b>(5) for the common options of all unit configuration files. The common configuration items are configured in the generic &quot;[Unit]&quot; and &quot;[Install]&quot; sections. The service specific configuration options are configured in the &quot;[Service]&quot; section.<div class="spacer">
</div>
Additional options are listed in  <b>systemd.exec</b>(5), which define the execution environment the commands are executed in, and in  <b>systemd.kill</b>(5), which define the way the processes of the service are terminated, and in  <b>systemd.resource-control</b>(5), which configure resource control settings for the processes of the service.<div class="spacer">
</div>
Unless  <i>DefaultDependencies=</i> is set to  <b>false</b>, service units will implicitly have dependencies of type  <i>Requires=</i> and  <i>After=</i> on basic.target as well as dependencies of type  <i>Conflicts=</i> and  <i>Before=</i> on shutdown.target. These ensure that normal service units pull in basic system initialization, and are terminated cleanly prior to system shutdown. Only services involved with early boot or late system shutdown should disable this option.<div class="spacer">
</div>
If a service is requested under a certain name but no unit configuration file is found, systemd looks for a SysV init script by the same name (with the .service suffix removed) and dynamically creates a service unit from that script. This is useful for compatibility with SysV. Note that this compatibility is quite comprehensive but not 100%. For details about the incompatibilities, see the  <b>Incompatibilities with SysV</b>[1] document.</div>
<div class="section">
<h1>OPTIONS</h1> Service files must include a &quot;[Service]&quot; section, which carries information about the service and the process it supervises. A number of options that may be used in this section are shared with other unit types. These options are documented in  <b>systemd.exec</b>(5) and  <b>systemd.kill</b>(5). The options specific to the &quot;[Service]&quot; section of service units are the following:<div class="spacer">
</div>
<i>Type=</i><div style="margin-left: 4.00ex;">
Configures the process start-up type for this service unit. One of  <b>simple</b>,  <b>forking</b>,  <b>oneshot</b>,  <b>dbus</b>,  <b>notify</b> or  <b>idle</b>.<div style="height: 1.00em;">
&#160;</div>
If set to  <b>simple</b> (the default if neither  <i>Type=</i> nor  <i>BusName=</i>, but  <i>ExecStart=</i> are specified), it is expected that the process configured with  <i>ExecStart=</i> is the main process of the service. In this mode, if the process offers functionality to other processes on the system, its communication channels should be installed before the daemon is started up (e.g. sockets set up by systemd, via socket activation), as systemd will immediately proceed starting follow-up units.<div style="height: 1.00em;">
&#160;</div>
If set to  <b>forking</b>, it is expected that the process configured with  <i>ExecStart=</i> will call  <b>fork()</b> as part of its start-up. The parent process is expected to exit when start-up is complete and all communication channels are set up. The child continues to run as the main daemon process. This is the behavior of traditional UNIX daemons. If this setting is used, it is recommended to also use the  <i>PIDFile=</i> option, so that systemd can identify the main process of the daemon. systemd will proceed with starting follow-up units as soon as the parent process exits.<div style="height: 1.00em;">
&#160;</div>
Behavior of  <b>oneshot</b> is similar to  <b>simple</b>; however, it is expected that the process has to exit before systemd starts follow-up units.  <i>RemainAfterExit=</i> is particularly useful for this type of service. This is the implied default if neither  <i>Type=</i> or  <i>ExecStart=</i> are specified.<div style="height: 1.00em;">
&#160;</div>
Behavior of  <b>dbus</b> is similar to  <b>simple</b>; however, it is expected that the daemon acquires a name on the D-Bus bus, as configured by  <i>BusName=</i>. systemd will proceed with starting follow-up units after the D-Bus bus name has been acquired. Service units with this option configured implicitly gain dependencies on the dbus.socket unit. This type is the default if  <i>BusName=</i> is specified.<div style="height: 1.00em;">
&#160;</div>
Behavior of  <b>notify</b> is similar to  <b>simple</b>; however, it is expected that the daemon sends a notification message via  <b>sd_notify</b>(3) or an equivalent call when it has finished starting up. systemd will proceed with starting follow-up units after this notification message has been sent. If this option is used,  <i>NotifyAccess=</i> (see below) should be set to open access to the notification socket provided by systemd. If  <i>NotifyAccess=</i> is not set, it will be implicitly set to  <b>main</b>. Note that currently  <i>Type=</i><b>notify</b> will not work if used in combination with  <i>PrivateNetwork=</i><b>yes</b>.<div style="height: 1.00em;">
&#160;</div>
Behavior of  <b>idle</b> is very similar to  <b>simple</b>; however, actual execution of the service binary is delayed until all jobs are dispatched. This may be used to avoid interleaving of output of shell services with the status output on the console.</div>
<div class="spacer">
</div>
<i>RemainAfterExit=</i><div style="margin-left: 4.00ex;">
Takes a boolean value that specifies whether the service shall be considered active even when all its processes exited. Defaults to  <b>no</b>.</div>
<div class="spacer">
</div>
<i>GuessMainPID=</i><div style="margin-left: 4.00ex;">
Takes a boolean value that specifies whether systemd should try to guess the main PID of a service if it cannot be determined reliably. This option is ignored unless  <b>Type=forking</b> is set and  <b>PIDFile=</b> is unset because for the other types or with an explicitly configured PID file, the main PID is always known. The guessing algorithm might come to incorrect conclusions if a daemon consists of more than one process. If the main PID cannot be determined, failure detection and automatic restarting of a service will not work reliably. Defaults to  <b>yes</b>.</div>
<div class="spacer">
</div>
<i>PIDFile=</i><div style="margin-left: 4.00ex;">
Takes an absolute file name pointing to the PID file of this daemon. Use of this option is recommended for services where  <i>Type=</i> is set to  <b>forking</b>. systemd will read the PID of the main process of the daemon after start-up of the service. systemd will not write to the file configured here, although it will remove the file after the service has shut down if it still exists.</div>
<div class="spacer">
</div>
<i>BusName=</i><div style="margin-left: 4.00ex;">
Takes a D-Bus bus name that this service is reachable as. This option is mandatory for services where  <i>Type=</i> is set to  <b>dbus</b>.</div>
<div class="spacer">
</div>
<i>BusPolicy=</i><div style="margin-left: 4.00ex;">
If specified, a custom kdbus endpoint will be created and installed as the default bus node for the service. Such a custom endpoint can hold an own set of policy rules that are enforced on top of the bus-wide ones. The custom endpoint is named after the service it was created for, and its node will be bind-mounted over the default bus node location, so the service can only access the bus through its own endpoint. Note that custom bus endpoints default to a 'deny all' policy. Hence, if at least one  <i>BusPolicy=</i> directive is given, you have to make sure to add explicit rules for everything the service should be able to do.<div style="height: 1.00em;">
&#160;</div>
The value of this directive is comprised of two parts; the bus name, and a verb to specify to granted access, which is one of  <b>see</b>,  <b>talk</b>, or  <b>own</b>.  <b>talk</b> implies  <b>see</b>, and  <b>own</b> implies both  <b>talk</b> and  <b>see</b>. If multiple access levels are specified for the same bus name, the most powerful one takes effect.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
BusPolicy=org.freedesktop.systemd1 talk<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
BusPolicy=org.foo.bar see<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
This option is only available on kdbus enabled systems.</div>
<div class="spacer">
</div>
<i>ExecStart=</i><div style="margin-left: 4.00ex;">
Commands with their arguments that are executed when this service is started. The value is split into zero or more command lines is according to the rules described below (see section &quot;Command Lines&quot; below).<div style="height: 1.00em;">
&#160;</div>
When  <i>Type</i> is not  <b>oneshot</b>, only one command may and must be given. When  <i>Type=oneshot</i> is used, zero or more commands may be specified. This can be specified by providing multiple command lines in the same directive, or alternatively, this directive may be specified more than once with the same effect. If the empty string is assigned to this option, the list of commands to start is reset, prior assignments of this option will have no effect. If no  <i>ExecStart=</i> is specified, then the service must have  <i>RemainAfterExit=yes</i> set.<div style="height: 1.00em;">
&#160;</div>
For each of the specified commands, the first argument must be an absolute path to an executable. Optionally, if this file name is prefixed with &quot;@&quot;, the second token will be passed as &quot;argv[0]&quot; to the executed process, followed by the further arguments specified. If the absolute filename is prefixed with &quot;-&quot;, an exit code of the command normally considered a failure (i.e. non-zero exit status or abnormal exit due to signal) is ignored and considered success. If both &quot;-&quot; and &quot;@&quot; are used, they can appear in either order.<div style="height: 1.00em;">
&#160;</div>
If more than one command is specified, the commands are invoked sequentially in the order they appear in the unit file. If one of the commands fails (and is not prefixed with &quot;-&quot;), other lines are not executed, and the unit is considered failed.<div style="height: 1.00em;">
&#160;</div>
Unless  <i>Type=forking</i> is set, the process started via this command line will be considered the main process of the daemon.</div>
<div class="spacer">
</div>
<i>ExecStartPre=</i>, <i>ExecStartPost=</i><div style="margin-left: 4.00ex;">
Additional commands that are executed before or after the command in  <i>ExecStart=</i>, respectively. Syntax is the same as for  <i>ExecStart=</i>, except that multiple command lines are allowed and the commands are executed one after the other, serially.<div style="height: 1.00em;">
&#160;</div>
If any of those commands (not prefixed with &quot;-&quot;) fail, the rest are not executed and the unit is considered failed.<div style="height: 1.00em;">
&#160;</div>
<i>ExecStart=</i> commands are only run after all  <i>ExecStartPre=</i> commands that were not prefixed with a &quot;-&quot; exit successfully.<div style="height: 1.00em;">
&#160;</div>
<i>ExecStartPost=</i> commands are only run after the service has started, as determined by  <i>Type=</i> (i.e. The process has been started for  <i>Type=simple</i> or  <i>Type=idle</i>, the process exits successfully for  <i>Type=oneshot</i>, the initial process exits successfully for  <i>Type=forking</i>, &quot;READY=1&quot; is sent for  <i>Type=notify</i>, or the  <i>BusName=</i> has been taken for  <i>Type=dbus</i>).<div style="height: 1.00em;">
&#160;</div>
Note that  <i>ExecStartPre=</i> may not be used to start long-running processes. All processes forked off by processes invoked via  <i>ExecStartPre=</i> will be killed before the next service process is run.</div>
<div class="spacer">
</div>
<i>ExecReload=</i><div style="margin-left: 4.00ex;">
Commands to execute to trigger a configuration reload in the service. This argument takes multiple command lines, following the same scheme as described for  <i>ExecStart=</i> above. Use of this setting is optional. Specifier and environment variable substitution is supported here following the same scheme as for  <i>ExecStart=</i>.<div style="height: 1.00em;">
&#160;</div>
One additional, special environment variable is set: if known,  <i>$MAINPID</i> is set to the main process of the daemon, and may be used for command lines like the following:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
/bin/kill -HUP $MAINPID<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
Note however that reloading a daemon by sending a signal (as with the example line above) is usually not a good choice, because this is an asynchronous operation and hence not suitable to order reloads of multiple services against each other. It is strongly recommended to set  <i>ExecReload=</i> to a command that not only triggers a configuration reload of the daemon, but also synchronously waits for it to complete.</div>
<div class="spacer">
</div>
<i>ExecStop=</i><div style="margin-left: 4.00ex;">
Commands to execute to stop the service started via  <i>ExecStart=</i>. This argument takes multiple command lines, following the same scheme as described for  <i>ExecStart=</i> above. Use of this setting is optional. After the commands configured in this option are run, all processes remaining for a service are terminated according to the  <i>KillMode=</i> setting (see  <b>systemd.kill</b>(5)). If this option is not specified, the process is terminated by sending the signal specified in  <i>KillSignal=</i> when service stop is requested. Specifier and environment variable substitution is supported (including  <i>$MAINPID</i>, see above).<div style="height: 1.00em;">
&#160;</div>
Note that it is usually not sufficient to specify a command for this setting that only asks the service to terminate (for example by queuing some form of termination signal for it), but does not wait for it to do so. Since the remaining processes of the services are killed using  <b>SIGKILL</b> immediately after the command exited this would not result in a clean stop. The specified command should hence be a synchronous operation, not an asynchronous one.</div>
<div class="spacer">
</div>
<i>ExecStopPost=</i><div style="margin-left: 4.00ex;">
Additional commands that are executed after the service was stopped. This includes cases where the commands configured in  <i>ExecStop=</i> were used, where the service does not have any  <i>ExecStop=</i> defined, or where the service exited unexpectedly. This argument takes multiple command lines, following the same scheme as described for  <i>ExecStart</i>. Use of these settings is optional. Specifier and environment variable substitution is supported.</div>
<div class="spacer">
</div>
<i>RestartSec=</i><div style="margin-left: 4.00ex;">
Configures the time to sleep before restarting a service (as configured with  <i>Restart=</i>). Takes a unit-less value in seconds, or a time span value such as &quot;5min 20s&quot;. Defaults to 100ms.</div>
<div class="spacer">
</div>
<i>TimeoutStartSec=</i><div style="margin-left: 4.00ex;">
Configures the time to wait for start-up. If a daemon service does not signal start-up completion within the configured time, the service will be considered failed and will be shut down again. Takes a unit-less value in seconds, or a time span value such as &quot;5min 20s&quot;. Pass &quot;0&quot; to disable the timeout logic. Defaults to  <i>DefaultTimeoutStartSec=</i> from the manager configuration file, except when  <i>Type=oneshot</i> is used, in which case the timeout is disabled by default (see  <b>systemd-system.conf</b>(5)).</div>
<div class="spacer">
</div>
<i>TimeoutStopSec=</i><div style="margin-left: 4.00ex;">
Configures the time to wait for stop. If a service is asked to stop, but does not terminate in the specified time, it will be terminated forcibly via  <b>SIGTERM</b>, and after another timeout of equal duration with  <b>SIGKILL</b> (see  <i>KillMode=</i> in  <b>systemd.kill</b>(5)). Takes a unit-less value in seconds, or a time span value such as &quot;5min 20s&quot;. Pass &quot;0&quot; to disable the timeout logic. Defaults to  <i>DefaultTimeoutStopSec=</i> from the manager configuration file (see  <b>systemd-system.conf</b>(5)).</div>
<div class="spacer">
</div>
<i>TimeoutSec=</i><div style="margin-left: 4.00ex;">
A shorthand for configuring both  <i>TimeoutStartSec=</i> and  <i>TimeoutStopSec=</i> to the specified value.</div>
<div class="spacer">
</div>
<i>WatchdogSec=</i><div style="margin-left: 4.00ex;">
Configures the watchdog timeout for a service. The watchdog is activated when the start-up is completed. The service must call  <b>sd_notify</b>(3) regularly with &quot;WATCHDOG=1&quot; (i.e. the &quot;keep-alive ping&quot;). If the time between two such calls is larger than the configured time, then the service is placed in a failed state and it will be terminated with  <i>SIGABRT</i>. By setting  <i>Restart=</i> to  <b>on-failure</b> or  <b>always</b>, the service will be automatically restarted. The time configured here will be passed to the executed service process in the  <i>WATCHDOG_USEC=</i> environment variable. This allows daemons to automatically enable the keep-alive pinging logic if watchdog support is enabled for the service. If this option is used,  <i>NotifyAccess=</i> (see below) should be set to open access to the notification socket provided by systemd. If  <i>NotifyAccess=</i> is not set, it will be implicitly set to  <b>main</b>. Defaults to 0, which disables this feature.</div>
<div class="spacer">
</div>
<i>Restart=</i><div style="margin-left: 4.00ex;">
Configures whether the service shall be restarted when the service process exits, is killed, or a timeout is reached. The service process may be the main service process, but it may also be one of the processes specified with  <i>ExecStartPre=</i>,  <i>ExecStartPost=</i>,  <i>ExecStop=</i>,  <i>ExecStopPost=</i>, or  <i>ExecReload=</i>. When the death of the process is a result of systemd operation (e.g. service stop or restart), the service will not be restarted. Timeouts include missing the watchdog &quot;keep-alive ping&quot; deadline and a service start, reload, and stop operation timeouts.<div style="height: 1.00em;">
&#160;</div>
Takes one of  <b>no</b>,  <b>on-success</b>,  <b>on-failure</b>,  <b>on-abnormal</b>,  <b>on-watchdog</b>,  <b>on-abort</b>, or  <b>always</b>. If set to  <b>no</b> (the default), the service will not be restarted. If set to  <b>on-success</b>, it will be restarted only when the service process exits cleanly. In this context, a clean exit means an exit code of 0, or one of the signals  <b>SIGHUP</b>,  <b>SIGINT</b>,  <b>SIGTERM</b> or  <b>SIGPIPE</b>, and additionally, exit statuses and signals specified in  <i>SuccessExitStatus=</i>. If set to  <b>on-failure</b>, the service will be restarted when the process exits with a non-zero exit code, is terminated by a signal (including on core dump, but excluding the aforementioned four signals), when an operation (such as service reload) times out, and when the configured watchdog timeout is triggered. If set to  <b>on-abnormal</b>, the service will be restarted when the process is terminated by a signal (including on core dump, excluding the aforementioned four signals), when an operation times out, or when the watchdog timeout is triggered. If set to  <b>on-abort</b>, the service will be restarted only if the service process exits due to an uncaught signal not specified as a clean exit status. If set to  <b>on-watchdog</b>, the service will be restarted only if the watchdog timeout for the service expires. If set to  <b>always</b>, the service will be restarted regardless of whether it exited cleanly or not, got terminated abnormally by a signal, or hit a timeout.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
<b>Table&#160;1.&#160;Exit causes and the effect of the <i>Restart=</i> settings on them</b><table class="tbl">
<col style="width: 28.00ex;"/>
<col style="width: 8.00ex;"/>
<col style="width: 12.00ex;"/>
<col style="width: 17.00ex;"/>
<col style="width: 17.00ex;"/>
<col style="width: 18.00ex;"/>
<col style="width: 15.00ex;"/>
<col style="width: 18.00ex;"/>
<tbody>
<tr>
<td>
Restart settings/Exit causes</td>
<td>
<b>no</b></td>
<td>
<b>always</b></td>
<td>
<b>on-success</b></td>
<td>
<b>on-failure</b></td>
<td>
<b>on-abnormal</b></td>
<td>
<b>on-abort</b></td>
<td>
<b>on-watchdog</b></td>
</tr>
<tr>
<td>
Clean exit code or signal</td>
<td>
&#160;</td>
<td>
X</td>
<td>
X</td>
<td>
&#160;</td>
<td>
&#160;</td>
<td>
&#160;</td>
<td>
&#160;</td>
</tr>
<tr>
<td>
Unclean exit code</td>
<td>
&#160;</td>
<td>
X</td>
<td>
&#160;</td>
<td>
X</td>
<td>
&#160;</td>
<td>
&#160;</td>
<td>
&#160;</td>
</tr>
<tr>
<td>
Unclean signal</td>
<td>
&#160;</td>
<td>
X</td>
<td>
&#160;</td>
<td>
X</td>
<td>
X</td>
<td>
X</td>
<td>
&#160;</td>
</tr>
<tr>
<td>
Timeout</td>
<td>
&#160;</td>
<td>
X</td>
<td>
&#160;</td>
<td>
X</td>
<td>
X</td>
<td>
&#160;</td>
<td>
&#160;</td>
</tr>
<tr>
<td>
Watchdog</td>
<td>
&#160;</td>
<td>
X</td>
<td>
&#160;</td>
<td>
X</td>
<td>
X</td>
<td>
&#160;</td>
<td>
X</td>
</tr>
</tbody>
</table>
<div style="height: 1.00em;">
&#160;</div>
As exceptions to the setting above the service will not be restarted if the exit code or signal is specified in<div style="height: 0.00em;">
&#160;</div>
<i>RestartPreventExitStatus=</i> (see below). Also, the services will always be restarted if the exit code or signal is specified in  <i>RestartForceExitStatus=</i> (see below).<div style="height: 1.00em;">
&#160;</div>
Setting this to  <b>on-failure</b> is the recommended choice for long-running services, in order to increase reliability by attempting automatic recovery from errors. For services that shall be able to terminate on their own choice (and avoid immediate restarting),  <b>on-abnormal</b> is an alternative choice.</div>
<div class="spacer">
</div>
<i>SuccessExitStatus=</i><div style="margin-left: 4.00ex;">
Takes a list of exit status definitions that when returned by the main service process will be considered successful termination, in addition to the normal successful exit code 0 and the signals  <b>SIGHUP</b>,  <b>SIGINT</b>,  <b>SIGTERM</b>, and  <b>SIGPIPE</b>. Exit status definitions can either be numeric exit codes or termination signal names, separated by spaces. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
SuccessExitStatus=1 2 8<br/>
        SIGKILL<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
ensures that exit codes 1, 2, 8 and the termination signal  <b>SIGKILL</b> are considered clean service terminations.<div style="height: 1.00em;">
&#160;</div>
Note that if a process has a signal handler installed and exits by calling  <b>_exit</b>(2) in response to a signal, the information about the signal is lost. Programs should instead perform cleanup and kill themselves with the same signal instead. See  <b>Proper handling of SIGINT/SIGQUIT &#8212; How to be a proper program</b>[2].<div style="height: 1.00em;">
&#160;</div>
This option may appear more than once, in which case the list of successful exit statuses is merged. If the empty string is assigned to this option, the list is reset, all prior assignments of this option will have no effect.</div>
<div class="spacer">
</div>
<i>RestartPreventExitStatus=</i><div style="margin-left: 4.00ex;">
Takes a list of exit status definitions that when returned by the main service process will prevent automatic service restarts, regardless of the restart setting configured with  <i>Restart=</i>. Exit status definitions can either be numeric exit codes or termination signal names, and are separated by spaces. Defaults to the empty list, so that, by default, no exit status is excluded from the configured restart logic. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
RestartPreventExitStatus=1 6<br/>
        SIGABRT<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
ensures that exit codes 1 and 6 and the termination signal  <b>SIGABRT</b> will not result in automatic service restarting. This option may appear more than once, in which case the list of restart-preventing statuses is merged. If the empty string is assigned to this option, the list is reset and all prior assignments of this option will have no effect.</div>
<div class="spacer">
</div>
<i>RestartForceExitStatus=</i><div style="margin-left: 4.00ex;">
Takes a list of exit status definitions that when returned by the main service process will force automatic service restarts, regardless of the restart setting configured with  <i>Restart=</i>. The argument format is similar to  <i>RestartPreventExitStatus=</i>.</div>
<div class="spacer">
</div>
<i>PermissionsStartOnly=</i><div style="margin-left: 4.00ex;">
Takes a boolean argument. If true, the permission-related execution options, as configured with  <i>User=</i> and similar options (see  <b>systemd.exec</b>(5) for more information), are only applied to the process started with  <i>ExecStart=</i>, and not to the various other  <i>ExecStartPre=</i>,  <i>ExecStartPost=</i>,  <i>ExecReload=</i>,  <i>ExecStop=</i>, and  <i>ExecStopPost=</i> commands. If false, the setting is applied to all configured commands the same way. Defaults to false.</div>
<div class="spacer">
</div>
<i>RootDirectoryStartOnly=</i><div style="margin-left: 4.00ex;">
Takes a boolean argument. If true, the root directory, as configured with the  <i>RootDirectory=</i> option (see  <b>systemd.exec</b>(5) for more information), is only applied to the process started with  <i>ExecStart=</i>, and not to the various other  <i>ExecStartPre=</i>,  <i>ExecStartPost=</i>,  <i>ExecReload=</i>,  <i>ExecStop=</i>, and  <i>ExecStopPost=</i> commands. If false, the setting is applied to all configured commands the same way. Defaults to false.</div>
<div class="spacer">
</div>
<i>NonBlocking=</i><div style="margin-left: 4.00ex;">
Set the  <b>O_NONBLOCK</b> flag for all file descriptors passed via socket-based activation. If true, all file descriptors &gt;= 3 (i.e. all except stdin, stdout, and stderr) will have the  <b>O_NONBLOCK</b> flag set and hence are in non-blocking mode. This option is only useful in conjunction with a socket unit, as described in  <b>systemd.socket</b>(5). Defaults to false.</div>
<div class="spacer">
</div>
<i>NotifyAccess=</i><div style="margin-left: 4.00ex;">
Controls access to the service status notification socket, as accessible via the  <b>sd_notify</b>(3) call. Takes one of  <b>none</b> (the default),  <b>main</b> or  <b>all</b>. If  <b>none</b>, no daemon status updates are accepted from the service processes, all status update messages are ignored. If  <b>main</b>, only service updates sent from the main process of the service are accepted. If  <b>all</b>, all services updates from all members of the service's control group are accepted. This option should be set to open access to the notification socket when using  <i>Type=notify</i> or  <i>WatchdogSec=</i> (see above). If those options are used but  <i>NotifyAccess=</i> is not configured, it will be implicitly set to  <b>main</b>.</div>
<div class="spacer">
</div>
<i>Sockets=</i><div style="margin-left: 4.00ex;">
Specifies the name of the socket units this service shall inherit socket file descriptors from when the service is started. Normally it should not be necessary to use this setting as all socket file descriptors whose unit shares the same name as the service (subject to the different unit name suffix of course) are passed to the spawned process.<div style="height: 1.00em;">
&#160;</div>
Note that the same socket file descriptors may be passed to multiple processes simultaneously. Also note that a different service may be activated on incoming socket traffic than the one which is ultimately configured to inherit the socket file descriptors. Or in other words: the  <i>Service=</i> setting of .socket units does not have to match the inverse of the  <i>Sockets=</i> setting of the .service it refers to.<div style="height: 1.00em;">
&#160;</div>
This option may appear more than once, in which case the list of socket units is merged. If the empty string is assigned to this option, the list of sockets is reset, and all prior uses of this setting will have no effect.</div>
<div class="spacer">
</div>
<i>StartLimitInterval=</i>, <i>StartLimitBurst=</i><div style="margin-left: 4.00ex;">
Configure service start rate limiting. By default, services which are started more than 5 times within 10 seconds are not permitted to start any more times until the 10 second interval ends. With these two options, this rate limiting may be modified. Use  <i>StartLimitInterval=</i> to configure the checking interval (defaults to  <i>DefaultStartLimitInterval=</i> in manager configuration file, set to 0 to disable any kind of rate limiting). Use  <i>StartLimitBurst=</i> to configure how many starts per interval are allowed (defaults to  <i>DefaultStartLimitBurst=</i> in manager configuration file). These configuration options are particularly useful in conjunction with  <i>Restart=</i>; however, they apply to all kinds of starts (including manual), not just those triggered by the  <i>Restart=</i> logic. Note that units which are configured for  <i>Restart=</i> and which reach the start limit are not attempted to be restarted anymore; however, they may still be restarted manually at a later point, from which point on, the restart logic is again activated. Note that  <b>systemctl reset-failed</b> will cause the restart rate counter for a service to be flushed, which is useful if the administrator wants to manually start a service and the start limit interferes with that.</div>
<div class="spacer">
</div>
<i>StartLimitAction=</i><div style="margin-left: 4.00ex;">
Configure the action to take if the rate limit configured with  <i>StartLimitInterval=</i> and  <i>StartLimitBurst=</i> is hit. Takes one of  <b>none</b>,  <b>reboot</b>,  <b>reboot-force</b>,  <b>reboot-immediate</b>,  <b>poweroff</b>,  <b>poweroff-force</b> or  <b>poweroff-immediate</b>. If  <b>none</b> is set, hitting the rate limit will trigger no action besides that the start will not be permitted.  <b>reboot</b> causes a reboot following the normal shutdown procedure (i.e. equivalent to  <b>systemctl reboot</b>).  <b>reboot-force</b> causes a forced reboot which will terminate all processes forcibly but should cause no dirty file systems on reboot (i.e. equivalent to  <b>systemctl reboot -f</b>) and  <b>reboot-immediate</b> causes immediate execution of the  <b>reboot</b>(2) system call, which might result in data loss. Similar,  <b>poweroff</b>,  <b>poweroff-force</b>,  <b>poweroff-immediate</b> have the effect of powering down the system with similar semantics. Defaults to  <b>none</b>.</div>
<div class="spacer">
</div>
<i>FailureAction=</i><div style="margin-left: 4.00ex;">
Configure the action to take when the service enters a failed state. Takes the same values as  <i>StartLimitAction=</i> and executes the same actions. Defaults to  <b>none</b>.</div>
<div class="spacer">
</div>
<i>RebootArgument=</i><div style="margin-left: 4.00ex;">
Configure the optional argument for the  <b>reboot</b>(2) system call if  <i>StartLimitAction=</i> or  <i>FailureAction=</i> is a reboot action. This works just like the optional argument to  <b>systemctl reboot</b> command.</div>
<div class="spacer">
</div>
<i>FileDescriptorStoreMax=</i><div style="margin-left: 4.00ex;">
Configure how many file descriptors may be stored in the service manager for the service using  <b>sd_pid_notify_with_fds</b>(3)'s &quot;FDSTORE=1&quot; messages. This is useful for implementing service restart schemes where the state is serialized to /run and the file descriptors passed to the service manager, to allow restarts without losing state. Defaults to 0, i.e. no file descriptors may be stored in the service manager by default. All file descriptors passed to the service manager from a specific service are passed back to the service's main process on the next service restart. Any file descriptors passed to the service manager are automatically closed when POLLHUP or POLLERR is seen on them, or when the service is fully stopped and no job queued or being executed for it.</div>
<div class="spacer">
</div>
Check  <b>systemd.exec</b>(5) and  <b>systemd.kill</b>(5) for more settings.</div>
<div class="section">
<h1>COMMAND LINES</h1> This section describes command line parsing and variable and specifier substitutions for  <i>ExecStart=</i>,  <i>ExecStartPre=</i>,  <i>ExecStartPost=</i>,  <i>ExecReload=</i>,  <i>ExecStop=</i>, and  <i>ExecStopPost=</i> options.<div class="spacer">
</div>
Multiple command lines may be concatenated in a single directive by separating them with semicolons (these semicolons must be passed as separate words). Lone semicolons may be escaped as &quot;\;&quot;.<div class="spacer">
</div>
Each command line is split on whitespace, with the first item being the command to execute, and the subsequent items being the arguments. Double quotes (&quot;...&quot;) and single quotes ('...') may be used, in which case everything until the next matching quote becomes part of the same argument. C-style escapes are also supported. The table below contains the list of allowed escape patterns. Only patterns which match the syntax in the table are allowed; others will result in an error, and must be escaped by doubling the backslash. Quotes themselves are removed after parsing and escape sequences substituted. In addition, a trailing backslash (&quot;\&quot;) may be used to merge lines.<div class="spacer">
</div>
This syntax is intended to be very similar to shell syntax, but only the meta-characters and expansions described in the following paragraphs are understood. Specifically, redirection using &quot;&lt;&quot;, &quot;&lt;&lt;&quot;, &quot;&gt;&quot;, and &quot;&gt;&gt;&quot;, pipes using &quot;|&quot;, running programs in the background using &quot;&amp;&quot;, and  <i>other elements of shell syntax are not supported</i>.<div class="spacer">
</div>
The command to execute must be an absolute path name. It may contain spaces, but control characters are not allowed.<div class="spacer">
</div>
The command line accepts &quot;%&quot; specifiers as described in  <b>systemd.unit</b>(5). Note that the first argument of the command line (i.e. the program to execute) may not include specifiers.<div class="spacer">
</div>
Basic environment variable substitution is supported. Use &quot;${FOO}&quot; as part of a word, or as a word of its own, on the command line, in which case it will be replaced by the value of the environment variable including all whitespace it contains, resulting in a single argument. Use &quot;$FOO&quot; as a separate word on the command line, in which case it will be replaced by the value of the environment variable split at whitespace resulting in zero or more arguments. For this type of expansion, quotes and respected when splitting into words, and afterwards removed.<div class="spacer">
</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
Environment=&quot;ONE=one&quot; 'TWO=two two'<br/>
ExecStart=/bin/echo $ONE $TWO ${TWO}<br/>
</div>
<div class="spacer">
</div>
This will execute  <b>/bin/echo</b> with four arguments: &quot;one&quot;, &quot;two&quot;, &quot;two&quot;, and &quot;two two&quot;.<div class="spacer">
</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
Environment=ONE='one' &quot;TWO='two&#160;two'&#160;too&quot; THREE=<br/>
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}<br/>
ExecStart=/bin/echo $ONE $TWO $THREE<br/>
</div>
<div class="spacer">
</div>
This results in echo being called twice, the first time with arguments &quot;'one'&quot;, &quot;'two&#160;two'&#160;too&quot;, &quot;&quot;, and the second time with arguments &quot;one&quot;, &quot;two&#160;two&quot;, &quot;too&quot;.<div class="spacer">
</div>
To pass a literal dollar sign, use &quot;$$&quot;. Variables whose value is not known at expansion time are treated as empty strings. Note that the first argument (i.e. the program to execute) may not be a variable.<div class="spacer">
</div>
Variables to be used in this fashion may be defined through  <i>Environment=</i> and  <i>EnvironmentFile=</i>. In addition, variables listed in the section &quot;Environment variables in spawned processes&quot; in  <b>systemd.exec</b>(5), which are considered &quot;static configuration&quot;, may be used (this includes e.g.  <i>$USER</i>, but not  <i>$TERM</i>).<div class="spacer">
</div>
Note that shell command lines are not directly supported. If shell command lines are to be used, they need to be passed explicitly to a shell implementation of some kind. Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
ExecStart=/bin/sh -c 'dmesg | tac'<br/>
</div>
<div class="spacer">
</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
ExecStart=/bin/echo one ; /bin/echo &quot;two two&quot;<br/>
</div>
<div class="spacer">
</div>
This will execute  <b>/bin/echo</b> two times, each time with one argument: &quot;one&quot; and &quot;two two&quot;, respectively. Because two commands are specified,  <i>Type=oneshot</i> must be used.<div class="spacer">
</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
ExecStart=/bin/echo / &gt;/dev/null &amp; \; \<br/>
/bin/ls<br/>
</div>
<div class="spacer">
</div>
This will execute  <b>/bin/echo</b> with five arguments: &quot;/&quot;, &quot;&gt;/dev/null&quot;, &quot;&amp;&quot;, &quot;;&quot;, and &quot;/bin/ls&quot;.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
<b>Table&#160;2.&#160;C escapes supported in command lines and environment variables</b><table class="tbl">
<col style="width: 13.00ex;"/>
<col style="width: 49.00ex;"/>
<tbody>
<tr>
<td>
Literal</td>
<td>
Actual value</td>
</tr>
<tr>
<td>
&quot;\a&quot;</td>
<td>
bell</td>
</tr>
<tr>
<td>
&quot;\b&quot;</td>
<td>
backspace</td>
</tr>
<tr>
<td>
&quot;\f&quot;</td>
<td>
form feed</td>
</tr>
<tr>
<td>
&quot;\n&quot;</td>
<td>
newline</td>
</tr>
<tr>
<td>
&quot;\r&quot;</td>
<td>
carriage return</td>
</tr>
<tr>
<td>
&quot;\t&quot;</td>
<td>
tab</td>
</tr>
<tr>
<td>
&quot;\v&quot;</td>
<td>
vertical tab</td>
</tr>
<tr>
<td>
&quot;\\&quot;</td>
<td>
backslash</td>
</tr>
<tr>
<td>
&quot;\&quot;&quot;</td>
<td>
double quotation mark</td>
</tr>
<tr>
<td>
&quot;\'&quot;</td>
<td>
single quotation mark</td>
</tr>
<tr>
<td>
&quot;\s&quot;</td>
<td>
space</td>
</tr>
<tr>
<td>
&quot;\x<i>xx</i>&quot;</td>
<td>
character number <i>xx</i> in hexadecimal encoding</td>
</tr>
<tr>
<td>
&quot;\<i>nnn</i>&quot;</td>
<td>
character number <i>nnn</i> in octal encoding</td>
</tr>
</tbody>
</table>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>EXAMPLES</h1>  <b>Example&#160;1.&#160;Simple service</b><div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
The following unit file creates a service that will execute /usr/sbin/foo-daemon. Since no  <i>Type=</i> is specified, the default  <i>Type=</i><b>simple</b> will be assumed. systemd will assume the unit to be started immediately after the program has begun executing.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Foo<div class="spacer">
</div>
<br/>
[Service]<br/>
ExecStart=/usr/sbin/foo-daemon<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
Note that systemd assumes here that the process started by systemd will continue running until the service terminates. If the program daemonizes itself (i.e. forks), please use  <i>Type=</i><b>forking</b> instead.<div class="spacer">
</div>
Since no  <i>ExecStop=</i> was specified, systemd will send SIGTERM to all processes started from this service, and after a timeout also SIGKILL. This behavior can be modified, see  <b>systemd.kill</b>(5) for details.<div class="spacer">
</div>
Note that this unit type does not include any type of notification when a service has completed initialization. For this, you should use other unit types, such as  <i>Type=</i><b>notify</b> if the service understands systemd's notification protocol,  <i>Type=</i><b>forking</b> if the service can background itself or  <i>Type=</i><b>dbus</b> if the unit acquires a DBus name once initialization is complete. See below.<div class="spacer">
</div>
<b>Example&#160;2.&#160;Oneshot service</b><div class="spacer">
</div>
Sometimes units should just execute an action without keeping active processes, such as a filesystem check or a cleanup action on boot. For this,  <i>Type=</i><b>oneshot</b> exists. Units of this type will wait until the process specified terminates and then fall back to being inactive. The following unit will perform a cleanup action:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Cleanup old Foo data<div class="spacer">
</div>
<br/>
[Service]<br/>
Type=oneshot<br/>
ExecStart=/usr/sbin/foo-cleanup<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
Note that systemd will consider the unit to be in the state 'starting' until the program has terminated, so ordered dependencies will wait for the program to finish before starting themselves. The unit will revert to the 'inactive' state after the execution is done, never reaching the 'active' state. That means another request to start the unit will perform the action again.<div class="spacer">
</div>
<i>Type=</i><b>oneshot</b> are the only service units that may have more than one  <i>ExecStart=</i> specified. They will be executed in order until either they are all successful or one of them fails.<div class="spacer">
</div>
<b>Example&#160;3.&#160;Stoppable oneshot service</b><div class="spacer">
</div>
Similarly to the oneshot services, there are sometimes units that need to execute a program to set up something and then execute another to shut it down, but no process remains active while they are considered 'started'. Network configuration can sometimes fall into this category. Another use case is if a oneshot service shall not be executed a each time when they are pulled in as a dependency, but only the first time.<div class="spacer">
</div>
For this, systemd knows the setting  <i>RemainAfterExit=</i><b>yes</b>, which causes systemd to consider the unit to be active if the start action exited successfully. This directive can be used with all types, but is most useful with  <i>Type=</i><b>oneshot</b> and  <i>Type=</i><b>simple</b>. With  <i>Type=</i><b>oneshot</b> systemd waits until the start action has completed before it considers the unit to be active, so dependencies start only after the start action has succeeded. With  <i>Type=</i><b>simple</b> dependencies will start immediately after the start action has been dispatched. The following unit provides an example for a simple static firewall.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Simple firewall<div class="spacer">
</div>
<br/>
[Service]<br/>
Type=oneshot<br/>
RemainAfterExit=yes<br/>
ExecStart=/usr/local/sbin/simple-firewall-start<br/>
ExecStop=/usr/local/sbin/simple-firewall-stop<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
Since the unit is considered to be running after the start action has exited, invoking  <b>systemctl start</b> on that unit again will cause no action to be taken.<div class="spacer">
</div>
<b>Example&#160;4.&#160;Traditional forking services</b><div class="spacer">
</div>
Many traditional daemons/services background (i.e. fork, daemonize) themselves when starting. Set  <i>Type=</i><b>forking</b> in the service's unit file to support this mode of operation. systemd will consider the service to be in the process of initialization while the original program is still running. Once it exits successfully and at least a process remains (and  <i>RemainAfterExit=</i><b>no</b>), the service is considered started.<div class="spacer">
</div>
Often a traditional daemon only consists of one process. Therefore, if only one process is left after the original process terminates, systemd will consider that process the main process of the service. In that case, the  <i>$MAINPID</i> variable will be available in  <i>ExecReload=</i>,  <i>ExecStop=</i>, etc.<div class="spacer">
</div>
In case more than one process remains, systemd will be unable to determine the main process, so it will not assume there is one. In that case,  <i>$MAINPID</i> will not expand to anything. However, if the process decides to write a traditional PID file, systemd will be able to read the main PID from there. Please set  <i>PIDFile=</i> accordingly. Note that the daemon should write that file before finishing with its initialization, otherwise systemd might try to read the file before it exists.<div class="spacer">
</div>
The following example shows a simple daemon that forks and just starts one process in the background:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Some simple daemon<div class="spacer">
</div>
<br/>
[Service]<br/>
Type=forking<br/>
ExecStart=/usr/sbin/my-simple-daemon -d<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
Please see  <b>systemd.kill</b>(5) for details on how you can influence the way systemd terminates the service.<div class="spacer">
</div>
<b>Example&#160;5.&#160;DBus services</b><div class="spacer">
</div>
For services that acquire a name on the DBus system bus, use  <i>Type=</i><b>dbus</b> and set  <i>BusName=</i> accordingly. The service should not fork (daemonize). systemd will consider the service to be initialized once the name has been acquired on the system bus. The following example shows a typical DBus service:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Simple DBus service<div class="spacer">
</div>
<br/>
[Service]<br/>
Type=dbus<br/>
BusName=org.example.simple-dbus-service<br/>
ExecStart=/usr/sbin/simple-dbus-service<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
For  <i>bus-activatable</i> services, don't include a &quot;[Install]&quot; section in the systemd service file, but use the  <i>SystemdService=</i> option in the corresponding DBus service file, for example (/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service):<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[D-BUS Service]<br/>
Name=org.example.simple-dbus-service<br/>
Exec=/usr/sbin/simple-dbus-service<br/>
User=root<br/>
SystemdService=simple-dbus-service.service<br/>
</div>
<div class="spacer">
</div>
Please see  <b>systemd.kill</b>(5) for details on how you can influence the way systemd terminates the service.<div class="spacer">
</div>
<b>Example&#160;6.&#160;Services that notify systemd about their initialization</b><div class="spacer">
</div>
<i>Type=</i><b>simple</b> services are really easy to write, but have the major disadvantage of systemd not being able to tell when initialization of the given service is complete. For this reason, systemd supports a simple notification protocol that allows daemons to make systemd aware that they are done initializing. Use  <i>Type=</i><b>notify</b> for this. A typical service file for such a daemon would look like this:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
[Unit]<br/>
Description=Simple notifying service<div class="spacer">
</div>
<br/>
[Service]<br/>
Type=notify<br/>
ExecStart=/usr/sbin/simple-notifying-service<div class="spacer">
</div>
<br/>
[Install]<br/>
WantedBy=multi-user.target<br/>
</div>
<div class="spacer">
</div>
Note that the daemon has to support systemd's notification protocol, else systemd will think the service hasn't started yet and kill it after a timeout. For an example of how to update daemons to support this protocol transparently, take a look at  <b>sd_notify</b>(3). systemd will consider the unit to be in the 'starting' state until a readiness notification has arrived.<div class="spacer">
</div>
Please see  <b>systemd.kill</b>(5) for details on how you can influence the way systemd terminates the service.</div>
<div class="section">
<h1>SEE ALSO</h1><div style="height: 1.00em;">
&#160;</div>
<b>systemd</b>(1),  <b>systemctl</b>(1),  <b>systemd.unit</b>(5),  <b>systemd.exec</b>(5),  <b>systemd.resource-control</b>(5),  <b>systemd.kill</b>(5),  <b>systemd.directives</b>(7)</div>
<div class="section">
<h1>NOTES</h1><dl>
<dt>
 1.</dt>
<dd>
Incompatibilities with SysV</dd>
</dl>
<div style="margin-left: 4.00ex;">
http://www.freedesktop.org/wiki/Software/systemd/Incompatibilities</div>
<dl>
<dt>
 2.</dt>
<dd>
Proper handling of SIGINT/SIGQUIT &#8212; How to be a proper program</dd>
</dl>
<div style="margin-left: 4.00ex;">
http://www.cons.org/cracauer/sigint.html</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
</td>
<td class="foot-os">
systemd 226</td>
</tr>
</table>
</div>
</body>
</html>

