<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
DLSYM(3P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DLSYM(3P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
DLSYM(3P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>NAME</h1> dlsym &#8212; get the address of a symbol from a symbol table handle</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
#include &lt;dlfcn.h&gt;<div class="spacer">
</div>
void *dlsym(void *restrict <i>handle</i>, const char *restrict <i>name</i>);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>dlsym</i>() function shall obtain the address of a symbol (a function identifier or a data object identifier) defined in the symbol table identified by the <i>handle</i> argument. The <i>handle</i> argument is a symbol table handle returned from a call to  <i>dlopen</i>() (and which has not since been released by a call to  <i>dlclose</i>()), and <i>name</i> is the symbol's name as a character string. The return value from  <i>dlsym</i>(), cast to a pointer to the type of the named symbol, can be used to call (in the case of a function) or access the contents of (in the case of a data object) the named symbol.<div class="spacer">
</div>
The  <i>dlsym</i>() function shall search for the named symbol in the symbol table referenced by <i>handle</i>. If the symbol table was created with lazy loading (see RTLD_LAZY in  <i>dlopen</i>()), load ordering shall be used in  <i>dlsym</i>() operations to relocate executable object files needed to resolve the symbol. The symbol resolution algorithm used shall be dependency order as described in  <i>dlopen</i>().<div class="spacer">
</div>
The RTLD_DEFAULT and RTLD_NEXT symbolic constants (which may be defined in <i>&lt;dlfcn.h&gt;</i>) are reserved for future use as special values that applications may be allowed to use for <i>handle</i>.</div>
<div class="section">
<h1>RETURN VALUE</h1> Upon successful completion, if <i>name</i> names a function identifier,  <i>dlsym</i>() shall return the address of the function converted from type pointer to function to type pointer to <b>void</b>; otherwise,  <i>dlsym</i>() shall return the address of the data object associated with the data object identifier named by <i>name</i> converted from a pointer to the type of the data object to a pointer to <b>void</b>. If <i>handle</i> does not refer to a valid symbol table handle or if the symbol named by <i>name</i> cannot be found in the symbol table associated with <i>handle</i>,  <i>dlsym</i>() shall return a null pointer.<div class="spacer">
</div>
More detailed diagnostic information shall be available through  <i>dlerror</i>().</div>
<div class="section">
<h1>ERRORS</h1> No errors are defined.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>EXAMPLES</h1> The following example shows how  <i>dlopen</i>() and  <i>dlsym</i>() can be used to access either a function or a data object. For simplicity, error checking has been omitted.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>void *handle;</b><br/>
<b>int (*fptr)(int), *iptr, result;</b><br/>
<b>/* open the needed symbol table */</b><br/>
<b>handle = dlopen(&quot;/usr/home/me/libfoo.so&quot;, RTLD_LOCAL | RTLD_LAZY);</b><br/>
<b>/* find the address of the function my_function */</b><br/>
<b>fptr = (int (*)(int))dlsym(handle, &quot;my_function&quot;);</b><br/>
<b>/* find the address of the data object my_object */</b><br/>
<b>iptr = (int *)dlsym(handle, &quot;my_OBJ&quot;);</b><br/>
<b>/* invoke my_function, passing the value of my_OBJ as the parameter */</b><br/>
<b>result = (*fptr)(*iptr);</b><br/>
</div>
</div>
<div class="section">
<h1>APPLICATION USAGE</h1> The following special purpose values for <i>handle</i> are reserved for future use and have the indicated meanings:<dl>
<dt>
RTLD_DEFAULT</dt>
<dd>
The identifier lookup happens in the normal global scope; that is, a search for an identifier using <i>handle</i> would find the same definition as a direct use of this identifier in the program code.</dd>
</dl>
<dl>
<dt>
RTLD_NEXT</dt>
<dd>
Specifies the next executable object file after this one that defines <i>name</i>. This one refers to the executable object file containing the invocation of  <i>dlsym</i>(). The next executable object file is the one found upon the application of a load order symbol resolution algorithm (see  <i>dlopen</i>()). The next symbol is either one of global scope (because it was introduced as part of the original process image or because it was added with a  <i>dlopen</i>() operation including the RTLD_GLOBAL flag), or is in an executable object file that was included in the same  <i>dlopen</i>() operation that loaded this one.</dd>
</dl>
<div class="spacer">
</div>
The RTLD_NEXT flag is useful to navigate an intentionally created hierarchy of multiply-defined symbols created through interposition. For example, if a program wished to create an implementation of  <i>malloc</i>() that embedded some statistics gathering about memory allocations, such an implementation could use the real  <i>malloc</i>() definition to perform the memory allocation &#8212; and itself only embed the necessary logic to implement the statistics gathering function.<div class="spacer">
</div>
Note that conversion from a <b>void *</b> pointer to a function pointer as in:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>fptr = (int (*)(int))dlsym(handle, &quot;my_function&quot;);</b><br/>
</div>
<div class="spacer">
</div>
is not defined by the ISO&#160;C standard. This standard requires this conversion to work correctly on conforming implementations.</div>
<div class="section">
<h1>RATIONALE</h1> None.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1> <i><i>dlclose</i>()</i>, <i><i>dlerror</i>()</i>, <i><i>dlopen</i>()</i><div class="spacer">
</div>
The Base Definitions volume of POSIX.1&#8208;2008, <i><b>&lt;dlfcn.h&gt;</b></i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2013 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 7, Copyright (C) 2013 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. (This is POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.) In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.unix.org/online.html .<div style="height: 1.00em;">
&#160;</div>
Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see https://www.kernel.org/doc/man-pages/reporting_bugs.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2013</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

