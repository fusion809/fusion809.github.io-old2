<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
QUEUE(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SLIST_EMPTY</b>, <b class="name">SLIST_ENTRY</b>, <b class="name">SLIST_FIRST</b>, <b class="name">SLIST_FOREACH</b>, <b class="name">SLIST_FOREACH_SAFE</b>, <b class="name">SLIST_HEAD</b>, <b class="name">SLIST_HEAD_INITIALIZER</b>, <b class="name">SLIST_INIT</b>, <b class="name">SLIST_INSERT_AFTER</b>, <b class="name">SLIST_INSERT_HEAD</b>, <b class="name">SLIST_NEXT</b>, <b class="name">SLIST_REMOVE_HEAD</b>, <b class="name">SLIST_REMOVE</b>, <b class="name">STAILQ_CONCAT</b>, <b class="name">STAILQ_EMPTY</b>, <b class="name">STAILQ_ENTRY</b>, <b class="name">STAILQ_FIRST</b>, <b class="name">STAILQ_FOREACH</b>, <b class="name">STAILQ_FOREACH_SAFE</b>, <b class="name">STAILQ_HEAD</b>, <b class="name">STAILQ_HEAD_INITIALIZER</b>, <b class="name">STAILQ_INIT</b>, <b class="name">STAILQ_INSERT_AFTER</b>, <b class="name">STAILQ_INSERT_HEAD</b>, <b class="name">STAILQ_INSERT_TAIL</b>, <b class="name">STAILQ_LAST</b>, <b class="name">STAILQ_NEXT</b>, <b class="name">STAILQ_REMOVE_HEAD</b>, <b class="name">STAILQ_REMOVE</b>, <b class="name">LIST_EMPTY</b>, <b class="name">LIST_ENTRY</b>, <b class="name">LIST_FIRST</b>, <b class="name">LIST_FOREACH</b>, <b class="name">LIST_FOREACH_SAFE</b>, <b class="name">LIST_HEAD</b>, <b class="name">LIST_HEAD_INITIALIZER</b>, <b class="name">LIST_INIT</b>, <b class="name">LIST_INSERT_AFTER</b>, <b class="name">LIST_INSERT_BEFORE</b>, <b class="name">LIST_INSERT_HEAD</b>, <b class="name">LIST_NEXT</b>, <b class="name">LIST_REMOVE</b>, <b class="name">TAILQ_CONCAT</b>, <b class="name">TAILQ_EMPTY</b>, <b class="name">TAILQ_ENTRY</b>, <b class="name">TAILQ_FIRST</b>, <b class="name">TAILQ_FOREACH</b>, <b class="name">TAILQ_FOREACH_SAFE</b>, <b class="name">TAILQ_FOREACH_REVERSE</b>, <b class="name">TAILQ_FOREACH_REVERSE_SAFE</b>, <b class="name">TAILQ_HEAD</b>, <b class="name">TAILQ_HEAD_INITIALIZER</b>, <b class="name">TAILQ_INIT</b>, <b class="name">TAILQ_INSERT_AFTER</b>, <b class="name">TAILQ_INSERT_BEFORE</b>, <b class="name">TAILQ_INSERT_HEAD</b>, <b class="name">TAILQ_INSERT_TAIL</b>, <b class="name">TAILQ_LAST</b>, <b class="name">TAILQ_NEXT</b>, <b class="name">TAILQ_PREV</b>, <b class="name">TAILQ_REMOVE</b> &#8212; <span class="desc">implementations of singly-linked lists, singly-linked tail queues, lists and tail queues</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/queue.h</a>&gt;</b><div class="spacer">
</div>
<b class="fname">SLIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">SLIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SLIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">SLIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *temp_var</i>);<div class="spacer">
</div>
<b class="fname">SLIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SLIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD head</i>);<div class="spacer">
</div>
<b class="fname">SLIST_INIT</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">SLIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head2</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *temp_var</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD head</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_INIT</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_LAST</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">STAILQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">LIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">LIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">LIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *temp_var</i>);<div class="spacer">
</div>
<b class="fname">LIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">LIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD head</i>);<div class="spacer">
</div>
<b class="fname">LIST_INIT</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">LIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head2</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *temp_var</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_REVERSE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_REVERSE_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *temp_var</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD head</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_INIT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_LAST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_PREV</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These macros define and operate on four types of data structures: singly-linked lists, singly-linked tail queues, lists, and tail queues. All four structures support the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry at the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry after any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
O(1) removal of an entry from the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Forward traversal through the list.</li>
</ol>
<div class="spacer">
</div>
O(n) removal of any entry in the list. Singly-linked lists are the simplest of the four data structures and support only the above functionality. Singly-linked lists are ideal for applications with large datasets and few or no removals, or for implementing a LIFO queue. Singly-linked lists add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
O(n) removal of any entry in the list.</li>
</ol>
<div class="spacer">
</div>
Singly-linked tail queues add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
O(n) removal of any entry in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be concatenated.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="spacer">
</div>
Singly-linked tailqs are ideal for applications with large datasets and few or no removals, or for implementing a FIFO queue.<div class="spacer">
</div>
All doubly linked types of data structures (lists and tail queues) additionally allow:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry before any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
O(1) removal of any entry in the list.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Each elements requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size and execution time of operations (except for removal) is about twice that of the singly-linked data-structures.</li>
</ol>
<div class="spacer">
</div>
Linked lists are the simplest of the doubly linked data structures and support only the above functionality over singly-linked lists.<div class="spacer">
</div>
Tail queues add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be traversed backwards, from tail to head.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be concatenated.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions and removals must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="spacer">
</div>
In the macro definitions, <i class="farg">TYPE</i> is the name of a user defined structure, that must contain a field of type <code class="lit">SLIST_ENTRY</code>, <code class="lit">STAILQ_ENTRY</code>, <code class="lit">LIST_ENTRY</code>, or <code class="lit">TAILQ_ENTRY</code>, named <i class="farg">NAME</i>. The argument <i class="farg">HEADNAME</i> is the name of a user defined structure that must be declared using the macros <code class="lit">SLIST_HEAD</code>, <code class="lit">STAILQ_HEAD</code>, <code class="lit">LIST_HEAD</code>, or <code class="lit">TAILQ_HEAD</code>. See the examples below for further explanation of how these macros are used.</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c49535453">SINGLY-LINKED LISTS</h1> A singly-linked list is headed by a structure defined by the <b class="name">SLIST_HEAD</b> macro. This structure contains a single pointer to the first element on the list. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the list after an existing element or at the head of the list. An <i class="farg">SLIST_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The macro <b class="name">SLIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">SLIST_EMPTY</b> evaluates to true if there are no elements in the list.<div class="spacer">
</div>
The macro <b class="name">SLIST_ENTRY</b> declares a structure that connects the elements in the list.<div class="spacer">
</div>
The macro <b class="name">SLIST_FIRST</b> returns the first element in the list or NULL if the list is empty.<div class="spacer">
</div>
The macro <b class="name">SLIST_FOREACH</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<div class="spacer">
</div>
The macro <b class="name">SLIST_FOREACH_SAFE</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>. However, unlike <b class="fname">SLIST_FOREACH</b>() here it is permitted to both remove <i class="farg">var</i> as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The macro <b class="name">SLIST_INIT</b> initializes the list referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">SLIST_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the list.<div class="spacer">
</div>
The macro <b class="name">SLIST_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">SLIST_NEXT</b> returns the next element in the list.<div class="spacer">
</div>
The macro <b class="name">SLIST_REMOVE_HEAD</b> removes the element <i class="farg">elm</i> from the head of the list. For optimum efficiency, elements being removed from the head of the list should explicitly use this macro instead of the generic <i class="farg">SLIST_REMOVE</i> macro.<div class="spacer">
</div>
The macro <b class="name">SLIST_REMOVE</b> removes the element <i class="farg">elm</i> from the list.</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c495354204558414d504c45">SINGLY-LINKED LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
SLIST_HEAD(slisthead, entry) head = 
    SLIST_HEAD_INITIALIZER(head); 
struct slisthead *headp;		/* Singly-linked List head. */ 
struct entry { 
	... 
	SLIST_ENTRY(entry) entries;	/* Singly-linked List. */ 
	... 
} *n1, *n2, *n3, *np; 
 
SLIST_INIT(&amp;head);			/* Initialize the list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SLIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SLIST_INSERT_AFTER(n1, n2, entries); 
 
SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */ 
free(n2); 
 
n3 = SLIST_FIRST(&amp;head); 
SLIST_REMOVE_HEAD(&amp;head, entries);	/* Deletion from the head. */ 
free(n3); 
					/* Forward traversal. */ 
SLIST_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Safe forward traversal. */ 
SLIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) { 
	np-&gt;do_stuff(); 
	... 
	SLIST_REMOVE(&amp;head, np, entry, entries); 
	free(np); 
} 
 
while (!SLIST_EMPTY(&amp;head)) {		/* List Deletion. */ 
	n1 = SLIST_FIRST(&amp;head); 
	SLIST_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
}</pre>
</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544205441494c20515545554553">SINGLY-LINKED TAIL QUEUES</h1> A singly-linked tail queue is headed by a structure defined by the <b class="name">STAILQ_HEAD</b> macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the tail queue after an existing element, at the head of the tail queue, or at the end of the tail queue. A <i class="farg">STAILQ_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
STAILQ_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <code class="lit">HEADNAME</code> is the name of the structure to be defined, and <code class="lit">TYPE</code> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The macro <b class="name">STAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">STAILQ_CONCAT</b> concatenates the tail queue headed by <i class="farg">head2</i> onto the end of the one headed by <i class="farg">head1</i> removing all entries from the former.<div class="spacer">
</div>
The macro <b class="name">STAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.<div class="spacer">
</div>
The macro <b class="name">STAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.<div class="spacer">
</div>
The macro <b class="name">STAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.<div class="spacer">
</div>
The macro <b class="name">STAILQ_FOREACH</b> traverses the tail queue referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<div class="spacer">
</div>
The macro <b class="name">STAILQ_FOREACH_SAFE</b> traverses the tail queue referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>. However, unlike <b class="fname">STAILQ_FOREACH</b>() here it is permitted to both remove <i class="farg">var</i> as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The macro <b class="name">STAILQ_INIT</b> initializes the tail queue referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">STAILQ_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the tail queue.<div class="spacer">
</div>
The macro <b class="name">STAILQ_INSERT_TAIL</b> inserts the new element <i class="farg">elm</i> at the end of the tail queue.<div class="spacer">
</div>
The macro <b class="name">STAILQ_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">STAILQ_LAST</b> returns the last item on the tail queue. If the tail queue is empty the return value is <span class="define">NULL</span>.<div class="spacer">
</div>
The macro <b class="name">STAILQ_NEXT</b> returns the next item on the tail queue, or NULL this item is the last.<div class="spacer">
</div>
The macro <b class="name">STAILQ_REMOVE_HEAD</b> removes the element at the head of the tail queue. For optimum efficiency, elements being removed from the head of the tail queue should use this macro explicitly rather than the generic <i class="farg">STAILQ_REMOVE</i> macro.<div class="spacer">
</div>
The macro <b class="name">STAILQ_REMOVE</b> removes the element <i class="farg">elm</i> from the tail queue.</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544205441494c205155455545204558414d504c45">SINGLY-LINKED TAIL QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
STAILQ_HEAD(stailhead, entry) head = 
    STAILQ_HEAD_INITIALIZER(head); 
struct stailhead *headp;		/* Singly-linked tail queue head. */ 
struct entry { 
	... 
	STAILQ_ENTRY(entry) entries;	/* Tail queue. */ 
	... 
} *n1, *n2, *n3, *np; 
 
STAILQ_INIT(&amp;head);			/* Initialize the queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
STAILQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
STAILQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
					/* Deletion. */ 
STAILQ_REMOVE(&amp;head, n2, entry, entries); 
free(n2); 
					/* Deletion from the head. */ 
n3 = STAILQ_FIRST(&amp;head); 
STAILQ_REMOVE_HEAD(&amp;head, entries); 
free(n3); 
					/* Forward traversal. */ 
STAILQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Safe forward traversal. */ 
STAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) { 
	np-&gt;do_stuff(); 
	... 
	STAILQ_REMOVE(&amp;head, np, entry, entries); 
	free(np); 
} 
					/* TailQ Deletion. */ 
while (!STAILQ_EMPTY(&amp;head)) { 
	n1 = STAILQ_FIRST(&amp;head); 
	STAILQ_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
} 
					/* Faster TailQ Deletion. */ 
n1 = STAILQ_FIRST(&amp;head); 
while (n1 != NULL) { 
	n2 = STAILQ_NEXT(n1, entries); 
	free(n1); 
	n1 = n2; 
} 
STAILQ_INIT(&amp;head);</pre>
</div>
<div class="section">
<h1 id="x4c49535453">LISTS</h1> A list is headed by a structure defined by the <b class="name">LIST_HEAD</b> macro. This structure contains a single pointer to the first element on the list. The elements are doubly linked so that an arbitrary element can be removed without traversing the list. New elements can be added to the list after an existing element, before an existing element, or at the head of the list. A <i class="farg">LIST_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The macro <b class="name">LIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">LIST_EMPTY</b> evaluates to true if there are no elements in the list.<div class="spacer">
</div>
The macro <b class="name">LIST_ENTRY</b> declares a structure that connects the elements in the list.<div class="spacer">
</div>
The macro <b class="name">LIST_FIRST</b> returns the first element in the list or NULL if the list is empty.<div class="spacer">
</div>
The macro <b class="name">LIST_FOREACH</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<div class="spacer">
</div>
The macro <b class="name">LIST_FOREACH_SAFE</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>. However, unlike <b class="fname">LIST_FOREACH</b>() here it is permitted to both remove <i class="farg">var</i> as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The macro <b class="name">LIST_INIT</b> initializes the list referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">LIST_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the list.<div class="spacer">
</div>
The macro <b class="name">LIST_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">LIST_INSERT_BEFORE</b> inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">LIST_NEXT</b> returns the next element in the list, or NULL if this is the last.<div class="spacer">
</div>
The macro <b class="name">LIST_REMOVE</b> removes the element <i class="farg">elm</i> from the list.</div>
<div class="section">
<h1 id="x4c495354204558414d504c45">LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
LIST_HEAD(listhead, entry) head = 
    LIST_HEAD_INITIALIZER(head); 
struct listhead *headp;			/* List head. */ 
struct entry { 
	... 
	LIST_ENTRY(entry) entries;	/* List. */ 
	... 
} *n1, *n2, *n3, *np, *np_temp; 
 
LIST_INIT(&amp;head);			/* Initialize the list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
LIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
LIST_INSERT_AFTER(n1, n2, entries); 
 
n3 = malloc(sizeof(struct entry));	/* Insert before. */ 
LIST_INSERT_BEFORE(n2, n3, entries); 
 
LIST_REMOVE(n2, entries);		/* Deletion. */ 
free(n2); 
					/* Forward traversal. */ 
LIST_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
 
					/* Safe forward traversal. */ 
LIST_FOREACH_SAFE(np, &amp;head, entries, np_temp) { 
	np-&gt;do_stuff(); 
	... 
	LIST_REMOVE(np, entries); 
	free(np); 
} 
 
while (!LIST_EMPTY(&amp;head)) {		/* List Deletion. */ 
	n1 = LIST_FIRST(&amp;head); 
	LIST_REMOVE(n1, entries); 
	free(n1); 
} 
 
n1 = LIST_FIRST(&amp;head);			/* Faster List Deletion. */ 
while (n1 != NULL) { 
	n2 = LIST_NEXT(n1, entries); 
	free(n1); 
	n1 = n2; 
} 
LIST_INIT(&amp;head);</pre>
</div>
<div class="section">
<h1 id="x5441494c20515545554553">TAIL QUEUES</h1> A tail queue is headed by a structure defined by the <b class="name">TAILQ_HEAD</b> macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are doubly linked so that an arbitrary element can be removed without traversing the tail queue. New elements can be added to the tail queue after an existing element, before an existing element, at the head of the tail queue, or at the end of the tail queue. A <i class="farg">TAILQ_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
TAILQ_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <code class="lit">HEADNAME</code> is the name of the structure to be defined, and <code class="lit">TYPE</code> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The macro <b class="name">TAILQ_HEAD_INITIALIZER</b> evaluates to an initializer for the tail queue <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">TAILQ_CONCAT</b> concatenates the tail queue headed by <i class="farg">head2</i> onto the end of the one headed by <i class="farg">head1</i> removing all entries from the former.<div class="spacer">
</div>
The macro <b class="name">TAILQ_EMPTY</b> evaluates to true if there are no items on the tail queue.<div class="spacer">
</div>
The macro <b class="name">TAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.<div class="spacer">
</div>
The macro <b class="name">TAILQ_FIRST</b> returns the first item on the tail queue or NULL if the tail queue is empty.<div class="spacer">
</div>
The macro <b class="name">TAILQ_FOREACH</b> traverses the tail queue referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>. <i class="farg">var</i> is set to <span class="define">NULL</span> if the loop completes normally, or if there were no elements.<div class="spacer">
</div>
The macro <b class="name">TAILQ_FOREACH_REVERSE</b> traverses the tail queue referenced by <i class="farg">head</i> in the reverse direction, assigning each element in turn to <i class="farg">var</i>.<div class="spacer">
</div>
The macros <b class="name">TAILQ_FOREACH_SAFE</b> and <b class="name">TAILQ_FOREACH_REVERSE_SAFE</b> traverse the list referenced by <i class="farg">head</i> in the forward or reverse direction respectively, assigning each element in turn to <i class="farg">var</i>. However, unlike their unsafe counterparts, <b class="name">TAILQ_FOREACH</b> and <b class="name">TAILQ_FOREACH_REVERSE</b> permit to both remove <i class="farg">var</i> as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The macro <b class="name">TAILQ_INIT</b> initializes the tail queue referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The macro <b class="name">TAILQ_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the tail queue.<div class="spacer">
</div>
The macro <b class="name">TAILQ_INSERT_TAIL</b> inserts the new element <i class="farg">elm</i> at the end of the tail queue.<div class="spacer">
</div>
The macro <b class="name">TAILQ_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">TAILQ_INSERT_BEFORE</b> inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The macro <b class="name">TAILQ_LAST</b> returns the last item on the tail queue. If the tail queue is empty the return value is <span class="define">NULL</span>.<div class="spacer">
</div>
The macro <b class="name">TAILQ_NEXT</b> returns the next item on the tail queue, or NULL if this item is the last.<div class="spacer">
</div>
The macro <b class="name">TAILQ_PREV</b> returns the previous item on the tail queue, or NULL if this item is the first.<div class="spacer">
</div>
The macro <b class="name">TAILQ_REMOVE</b> removes the element <i class="farg">elm</i> from the tail queue.</div>
<div class="section">
<h1 id="x5441494c205155455545204558414d504c45">TAIL QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
TAILQ_HEAD(tailhead, entry) head = 
    TAILQ_HEAD_INITIALIZER(head); 
struct tailhead *headp;			/* Tail queue head. */ 
struct entry { 
	... 
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */ 
	... 
} *n1, *n2, *n3, *np; 
 
TAILQ_INIT(&amp;head);			/* Initialize the queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
TAILQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
TAILQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n3 = malloc(sizeof(struct entry));	/* Insert before. */ 
TAILQ_INSERT_BEFORE(n2, n3, entries); 
 
TAILQ_REMOVE(&amp;head, n2, entries);	/* Deletion. */ 
free(n2); 
					/* Forward traversal. */ 
TAILQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Safe forward traversal. */ 
TAILQ_FOREACH_SAFE(np, &amp;head, entries, np_temp) { 
	np-&gt;do_stuff(); 
	... 
	TAILQ_REMOVE(&amp;head, np, entries); 
	free(np); 
} 
					/* Reverse traversal. */ 
TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries) 
	np-&gt; ... 
					/* TailQ Deletion. */ 
while (!TAILQ_EMPTY(&amp;head)) { 
	n1 = TAILQ_FIRST(&amp;head); 
	TAILQ_REMOVE(&amp;head, n1, entries); 
	free(n1); 
} 
					/* Faster TailQ Deletion. */ 
n1 = TAILQ_FIRST(&amp;head); 
while (n1 != NULL) { 
	n2 = TAILQ_NEXT(n1, entries); 
	free(n1); 
	n1 = n2; 
} 
TAILQ_INIT(&amp;head);</pre>
</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">queue</b> functions first appeared in <span class="unix">4.4BSD</span>.</div>
</div>
</body>
</html>

