<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
PTRACE(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PTRACE(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
PTRACE(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> ptrace - process trace</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/ptrace.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>long ptrace(enum __ptrace_request </b><i>request</i><b>, pid_t </b><i>pid</i><b>, </b><br/>
<b>            void *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The <b>ptrace</b>() system call provides a means by which one process (the &quot;tracer&quot;) may observe and control the execution of another process (the &quot;tracee&quot;), and examine and change the tracee's memory and registers. It is primarily used to implement breakpoint debugging and system call tracing.<div class="spacer">
</div>
A tracee first needs to be attached to the tracer. Attachment and subsequent commands are per thread: in a multithreaded process, every thread can be individually attached to a (potentially different) tracer, or left not attached and thus not debugged. Therefore, &quot;tracee&quot; always means &quot;(one) thread&quot;, never &quot;a (possibly multithreaded) process&quot;. Ptrace commands are always sent to a specific tracee using a call of the form<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_foo, pid, ...)<div style="height: 1.00em;">
&#160;</div>
where <i>pid</i> is the thread ID of the corresponding Linux thread.<div class="spacer">
</div>
(Note that in this page, a &quot;multithreaded process&quot; means a thread group consisting of threads created using the <b>clone</b>(2) <b>CLONE_THREAD</b> flag.)<div class="spacer">
</div>
A process can initiate a trace by calling <b>fork</b>(2) and having the resulting child do a <b>PTRACE_TRACEME</b>, followed (typically) by an <b>execve</b>(2). Alternatively, one process may commence tracing another process using <b>PTRACE_ATTACH</b> or <b>PTRACE_SEIZE</b>.<div class="spacer">
</div>
While being traced, the tracee will stop each time a signal is delivered, even if the signal is being ignored. (An exception is <b>SIGKILL</b>, which has its usual effect.) The tracer will be notified at its next call to <b>waitpid</b>(2) (or one of the related &quot;wait&quot; system calls); that call will return a <i>status</i> value containing information that indicates the cause of the stop in the tracee. While the tracee is stopped, the tracer can use various ptrace requests to inspect and modify the tracee. The tracer then causes the tracee to continue, optionally ignoring the delivered signal (or even delivering a different signal instead).<div class="spacer">
</div>
If the <b>PTRACE_O_TRACEEXEC</b> option is not in effect, all successful calls to <b>execve</b>(2) by the traced process will cause it to be sent a <b>SIGTRAP</b> signal, giving the parent a chance to gain control before the new program begins execution.<div class="spacer">
</div>
When the tracer is finished tracing, it can cause the tracee to continue executing in a normal, untraced mode via <b>PTRACE_DETACH</b>.<div class="spacer">
</div>
The value of <i>request</i> determines the action to be performed:<dl>
<dt>
<b>PTRACE_TRACEME</b></dt>
<dd>
Indicate that this process is to be traced by its parent. A process probably shouldn't make this request if its parent isn't expecting to trace it. (<i>pid</i>, <i>addr</i>, and <i>data</i> are ignored.)</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The <b>PTRACE_TRACEME</b> request is used only by the tracee; the remaining requests are used only by the tracer. In the following requests, <i>pid</i> specifies the thread ID of the tracee to be acted on. For requests other than <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>, the tracee must be stopped.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b></dt>
<dd>
Read a word at the address <i>addr</i> in the tracee's memory, returning the word as the result of the <b>ptrace</b>() call. Linux does not have separate text and data address spaces, so these two requests are currently equivalent. (<i>data</i> is ignored; but see NOTES.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_PEEKUSER</b></dt>
<dd>
Read a word at offset <i>addr</i> in the tracee's USER area, which holds the registers and other information about the process (see <i>&lt;sys/user.h&gt;</i>). The word is returned as the result of the <b>ptrace</b>() call. Typically, the offset must be word-aligned, though this might vary by architecture. See NOTES. (<i>data</i> is ignored; but see NOTES.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_POKETEXT</b>, <b>PTRACE_POKEDATA</b></dt>
<dd>
Copy the word <i>data</i> to the address <i>addr</i> in the tracee's memory. As for <b>PTRACE_PEEKTEXT</b> and <b>PTRACE_PEEKDATA</b>, these two requests are currently equivalent.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_POKEUSER</b></dt>
<dd>
Copy the word <i>data</i> to offset <i>addr</i> in the tracee's USER area. As for <b>PTRACE_PEEKUSER</b>, the offset must typically be word-aligned. In order to maintain the integrity of the kernel, some modifications to the USER area are disallowed.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_GETREGS</b>, <b>PTRACE_GETFPREGS</b></dt>
<dd>
Copy the tracee's general-purpose or floating-point registers, respectively, to the address <i>data</i> in the tracer. See <i>&lt;sys/user.h&gt;</i> for information on the format of this data. (<i>addr</i> is ignored.) Note that SPARC systems have the meaning of <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is ignored and the registers are copied to the address <i>addr</i>. <b>PTRACE_GETREGS</b> and <b>PTRACE_GETFPREGS</b> are not present on all architectures.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_GETREGSET</b> (since Linux 2.6.34)</dt>
<dd>
Read the tracee's registers. <i>addr</i> specifies, in an architecture-dependent way, the type of registers to be read. <b>NT_PRSTATUS</b> (with numerical value 1) usually results in reading of general-purpose registers. If the CPU has, for example, floating-point and/or vector registers, they can be retrieved by setting <i>addr</i> to the corresponding <b>NT_foo</b> constant. <i>data</i> points to a <b>struct iovec</b>, which describes the destination buffer's location and length. On return, the kernel modifies <b>iov.len</b> to indicate the actual number of bytes returned.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SETREGS</b>, <b>PTRACE_SETFPREGS</b></dt>
<dd>
Modify the tracee's general-purpose or floating-point registers, respectively, from the address <i>data</i> in the tracer. As for <b>PTRACE_POKEUSER</b>, some general-purpose register modifications may be disallowed. (<i>addr</i> is ignored.) Note that SPARC systems have the meaning of <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is ignored and the registers are copied from the address <i>addr</i>. <b>PTRACE_SETREGS</b> and <b>PTRACE_SETFPREGS</b> are not present on all architectures.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SETREGSET</b> (since Linux 2.6.34)</dt>
<dd>
Modify the tracee's registers. The meaning of <i>addr</i> and <i>data</i> is analogous to <b>PTRACE_GETREGSET</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_GETSIGINFO</b> (since Linux 2.3.99-pre6)</dt>
<dd>
Retrieve information about the signal that caused the stop. Copy a <i>siginfo_t</i> structure (see <b>sigaction</b>(2)) from the tracee to the address <i>data</i> in the tracer. (<i>addr</i> is ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SETSIGINFO</b> (since Linux 2.3.99-pre6)</dt>
<dd>
Set signal information: copy a <i>siginfo_t</i> structure from the address <i>data</i> in the tracer to the tracee. This will affect only signals that would normally be delivered to the tracee and were caught by the tracer. It may be difficult to tell these normal signals from synthetic signals generated by <b>ptrace</b>() itself. (<i>addr</i> is ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_PEEKSIGINFO</b> (since Linux 3.10)</dt>
<dd>
Retrieve <i>siginfo_t</i> structures without removing signals from a queue. <i>addr</i> points to a <i>ptrace_peeksiginfo_args</i> structure that specifies the ordinal position from which copying of signals should start, and the number of signals to copy. <i>siginfo_t</i> structures are copied into the buffer pointed to by <i>data</i>. The return value contains the number of copied signals (zero indicates that there is no signal corresponding to the specified ordinal position). Within the returned <i>siginfo</i> structures, the <i>si_code</i> field includes information (<b>__SI_CHLD</b>, <b>__SI_FAULT</b>, etc.) that are not otherwise exposed to user space.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<br/>
struct ptrace_peeksiginfo_args {<br/>
    u64 off;    /* Ordinal position in queue at which<br/>
                   to start copying signals */<br/>
    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */<br/>
    s32 nr;     /* Number of signals to copy */<br/>
};<br/>
<div style="height: 1.00em;">
&#160;</div>
Currently, there is only one flag, <b>PTRACE_PEEKSIGINFO_SHARED</b>, for dumping signals from the process-wide signal queue. If this flag is not set, signals are read from the per-thread queue of the specified thread.<br/>
<dl>
<dt>
<b>PTRACE_GETSIGMASK</b> (since Linux 3.11)</dt>
<dd>
Place a copy of the mask of blocked signals (see <b>sigprocmask</b>(2)) in the buffer pointed to by <i>data</i>, which should be a pointer to a buffer of type <i>sigset_t</i>. The <i>addr</i> argument contains the size of the buffer pointed to by <i>data</i> (i.e., <i>sizeof(sigset_t)</i>).</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SETSIGMASK</b> (since Linux 3.11)</dt>
<dd>
Change the mask of blocked signals (see <b>sigprocmask</b>(2)) to the value specified in the buffer pointed to by <i>data</i>, which should be a pointer to a buffer of type <i>sigset_t</i>. The <i>addr</i> argument contains the size of the buffer pointed to by <i>data</i> (i.e., <i>sizeof(sigset_t)</i>).</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SETOPTIONS</b> (since Linux 2.4.6; see BUGS for caveats)</dt>
<dd>
Set ptrace options from <i>data</i>. (<i>addr</i> is ignored.) <i>data</i> is interpreted as a bit mask of options, which are specified by the following flags:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>PTRACE_O_EXITKILL</b> (since Linux 3.8)</dt>
<dd>
If a tracer sets this flag, a <b>SIGKILL</b> signal will be sent to every tracee if the tracer exits. This option is useful for ptrace jailers that want to ensure that tracees can never escape the tracer's control.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACECLONE</b> (since Linux 2.5.46)</dt>
<dd>
Stop the tracee at the next <b>clone</b>(2) and automatically start tracing the newly cloned process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
This option may not catch <b>clone</b>(2) calls in all cases. If the tracee calls <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag, <b>PTRACE_EVENT_VFORK</b> will be delivered instead if <b>PTRACE_O_TRACEVFORK</b> is set; otherwise if the tracee calls <b>clone</b>(2) with the exit signal set to <b>SIGCHLD</b>, <b>PTRACE_EVENT_FORK</b> will be delivered if <b>PTRACE_O_TRACEFORK</b> is set.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACEEXEC</b> (since Linux 2.5.46)</dt>
<dd>
Stop the tracee at the next <b>execve</b>(2). A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
If the execing thread is not a thread group leader, the thread ID is reset to thread group leader's ID before this stop. Since Linux 3.0, the former thread ID can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACEEXIT</b> (since Linux 2.5.60)</dt>
<dd>
Stop the tracee at exit. A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
The tracee's exit status can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The tracee is stopped early during process exit, when registers are still available, allowing the tracer to see where the exit occurred, whereas the normal exit notification is done after the process is finished exiting. Even though context is available, the tracer cannot prevent the exit from happening at this point.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACEFORK</b> (since Linux 2.5.46)</dt>
<dd>
Stop the tracee at the next <b>fork</b>(2) and automatically start tracing the newly forked process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACESYSGOOD</b> (since Linux 2.4.6)</dt>
<dd>
When delivering system call traps, set bit 7 in the signal number (i.e., deliver <i>SIGTRAP|0x80</i>). This makes it easy for the tracer to distinguish normal traps from those caused by a system call. (<b>PTRACE_O_TRACESYSGOOD</b> may not work on all architectures.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACEVFORK</b> (since Linux 2.5.46)</dt>
<dd>
Stop the tracee at the next <b>vfork</b>(2) and automatically start tracing the newly vforked process, which will start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
The PID of the new process can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACEVFORKDONE</b> (since Linux 2.5.60)</dt>
<dd>
Stop the tracee at the completion of the next <b>vfork</b>(2). A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
The PID of the new process can (since Linux 2.6.18) be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_O_TRACESECCOMP</b> (since Linux 3.5)</dt>
<dd>
Stop the tracee when a <b>seccomp</b>(2) <b>SECCOMP_RET_TRACE</b> rule is triggered. A <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such that<div style="height: 1.00em;">
&#160;</div>
<br/>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))<br/>
<div style="height: 1.00em;">
&#160;</div>
While this triggers a <b>PTRACE_EVENT</b> stop, it is similar to a syscall-enter-stop, in that the tracee has not yet entered the syscall that seccomp triggered on. The seccomp event message data (from the <b>SECCOMP_RET_DATA</b> portion of the seccomp filter rule) can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
</div>
<dl>
<dt>
<b>PTRACE_GETEVENTMSG</b> (since Linux 2.5.46)</dt>
<dd>
Retrieve a message (as an <i>unsigned long</i>) about the ptrace event that just happened, placing it at the address <i>data</i> in the tracer. For <b>PTRACE_EVENT_EXIT</b>, this is the tracee's exit status. For <b>PTRACE_EVENT_FORK</b>, <b>PTRACE_EVENT_VFORK</b>, <b>PTRACE_EVENT_VFORK_DONE</b>, and <b>PTRACE_EVENT_CLONE</b>, this is the PID of the new process. For <b>PTRACE_EVENT_SECCOMP</b>, this is the <b>seccomp</b>(2) filter's <b>SECCOMP_RET_DATA</b> associated with the triggered rule. (<i>addr</i> is ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_CONT</b></dt>
<dd>
Restart the stopped tracee process. If <i>data</i> is nonzero, it is interpreted as the number of a signal to be delivered to the tracee; otherwise, no signal is delivered. Thus, for example, the tracer can control whether a signal sent to the tracee is delivered or not. (<i>addr</i> is ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b></dt>
<dd>
Restart the stopped tracee as for <b>PTRACE_CONT</b>, but arrange for the tracee to be stopped at the next entry to or exit from a system call, or after execution of a single instruction, respectively. (The tracee will also, as usual, be stopped upon receipt of a signal.) From the tracer's perspective, the tracee will appear to have been stopped by receipt of a <b>SIGTRAP</b>. So, for <b>PTRACE_SYSCALL</b>, for example, the idea is to inspect the arguments to the system call at the first stop, then do another <b>PTRACE_SYSCALL</b> and inspect the return value of the system call at the second stop. The <i>data</i> argument is treated as for <b>PTRACE_CONT</b>. (<i>addr</i> is ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SYSEMU</b>, <b>PTRACE_SYSEMU_SINGLESTEP</b> (since Linux 2.6.14)</dt>
<dd>
For <b>PTRACE_SYSEMU</b>, continue and stop on entry to the next system call, which will not be executed. For <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but also singlestep if not a system call. This call is used by programs like User Mode Linux that want to emulate all the tracee's system calls. The <i>data</i> argument is treated as for <b>PTRACE_CONT</b>. The <i>addr</i> argument is ignored. These requests are currently supported only on x86.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_LISTEN</b> (since Linux 3.4)</dt>
<dd>
Restart the stopped tracee, but prevent it from executing. The resulting state of the tracee is similar to a process which has been stopped by a <b>SIGSTOP</b> (or other stopping signal). See the &quot;group-stop&quot; subsection for additional information. <b>PTRACE_LISTEN</b> works only on tracees attached by <b>PTRACE_SEIZE</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_KILL</b></dt>
<dd>
Send the tracee a <b>SIGKILL</b> to terminate it. (<i>addr</i> and <i>data</i> are ignored.)</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<i>This operation is deprecated; do not use it!</i> Instead, send a <b>SIGKILL</b> directly using <b>kill</b>(2) or <b>tgkill</b>(2). The problem with <b>PTRACE_KILL</b> is that it requires the tracee to be in signal-delivery-stop, otherwise it may not work (i.e., may complete successfully but won't kill the tracee). By contrast, sending a <b>SIGKILL</b> directly has no such limitation.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_INTERRUPT</b> (since Linux 3.4)</dt>
<dd>
Stop a tracee. If the tracee is running or sleeping in kernel space and <b>PTRACE_SYSCALL</b> is in effect, the system call is interrupted and syscall-exit-stop is reported. (The interrupted system call is restarted when the tracee is restarted.) If the tracee was already stopped by a signal and <b>PTRACE_LISTEN</b> was sent to it, the tracee stops with <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns the stop signal. If any other ptrace-stop is generated at the same time (for example, if a signal is sent to the tracee), this ptrace-stop happens. If none of the above applies (for example, if the tracee is running in user space), it stops with <b>PTRACE_EVENT_STOP</b> with <i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>. <b>PTRACE_INTERRUPT</b> only works on tracees attached by <b>PTRACE_SEIZE</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_ATTACH</b></dt>
<dd>
Attach to the process specified in <i>pid</i>, making it a tracee of the calling process. The tracee is sent a <b>SIGSTOP</b>, but will not necessarily have stopped by the completion of this call; use <b>waitpid</b>(2) to wait for the tracee to stop. See the &quot;Attaching and detaching&quot; subsection for additional information. (<i>addr</i> and <i>data</i> are ignored.)</dd>
</dl>
<dl>
<dt>
<b>PTRACE_SEIZE</b> (since Linux 3.4)</dt>
<dd>
Attach to the process specified in <i>pid</i>, making it a tracee of the calling process. Unlike <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b> does not stop the process. Group-stops are reported as <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns the stop signal. Automatically attached children stop with <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b> instead of having <b>SIGSTOP</b> signal delivered to them. <b>evecve</b>(2) does not deliver an extra <b>SIGTRAP</b>. Only a <b>PTRACE_SEIZE</b>d process can accept <b>PTRACE_INTERRUPT</b> and <b>PTRACE_LISTEN</b> commands. The &quot;seized&quot; behavior just described is inherited by children that are automatically attached using <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, and <b>PTRACE_O_TRACECLONE</b>. <i>addr</i> must be zero. <i>data</i> contains a bit mask of ptrace options to activate immediately.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_DETACH</b></dt>
<dd>
Restart the stopped tracee as for <b>PTRACE_CONT</b>, but first detach from it. Under Linux, a tracee can be detached in this way regardless of which method was used to initiate tracing. (<i>addr</i> is ignored.)</dd>
</dl>
<div class="subsection">
<h2>Death under ptrace</h2> When a (possibly multithreaded) process receives a killing signal (one whose disposition is set to <b>SIG_DFL</b> and whose default action is to kill the process), all threads exit. Tracees report their death to their tracer(s). Notification of this event is delivered via <b>waitpid</b>(2).<div class="spacer">
</div>
Note that the killing signal will first cause signal-delivery-stop (on one tracee only), and only after it is injected by the tracer (or after it was dispatched to a thread which isn't traced), will death from the signal happen on <i>all</i> tracees within a multithreaded process. (The term &quot;signal-delivery-stop&quot; is explained below.)<div class="spacer">
</div>
<b>SIGKILL</b> does not generate signal-delivery-stop and therefore the tracer can't suppress it. <b>SIGKILL</b> kills even within system calls (syscall-exit-stop is not generated prior to death by <b>SIGKILL</b>). The net effect is that <b>SIGKILL</b> always kills the process (all its threads), even if some threads of the process are ptraced.<div class="spacer">
</div>
When the tracee calls <b>_exit</b>(2), it reports its death to its tracer. Other threads are not affected.<div class="spacer">
</div>
When any thread executes <b>exit_group</b>(2), every tracee in its thread group reports its death to its tracer.<div class="spacer">
</div>
If the <b>PTRACE_O_TRACEEXIT</b> option is on, <b>PTRACE_EVENT_EXIT</b> will happen before actual death. This applies to exits via <b>exit</b>(2), <b>exit_group</b>(2), and signal deaths (except <b>SIGKILL</b>, depending on the kernel version; see BUGS below), and when threads are torn down on <b>execve</b>(2) in a multithreaded process.<div class="spacer">
</div>
The tracer cannot assume that the ptrace-stopped tracee exists. There are many scenarios when the tracee may die while stopped (such as <b>SIGKILL</b>). Therefore, the tracer must be prepared to handle an <b>ESRCH</b> error on any ptrace operation. Unfortunately, the same error is returned if the tracee exists but is not ptrace-stopped (for commands which require a stopped tracee), or if it is not traced by the process which issued the ptrace call. The tracer needs to keep track of the stopped/running state of the tracee, and interpret <b>ESRCH</b> as &quot;tracee died unexpectedly&quot; only if it knows that the tracee has been observed to enter ptrace-stop. Note that there is no guarantee that <i>waitpid(WNOHANG)</i> will reliably report the tracee's death status if a ptrace operation returned <b>ESRCH</b>. <i>waitpid(WNOHANG)</i> may return 0 instead. In other words, the tracee may be &quot;not yet fully dead&quot;, but already refusing ptrace requests.<div class="spacer">
</div>
The tracer can't assume that the tracee <i>always</i> ends its life by reporting <i>WIFEXITED(status)</i> or <i>WIFSIGNALED(status)</i>; there are cases where this does not occur. For example, if a thread other than thread group leader does an <b>execve</b>(2), it disappears; its PID will never be seen again, and any subsequent ptrace stops will be reported under the thread group leader's PID.</div>
<div class="subsection">
<h2>Stopped states</h2> A tracee can be in two states: running or stopped. For the purposes of ptrace, a tracee which is blocked in a system call (such as <b>read</b>(2), <b>pause</b>(2), etc.) is nevertheless considered to be running, even if the tracee is blocked for a long time. The state of the tracee after <b>PTRACE_LISTEN</b> is somewhat of a gray area: it is not in any ptrace-stop (ptrace commands won't work on it, and it will deliver <b>waitpid</b>(2) notifications), but it also may be considered &quot;stopped&quot; because it is not executing instructions (is not scheduled), and if it was in group-stop before <b>PTRACE_LISTEN</b>, it will not respond to signals until <b>SIGCONT</b> is received.<div class="spacer">
</div>
There are many kinds of states when the tracee is stopped, and in ptrace discussions they are often conflated. Therefore, it is important to use precise terms.<div class="spacer">
</div>
In this manual page, any stopped state in which the tracee is ready to accept ptrace commands from the tracer is called <i>ptrace-stop</i>. Ptrace-stops can be further subdivided into <i>signal-delivery-stop</i>, <i>group-stop</i>, <i>syscall-stop</i>, and so on. These stopped states are described in detail below.<div class="spacer">
</div>
When the running tracee enters ptrace-stop, it notifies its tracer using <b>waitpid</b>(2) (or one of the other &quot;wait&quot; system calls). Most of this manual page assumes that the tracer waits with:<div class="spacer">
</div>
<br/>
    pid = waitpid(pid_or_minus_1, &amp;status, __WALL);<div class="spacer">
</div>
Ptrace-stopped tracees are reported as returns with <i>pid</i> greater than 0 and <i>WIFSTOPPED(status)</i> true.<div class="spacer">
</div>
The <b>__WALL</b> flag does not include the <b>WSTOPPED</b> and <b>WEXITED</b> flags, but implies their functionality.<div class="spacer">
</div>
Setting the <b>WCONTINUED</b> flag when calling <b>waitpid</b>(2) is not recommended: the &quot;continued&quot; state is per-process and consuming it can confuse the real parent of the tracee.<div class="spacer">
</div>
Use of the <b>WNOHANG</b> flag may cause <b>waitpid</b>(2) to return 0 (&quot;no wait results available yet&quot;) even if the tracer knows there should be a notification. Example:<div class="spacer">
</div>
<br/>
    errno = 0;<br/>
    ptrace(PTRACE_CONT, pid, 0L, 0L);<br/>
    if (errno == ESRCH) {<br/>
        /* tracee is dead */<br/>
        r = waitpid(tracee, &amp;status, __WALL | WNOHANG);<br/>
        /* r can still be 0 here! */<br/>
    }<br/>
<div class="spacer">
</div>
The following kinds of ptrace-stops exist: signal-delivery-stops, group-stops, <b>PTRACE_EVENT</b> stops, syscall-stops. They all are reported by <b>waitpid</b>(2) with <i>WIFSTOPPED(status)</i> true. They may be differentiated by examining the value <i>status&gt;&gt;8</i>, and if there is ambiguity in that value, by querying <b>PTRACE_GETSIGINFO</b>. (Note: the <i>WSTOPSIG(status)</i> macro can't be used to perform this examination, because it returns the value <i>(status&gt;&gt;8)&#160;&amp;&#160;0xff</i>.)</div>
<div class="subsection">
<h2>Signal-delivery-stop</h2> When a (possibly multithreaded) process receives any signal except <b>SIGKILL</b>, the kernel selects an arbitrary thread which handles the signal. (If the signal is generated with <b>tgkill</b>(2), the target thread can be explicitly selected by the caller.) If the selected thread is traced, it enters signal-delivery-stop. At this point, the signal is not yet delivered to the process, and can be suppressed by the tracer. If the tracer doesn't suppress the signal, it passes the signal to the tracee in the next ptrace restart request. This second step of signal delivery is called <i>signal injection</i> in this manual page. Note that if the signal is blocked, signal-delivery-stop doesn't happen until the signal is unblocked, with the usual exception that <b>SIGSTOP</b> can't be blocked.<div class="spacer">
</div>
Signal-delivery-stop is observed by the tracer as <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i> true, with the signal returned by <i>WSTOPSIG(status)</i>. If the signal is <b>SIGTRAP</b>, this may be a different kind of ptrace-stop; see the &quot;Syscall-stops&quot; and &quot;execve&quot; sections below for details. If <i>WSTOPSIG(status)</i> returns a stopping signal, this may be a group-stop; see below.</div>
<div class="subsection">
<h2>Signal injection and suppression</h2> After signal-delivery-stop is observed by the tracer, the tracer should restart the tracee with the call<div class="spacer">
</div>
<br/>
    ptrace(PTRACE_restart, pid, 0, sig)<div class="spacer">
</div>
where <b>PTRACE_restart</b> is one of the restarting ptrace requests. If <i>sig</i> is 0, then a signal is not delivered. Otherwise, the signal <i>sig</i> is delivered. This operation is called <i>signal injection</i> in this manual page, to distinguish it from signal-delivery-stop.<div class="spacer">
</div>
The <i>sig</i> value may be different from the <i>WSTOPSIG(status)</i> value: the tracer can cause a different signal to be injected.<div class="spacer">
</div>
Note that a suppressed signal still causes system calls to return prematurely. In this case, system calls will be restarted: the tracer will observe the tracee to reexecute the interrupted system call (or <b>restart_syscall</b>(2) system call for a few system calls which use a different mechanism for restarting) if the tracer uses <b>PTRACE_SYSCALL</b>. Even system calls (such as <b>poll</b>(2)) which are not restartable after signal are restarted after signal is suppressed; however, kernel bugs exist which cause some system calls to fail with <b>EINTR</b> even though no observable signal is injected to the tracee.<div class="spacer">
</div>
Restarting ptrace commands issued in ptrace-stops other than signal-delivery-stop are not guaranteed to inject a signal, even if <i>sig</i> is nonzero. No error is reported; a nonzero <i>sig</i> may simply be ignored. Ptrace users should not try to &quot;create a new signal&quot; this way: use <b>tgkill</b>(2) instead.<div class="spacer">
</div>
The fact that signal injection requests may be ignored when restarting the tracee after ptrace stops that are not signal-delivery-stops is a cause of confusion among ptrace users. One typical scenario is that the tracer observes group-stop, mistakes it for signal-delivery-stop, restarts the tracee with<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_restart, pid, 0, stopsig)<div style="height: 1.00em;">
&#160;</div>
with the intention of injecting <i>stopsig</i>, but <i>stopsig</i> gets ignored and the tracee continues to run.<div class="spacer">
</div>
The <b>SIGCONT</b> signal has a side effect of waking up (all threads of) a group-stopped process. This side effect happens before signal-delivery-stop. The tracer can't suppress this side effect (it can only suppress signal injection, which only causes the <b>SIGCONT</b> handler to not be executed in the tracee, if such a handler is installed). In fact, waking up from group-stop may be followed by signal-delivery-stop for signal(s) <i>other than</i> <b>SIGCONT</b>, if they were pending when <b>SIGCONT</b> was delivered. In other words, <b>SIGCONT</b> may be not the first signal observed by the tracee after it was sent.<div class="spacer">
</div>
Stopping signals cause (all threads of) a process to enter group-stop. This side effect happens after signal injection, and therefore can be suppressed by the tracer.<div class="spacer">
</div>
In Linux 2.4 and earlier, the <b>SIGSTOP</b> signal can't be injected.<div class="spacer">
</div>
<b>PTRACE_GETSIGINFO</b> can be used to retrieve a <i>siginfo_t</i> structure which corresponds to the delivered signal. <b>PTRACE_SETSIGINFO</b> may be used to modify it. If <b>PTRACE_SETSIGINFO</b> has been used to alter <i>siginfo_t</i>, the <i>si_signo</i> field and the <i>sig</i> parameter in the restarting command must match, otherwise the result is undefined.</div>
<div class="subsection">
<h2>Group-stop</h2> When a (possibly multithreaded) process receives a stopping signal, all threads stop. If some threads are traced, they enter a group-stop. Note that the stopping signal will first cause signal-delivery-stop (on one tracee only), and only after it is injected by the tracer (or after it was dispatched to a thread which isn't traced), will group-stop be initiated on <i>all</i> tracees within the multithreaded process. As usual, every tracee reports its group-stop separately to the corresponding tracer.<div class="spacer">
</div>
Group-stop is observed by the tracer as <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i> true, with the stopping signal available via <i>WSTOPSIG(status)</i>. The same result is returned by some other classes of ptrace-stops, therefore the recommended practice is to perform the call<div class="spacer">
</div>
<br/>
    ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo)<div class="spacer">
</div>
The call can be avoided if the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>, <b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals are stopping signals. If the tracer sees something else, it can't be a group-stop. Otherwise, the tracer needs to call <b>PTRACE_GETSIGINFO</b>. If <b>PTRACE_GETSIGINFO</b> fails with <b>EINVAL</b>, then it is definitely a group-stop. (Other failure codes are possible, such as <b>ESRCH</b> (&quot;no such process&quot;) if a <b>SIGKILL</b> killed the tracee.)<div class="spacer">
</div>
If tracee was attached using <b>PTRACE_SEIZE</b>, group-stop is indicated by <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 == PTRACE_EVENT_STOP</i>. This allows detection of group-stops without requiring an extra <b>PTRACE_GETSIGINFO</b> call.<div class="spacer">
</div>
As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until it restarts or kills it, the tracee will not run, and will not send notifications (except <b>SIGKILL</b> death) to the tracer, even if the tracer enters into another <b>waitpid</b>(2) call.<div class="spacer">
</div>
The kernel behavior described in the previous paragraph causes a problem with transparent handling of stopping signals. If the tracer restarts the tracee after group-stop, the stopping signal is effectively ignored&#8212;the tracee doesn't remain stopped, it runs. If the tracer doesn't restart the tracee before entering into the next <b>waitpid</b>(2), future <b>SIGCONT</b> signals will not be reported to the tracer; this would cause the <b>SIGCONT</b> signals to have no effect on the tracee.<div class="spacer">
</div>
Since Linux 3.4, there is a method to overcome this problem: instead of <b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN</b> command can be used to restart a tracee in a way where it does not execute, but waits for a new event which it can report via <b>waitpid</b>(2) (such as when it is restarted by a <b>SIGCONT</b>).</div>
<div class="subsection">
<h2>PTRACE_EVENT stops</h2> If the tracer sets <b>PTRACE_O_TRACE_*</b> options, the tracee will enter ptrace-stops called <b>PTRACE_EVENT</b> stops.<div class="spacer">
</div>
<b>PTRACE_EVENT</b> stops are observed by the tracer as <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i>, and <i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b>. An additional bit is set in the higher byte of the status word: the value <i>status&gt;&gt;8</i> will be<div style="height: 1.00em;">
&#160;</div>
<br/>
    (SIGTRAP | PTRACE_EVENT_foo &lt;&lt; 8).<div style="height: 1.00em;">
&#160;</div>
The following events exist:<dl>
<dt>
<b>PTRACE_EVENT_VFORK</b></dt>
<dd>
Stop before return from <b>vfork</b>(2) or <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag. When the tracee is continued after this stop, it will wait for child to exit/exec before continuing its execution (in other words, the usual behavior on <b>vfork</b>(2)).</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_FORK</b></dt>
<dd>
Stop before return from <b>fork</b>(2) or <b>clone</b>(2) with the exit signal set to <b>SIGCHLD</b>.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_CLONE</b></dt>
<dd>
Stop before return from <b>clone</b>(2).</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_VFORK_DONE</b></dt>
<dd>
Stop before return from <b>vfork</b>(2) or <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag, but after the child unblocked this tracee by exiting or execing.</dd>
</dl>
<div class="spacer">
</div>
For all four stops described above, the stop occurs in the parent (i.e., the tracee), not in the newly created thread. <b>PTRACE_GETEVENTMSG</b> can be used to retrieve the new thread's ID.<dl>
<dt>
<b>PTRACE_EVENT_EXEC</b></dt>
<dd>
Stop before return from <b>execve</b>(2). Since Linux 3.0, <b>PTRACE_GETEVENTMSG</b> returns the former thread ID.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_EXIT</b></dt>
<dd>
Stop before exit (including death from <b>exit_group</b>(2)), signal death, or exit caused by <b>execve</b>(2) in a multithreaded process. <b>PTRACE_GETEVENTMSG</b> returns the exit status. Registers can be examined (unlike when &quot;real&quot; exit happens). The tracee is still alive; it needs to be <b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to finish exiting.</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_STOP</b></dt>
<dd>
Stop induced by <b>PTRACE_INTERRUPT</b> command, or group-stop, or initial ptrace-stop when a new child is attached (only if attached using <b>PTRACE_SEIZE</b>).</dd>
</dl>
<dl>
<dt>
<b>PTRACE_EVENT_SECCOMP</b></dt>
<dd>
Stop triggered by a <b>seccomp</b>(2) rule on tracee syscall entry when <b>PTRACE_O_TRACESECCOMP</b> has been set by the tracer. The seccomp event message data (from the <b>SECCOMP_RET_DATA</b> portion of the seccomp filter rule) can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<div class="spacer">
</div>
<b>PTRACE_GETSIGINFO</b> on <b>PTRACE_EVENT</b> stops returns <b>SIGTRAP</b> in <i>si_signo</i>, with <i>si_code</i> set to <i>(event&lt;&lt;8)&#160;|&#160;SIGTRAP</i>.</div>
<div class="subsection">
<h2>Syscall-stops</h2> If the tracee was restarted by <b>PTRACE_SYSCALL</b>, the tracee enters syscall-enter-stop just prior to entering any system call. If the tracer restarts the tracee with <b>PTRACE_SYSCALL</b>, the tracee enters syscall-exit-stop when the system call is finished, or if it is interrupted by a signal. (That is, signal-delivery-stop never happens between syscall-enter-stop and syscall-exit-stop; it happens <i>after</i> syscall-exit-stop.)<div class="spacer">
</div>
Other possibilities are that the tracee may stop in a <b>PTRACE_EVENT</b> stop, exit (if it entered <b>_exit</b>(2) or <b>exit_group</b>(2)), be killed by <b>SIGKILL</b>, or die silently (if it is a thread group leader, the <b>execve</b>(2) happened in another thread, and that thread is not traced by the same tracer; this situation is discussed later).<div class="spacer">
</div>
Syscall-enter-stop and syscall-exit-stop are observed by the tracer as <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i> true, and <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>. If the <b>PTRACE_O_TRACESYSGOOD</b> option was set by the tracer, then <i>WSTOPSIG(status)</i> will give the value <i>(SIGTRAP&#160;|&#160;0x80)</i>.<div class="spacer">
</div>
Syscall-stops can be distinguished from signal-delivery-stop with <b>SIGTRAP</b> by querying <b>PTRACE_GETSIGINFO</b> for the following cases:<dl>
<dt>
<i>si_code</i> &lt;= 0</dt>
<dd>
<b>SIGTRAP</b> was delivered as a result of a user-space action, for example, a system call (<b>tgkill</b>(2), <b>kill</b>(2), <b>sigqueue</b>(3), etc.), expiration of a POSIX timer, change of state on a POSIX message queue, or completion of an asynchronous I/O request.</dd>
</dl>
<dl>
<dt>
<i>si_code</i> == SI_KERNEL (0x80)</dt>
<dd>
<b>SIGTRAP</b> was sent by the kernel.</dd>
</dl>
<dl>
<dt>
<i>si_code</i> == SIGTRAP or <i>si_code</i> == (SIGTRAP|0x80)</dt>
<dd>
This is a syscall-stop.</dd>
</dl>
<div class="spacer">
</div>
However, syscall-stops happen very often (twice per system call), and performing <b>PTRACE_GETSIGINFO</b> for every syscall-stop may be somewhat expensive.<div class="spacer">
</div>
Some architectures allow the cases to be distinguished by examining registers. For example, on x86, <i>rax</i> == -<b>ENOSYS</b> in syscall-enter-stop. Since <b>SIGTRAP</b> (like any other signal) always happens <i>after</i> syscall-exit-stop, and at this point <i>rax</i> almost never contains -<b>ENOSYS</b>, the <b>SIGTRAP</b> looks like &quot;syscall-stop which is not syscall-enter-stop&quot;; in other words, it looks like a &quot;stray syscall-exit-stop&quot; and can be detected this way. But such detection is fragile and is best avoided.<div class="spacer">
</div>
Using the <b>PTRACE_O_TRACESYSGOOD</b> option is the recommended method to distinguish syscall-stops from other kinds of ptrace-stops, since it is reliable and does not incur a performance penalty.<div class="spacer">
</div>
Syscall-enter-stop and syscall-exit-stop are indistinguishable from each other by the tracer. The tracer needs to keep track of the sequence of ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-stop or vice versa. The rule is that syscall-enter-stop is always followed by syscall-exit-stop, <b>PTRACE_EVENT</b> stop or the tracee's death; no other kinds of ptrace-stop can occur in between.<div class="spacer">
</div>
If after syscall-enter-stop, the tracer uses a restarting command other than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not generated.<div class="spacer">
</div>
<b>PTRACE_GETSIGINFO</b> on syscall-stops returns <b>SIGTRAP</b> in <i>si_signo</i>, with <i>si_code</i> set to <b>SIGTRAP</b> or <i>(SIGTRAP|0x80)</i>.</div>
<div class="subsection">
<h2>PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops</h2> [Details of these kinds of stops are yet to be documented.]</div>
<div class="subsection">
<h2>Informational and restarting ptrace commands</h2> Most ptrace commands (all except <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>, <b>PTRACE_TRACEME</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>) require the tracee to be in a ptrace-stop, otherwise they fail with <b>ESRCH</b>.<div class="spacer">
</div>
When the tracee is in ptrace-stop, the tracer can read and write data to the tracee using informational commands. These commands leave the tracee in ptrace-stopped state:<div class="spacer">
</div>
<br/>
    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);<br/>
    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);<br/>
    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct);<br/>
    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct);<br/>
    ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov);<br/>
    ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov);<br/>
    ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo);<br/>
    ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo);<br/>
    ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var);<br/>
    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);<br/>
<div class="spacer">
</div>
Note that some errors are not reported. For example, setting signal information (<i>siginfo</i>) may have no effect in some ptrace-stops, yet the call may succeed (return 0 and not set <i>errno</i>); querying <b>PTRACE_GETEVENTMSG</b> may succeed and return some random value if current ptrace-stop is not documented as returning a meaningful event message.<div class="spacer">
</div>
The call<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);<div style="height: 1.00em;">
&#160;</div>
affects one tracee. The tracee's current flags are replaced. Flags are inherited by new tracees created and &quot;auto-attached&quot; via active <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or <b>PTRACE_O_TRACECLONE</b> options.<div class="spacer">
</div>
Another group of commands makes the ptrace-stopped tracee run. They have the form:<div class="spacer">
</div>
<br/>
    ptrace(cmd, pid, 0, sig);<div class="spacer">
</div>
where <i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>, <b>PTRACE_DETACH</b>, <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>, or <b>PTRACE_SYSEMU_SINGLESTEP</b>. If the tracee is in signal-delivery-stop, <i>sig</i> is the signal to be injected (if it is nonzero). Otherwise, <i>sig</i> may be ignored. (When restarting a tracee from a ptrace-stop other than signal-delivery-stop, recommended practice is to always pass 0 in <i>sig</i>.)</div>
<div class="subsection">
<h2>Attaching and detaching</h2> A thread can be attached to the tracer using the call<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_ATTACH, pid, 0, 0);<div style="height: 1.00em;">
&#160;</div>
or<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<div style="height: 1.00em;">
&#160;</div>
<b>PTRACE_ATTACH</b> sends <b>SIGSTOP</b> to this thread. If the tracer wants this <b>SIGSTOP</b> to have no effect, it needs to suppress it. Note that if other signals are concurrently sent to this thread during attach, the tracer may see the tracee enter signal-delivery-stop with other signal(s) first! The usual practice is to reinject these signals until <b>SIGSTOP</b> is seen, then suppress <b>SIGSTOP</b> injection. The design bug here is that a ptrace attach and a concurrently delivered <b>SIGSTOP</b> may race and the concurrent <b>SIGSTOP</b> may be lost.<div class="spacer">
</div>
Since attaching sends <b>SIGSTOP</b> and the tracer usually suppresses it, this may cause a stray <b>EINTR</b> return from the currently executing system call in the tracee, as described in the &quot;Signal injection and suppression&quot; section.<div class="spacer">
</div>
Since Linux 3.4, <b>PTRACE_SEIZE</b> can be used instead of <b>PTRACE_ATTACH</b>. <b>PTRACE_SEIZE</b> does not stop the attached process. If you need to stop it after attach (or at any other time) without sending it any signals, use <b>PTRACE_INTERRUPT</b> command.<div class="spacer">
</div>
The request<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_TRACEME, 0, 0, 0);<div style="height: 1.00em;">
&#160;</div>
turns the calling thread into a tracee. The thread continues to run (doesn't enter ptrace-stop). A common practice is to follow the <b>PTRACE_TRACEME</b> with<div style="height: 1.00em;">
&#160;</div>
<br/>
    raise(SIGSTOP);<div style="height: 1.00em;">
&#160;</div>
and allow the parent (which is our tracer now) to observe our signal-delivery-stop.<div class="spacer">
</div>
If the <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or <b>PTRACE_O_TRACECLONE</b> options are in effect, then children created by, respectively, <b>vfork</b>(2) or <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag, <b>fork</b>(2) or <b>clone</b>(2) with the exit signal set to <b>SIGCHLD</b>, and other kinds of <b>clone</b>(2), are automatically attached to the same tracer which traced their parent. <b>SIGSTOP</b> is delivered to the children, causing them to enter signal-delivery-stop after they exit the system call which created them.<div class="spacer">
</div>
Detaching of the tracee is performed by:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ptrace(PTRACE_DETACH, pid, 0, sig);<div style="height: 1.00em;">
&#160;</div>
<b>PTRACE_DETACH</b> is a restarting operation; therefore it requires the tracee to be in ptrace-stop. If the tracee is in signal-delivery-stop, a signal can be injected. Otherwise, the <i>sig</i> parameter may be silently ignored.<div class="spacer">
</div>
If the tracee is running when the tracer wants to detach it, the usual solution is to send <b>SIGSTOP</b> (using <b>tgkill</b>(2), to make sure it goes to the correct thread), wait for the tracee to stop in signal-delivery-stop for <b>SIGSTOP</b> and then detach it (suppressing <b>SIGSTOP</b> injection). A design bug is that this can race with concurrent <b>SIGSTOP</b>s. Another complication is that the tracee may enter other ptrace-stops and needs to be restarted and waited for again, until <b>SIGSTOP</b> is seen. Yet another complication is to be sure that the tracee is not already ptrace-stopped, because no signal delivery happens while it is&#8212;not even <b>SIGSTOP</b>.<div class="spacer">
</div>
If the tracer dies, all tracees are automatically detached and restarted, unless they were in group-stop. Handling of restart from group-stop is currently buggy, but the &quot;as planned&quot; behavior is to leave tracee stopped and waiting for <b>SIGCONT</b>. If the tracee is restarted from signal-delivery-stop, the pending signal is injected.</div>
<div class="subsection">
<h2>execve(2) under ptrace</h2> When one thread in a multithreaded process calls <b>execve</b>(2), the kernel destroys all other threads in the process, and resets the thread ID of the execing thread to the thread group ID (process ID). (Or, to put things another way, when a multithreaded process does an <b>execve</b>(2), at completion of the call, it appears as though the <b>execve</b>(2) occurred in the thread group leader, regardless of which thread did the <b>execve</b>(2).) This resetting of the thread ID looks very confusing to tracers:<dl>
<dt>
*</dt>
<dd>
All other threads stop in <b>PTRACE_EVENT_EXIT</b> stop, if the <b>PTRACE_O_TRACEEXIT</b> option was turned on. Then all other threads except the thread group leader report death as if they exited via <b>_exit</b>(2) with exit code 0.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The execing tracee changes its thread ID while it is in the <b>execve</b>(2). (Remember, under ptrace, the &quot;pid&quot; returned from <b>waitpid</b>(2), or fed into ptrace calls, is the tracee's thread ID.) That is, the tracee's thread ID is reset to be the same as its process ID, which is the same as the thread group leader's thread ID.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
Then a <b>PTRACE_EVENT_EXEC</b> stop happens, if the <b>PTRACE_O_TRACEEXEC</b> option was turned on.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
If the thread group leader has reported its <b>PTRACE_EVENT_EXIT</b> stop by this time, it appears to the tracer that the dead thread leader &quot;reappears from nowhere&quot;. (Note: the thread group leader does not report death via <i>WIFEXITED(status)</i> until there is at least one other live thread. This eliminates the possibility that the tracer will see it dying and then reappearing.) If the thread group leader was still alive, for the tracer this may look as if thread group leader returns from a different system call than it entered, or even &quot;returned from a system call even though it was not in any system call&quot;. If the thread group leader was not traced (or was traced by a different tracer), then during <b>execve</b>(2) it will appear as if it has become a tracee of the tracer of the execing tracee.</dd>
</dl>
<div class="spacer">
</div>
All of the above effects are the artifacts of the thread ID change in the tracee.<div class="spacer">
</div>
The <b>PTRACE_O_TRACEEXEC</b> option is the recommended tool for dealing with this situation. First, it enables <b>PTRACE_EVENT_EXEC</b> stop, which occurs before <b>execve</b>(2) returns. In this stop, the tracer can use <b>PTRACE_GETEVENTMSG</b> to retrieve the tracee's former thread ID. (This feature was introduced in Linux 3.0.) Second, the <b>PTRACE_O_TRACEEXEC</b> option disables legacy <b>SIGTRAP</b> generation on <b>execve</b>(2).<div class="spacer">
</div>
When the tracer receives <b>PTRACE_EVENT_EXEC</b> stop notification, it is guaranteed that except this tracee and the thread group leader, no other threads from the process are alive.<div class="spacer">
</div>
On receiving the <b>PTRACE_EVENT_EXEC</b> stop notification, the tracer should clean up all its internal data structures describing the threads of this process, and retain only one data structure&#8212;one which describes the single still running tracee, with<div style="height: 1.00em;">
&#160;</div>
<br/>
    thread ID == thread group ID == process ID.<div class="spacer">
</div>
Example: two threads call <b>execve</b>(2) at the same time:<div class="spacer">
</div>
<br/>
*** we get syscall-enter-stop in thread 1: **<br/>
PID1 execve(&quot;/bin/foo&quot;, &quot;foo&quot; &lt;unfinished ...&gt;<br/>
*** we issue PTRACE_SYSCALL for thread 1 **<br/>
*** we get syscall-enter-stop in thread 2: **<br/>
PID2 execve(&quot;/bin/bar&quot;, &quot;bar&quot; &lt;unfinished ...&gt;<br/>
*** we issue PTRACE_SYSCALL for thread 2 **<br/>
*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **<br/>
*** we get syscall-exit-stop for PID0: **<br/>
PID0 &lt;... execve resumed&gt; )             = 0<br/>
<div class="spacer">
</div>
If the <b>PTRACE_O_TRACEEXEC</b> option is <i>not</i> in effect for the execing tracee, and if the tracee was <b>PTRACE_ATTACH</b>ed rather that <b>PTRACE_SEIZE</b>d, the kernel delivers an extra <b>SIGTRAP</b> to the tracee after <b>execve</b>(2) returns. This is an ordinary signal (similar to one which can be generated by <i>kill -TRAP</i>), not a special kind of ptrace-stop. Employing <b>PTRACE_GETSIGINFO</b> for this signal returns <i>si_code</i> set to 0 (<i>SI_USER</i>). This signal may be blocked by signal mask, and thus may be delivered (much) later.<div class="spacer">
</div>
Usually, the tracer (for example, <b>strace</b>(1)) would not want to show this extra post-execve <b>SIGTRAP</b> signal to the user, and would suppress its delivery to the tracee (if <b>SIGTRAP</b> is set to <b>SIG_DFL</b>, it is a killing signal). However, determining <i>which</i> <b>SIGTRAP</b> to suppress is not easy. Setting the <b>PTRACE_O_TRACEEXEC</b> option or using <b>PTRACE_SEIZE</b> and thus suppressing this extra <b>SIGTRAP</b> is the recommended approach.</div>
<div class="subsection">
<h2>Real parent</h2> The ptrace API (ab)uses the standard UNIX parent/child signaling over <b>waitpid</b>(2). This used to cause the real parent of the process to stop receiving several kinds of <b>waitpid</b>(2) notifications when the child process is traced by some other process.<div class="spacer">
</div>
Many of these bugs have been fixed, but as of Linux 2.6.38 several still exist; see BUGS below.<div class="spacer">
</div>
As of Linux 2.6.38, the following is believed to work correctly:<dl>
<dt>
*</dt>
<dd>
exit/death by signal is reported first to the tracer, then, when the tracer consumes the <b>waitpid</b>(2) result, to the real parent (to the real parent only when the whole multithreaded process exits). If the tracer and the real parent are the same process, the report is sent only once.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, the <b>PTRACE_PEEK*</b> requests return the requested data (but see NOTES), while other requests return zero.<div class="spacer">
</div>
On error, all requests return -1, and <i>errno</i> is set appropriately. Since the value returned by a successful <b>PTRACE_PEEK*</b> request may be -1, the caller must clear <i>errno</i> before the call, and then check it afterward to determine whether or not an error occurred.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EBUSY</b></dt>
<dd>
(i386 only) There was an error with allocating or freeing a debug register.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
There was an attempt to read from or write to an invalid area in the tracer's or the tracee's memory, probably because the area wasn't mapped or accessible. Unfortunately, under Linux, different variations of this fault will return <b>EIO</b> or <b>EFAULT</b> more or less arbitrarily.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
An attempt was made to set an invalid option.</dd>
</dl>
<dl>
<dt>
<b>EIO</b></dt>
<dd>
<i>request</i> is invalid, or an attempt was made to read from or write to an invalid area in the tracer's or the tracee's memory, or there was a word-alignment violation, or an invalid signal was specified during a restart request.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
The specified process cannot be traced. This could be because the tracer has insufficient privileges (the required capability is <b>CAP_SYS_PTRACE</b>); unprivileged processes cannot trace processes that they cannot send signals to or those running set-user-ID/set-group-ID programs, for obvious reasons. Alternatively, the process may already be being traced, or (on kernels before 2.6.26) be <b>init</b>(1) (PID 1).</dd>
</dl>
<dl>
<dt>
<b>ESRCH</b></dt>
<dd>
The specified process does not exist, or is not currently being traced by the caller, or is not stopped (for requests that require a stopped tracee).</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> SVr4, 4.3BSD.</div>
<div class="section">
<h1>NOTES</h1> Although arguments to <b>ptrace</b>() are interpreted according to the prototype given, glibc currently declares <b>ptrace</b>() as a variadic function with only the <i>request</i> argument fixed. It is recommended to always supply four arguments, even if the requested operation does not use them, setting unused/ignored arguments to <i>0L</i> or <i>(void&#160;*)&#160;0</i>.<div class="spacer">
</div>
In Linux kernels before 2.6.26, <b>init</b>(1), the process with PID 1, may not be traced.<div class="spacer">
</div>
A tracees parent continues to be the tracer even if that tracer calls <b>execve</b>(2).<div class="spacer">
</div>
The layout of the contents of memory and the USER area are quite operating-system- and architecture-specific. The offset supplied, and the data returned, might not entirely match with the definition of <i>struct user</i>.<div class="spacer">
</div>
The size of a &quot;word&quot; is determined by the operating-system variant (e.g., for 32-bit Linux it is 32 bits).<div class="spacer">
</div>
This page documents the way the <b>ptrace</b>() call works currently in Linux. Its behavior differs significantly on other flavors of UNIX. In any case, use of <b>ptrace</b>() is highly specific to the operating system and architecture.<div class="subsection">
<h2>C library/kernel differences</h2> At the system call level, the <b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b>, and <b>PTRACE_PEEKUSER</b> requests have a different API: they store the result at the address specified by the <i>data</i> parameter, and the return value is the error flag. The glibc wrapper function provides the API given in DESCRIPTION above, with the result being returned via the function return value.</div>
</div>
<div class="section">
<h1>BUGS</h1> On hosts with 2.6 kernel headers, <b>PTRACE_SETOPTIONS</b> is declared with a different value than the one for 2.4. This leads to applications compiled with 2.6 kernel headers failing when run on 2.4 kernels. This can be worked around by redefining <b>PTRACE_SETOPTIONS</b> to <b>PTRACE_OLDSETOPTIONS</b>, if that is defined.<div class="spacer">
</div>
Group-stop notifications are sent to the tracer, but not to real parent. Last confirmed on 2.6.38.6.<div class="spacer">
</div>
If a thread group leader is traced and exits by calling <b>_exit</b>(2), a <b>PTRACE_EVENT_EXIT</b> stop will happen for it (if requested), but the subsequent <b>WIFEXITED</b> notification will not be delivered until all other threads exit. As explained above, if one of other threads calls <b>execve</b>(2), the death of the thread group leader will <i>never</i> be reported. If the execed thread is not traced by this tracer, the tracer will never know that <b>execve</b>(2) happened. One possible workaround is to <b>PTRACE_DETACH</b> the thread group leader instead of restarting it in this case. Last confirmed on 2.6.38.6.<div class="spacer">
</div>
A <b>SIGKILL</b> signal may still cause a <b>PTRACE_EVENT_EXIT</b> stop before actual signal death. This may be changed in the future; <b>SIGKILL</b> is meant to always immediately kill tasks even under ptrace. Last confirmed on Linux 3.13.<div class="spacer">
</div>
Some system calls return with <b>EINTR</b> if a signal was sent to a tracee, but delivery was suppressed by the tracer. (This is very typical operation: it is usually done by debuggers on every attach, in order to not introduce a bogus <b>SIGSTOP</b>). As of Linux 3.2.9, the following system calls are affected (this list is likely incomplete): <b>epoll_wait</b>(2), and <b>read</b>(2) from an <b>inotify</b>(7) file descriptor. The usual symptom of this bug is that when you attach to a quiescent process with the command<div style="height: 1.00em;">
&#160;</div>
<br/>
    strace -p &lt;process-ID&gt;<div style="height: 1.00em;">
&#160;</div>
then, instead of the usual and expected one-line output such as<div class="spacer">
</div>
<br/>
    restart_syscall(&lt;... resuming interrupted call ...&gt;_<div class="spacer">
</div>
<br/>
or<div class="spacer">
</div>
<br/>
    select(6, [5], NULL, [5], NULL_<div class="spacer">
</div>
<br/>
('_' denotes the cursor position), you observe more than one line. For example:<div class="spacer">
</div>
<br/>
    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0<br/>
    epoll_wait(4,_<div class="spacer">
</div>
<br/>
What is not visible here is that the process was blocked in <b>epoll_wait</b>(2) before <b>strace</b>(1) has attached to it. Attaching caused <b>epoll_wait</b>(2) to return to user space with the error <b>EINTR</b>. In this particular case, the program reacted to <b>EINTR</b> by checking the current time, and then executing <b>epoll_wait</b>(2) again. (Programs which do not expect such &quot;stray&quot; <b>EINTR</b> errors may behave in an unintended way upon an <b>strace</b>(1) attach.)</div>
<div class="section">
<h1>SEE ALSO</h1> <b>gdb</b>(1), <b>strace</b>(1), <b>clone</b>(2), <b>execve</b>(2), <b>fork</b>(2), <b>gettid</b>(2), <b>seccomp</b>(2), <b>sigaction</b>(2), <b>tgkill</b>(2), <b>vfork</b>(2), <b>waitpid</b>(2), <b>exec</b>(3), <b>capabilities</b>(7), <b>signal</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 4.02 of the Linux <i>man-pages</i> project. A description of the project, information about reporting bugs, and the latest version of this page, can be found at http://www.kernel.org/doc/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-07-23</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

