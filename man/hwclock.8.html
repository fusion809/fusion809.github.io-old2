<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
HWCLOCK(8)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HWCLOCK(8)</td>
<td class="head-vol">
System Administration</td>
<td class="head-rtitle">
HWCLOCK(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> hwclock - read or set the hardware clock (RTC)</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>hwclock</b> [<i>function</i>] [<i>option</i>...]</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>hwclock</b> is a tool for accessing the Hardware Clock.  It can: display the Hardware Clock time; set the Hardware Clock to a specified time; set the Hardware Clock from the System Clock; set the System Clock from the Hardware Clock; compensate for Hardware Clock drift; correct the System Clock timescale; set the kernel's timezone, NTP timescale, and epoch (Alpha only); compare the System and Hardware Clocks; and predict future Hardware Clock values based on its drift rate.<div class="spacer">
</div>
Since v2.26 important changes were made to the <b>--hctosys</b> function and the <b>--directisa</b> option, and a new option <b>--update-drift</b> was added.  See their respective descriptions below.</div>
<div class="section">
<h1>FUNCTIONS</h1> The following functions are mutually exclusive, only one can be given at a time.  If none is given, the default is  <b>--show</b>.<dl>
<dt>
<b>--adjust</b></dt>
<dd>
Add or subtract time from the Hardware Clock to account for systematic drift since the last time the clock was set or adjusted.  See the discussion below, under <b>The Adjust Function</b>.</dd>
</dl>
<dl>
<dt>
<b>-c</b>,<b>&#160;--compare</b></dt>
<dd>
Periodically compare the Hardware Clock to the System Time and output the difference every 10 seconds.  This will also print the frequency offset and tick.</dd>
</dl>
<dl>
<dt>
<b>--getepoch</b></dt>
<dd>
<b>--setepoch</b> These functions are for Alpha machines only.<div style="height: 1.00em;">
&#160;</div>
Read and set the kernel's Hardware Clock epoch value. Epoch is the number of years into AD to which a zero year value in the Hardware Clock refers.  For example, if you are using the convention that the year counter in your Hardware Clock contains the number of full years since 1952, then the kernel's Hardware Clock epoch value must be 1952.<div style="height: 1.00em;">
&#160;</div>
The <b>--setepoch</b> function requires using the <b>--epoch</b> option to specify the year.<div style="height: 1.00em;">
&#160;</div>
This epoch value is used whenever <b>hwclock</b> reads or sets the Hardware Clock.</dd>
</dl>
<dl>
<dt>
<b>--predict</b></dt>
<dd>
Predict what the Hardware Clock will read in the future based upon the time given by the <b>--date</b> option and the information in <i>/etc/adjtime</i>. This is useful, for example, to account for drift when setting a Hardware Clock wakeup (aka alarm). See <b>rtcwake</b>(8).<div style="height: 1.00em;">
&#160;</div>
Do not use this function if the Hardware Clock is being modified by anything other than the current operating system's <b>hwclock</b> command, such as '11&#160;minute&#160;mode' or from dual-booting another OS.</dd>
</dl>
<dl>
<dt>
<b>-r</b>,<b>&#160;--show</b></dt>
<dd>
<b>--get</b><div style="height: 0.00em;">
&#160;</div>
Read the Hardware Clock and print the time on standard output. The time shown is always in local time, even if you keep your Hardware Clock in UTC.  See the <b>--localtime</b> option.<div style="height: 1.00em;">
&#160;</div>
Showing the Hardware Clock time is the default when no function is specified.<div style="height: 1.00em;">
&#160;</div>
The <b>--get</b> function also applies drift correction to the time read, based upon the information in <i>/etc/adjtime</i>. Do not use this function if the Hardware Clock is being modified by anything other than the current operating system's <b>hwclock</b> command, such as '11&#160;minute&#160;mode' or from dual-booting another OS.</dd>
</dl>
<dl>
<dt>
<b>-s</b>,<b>&#160;--hctosys</b></dt>
<dd>
Set the System Clock from the Hardware Clock.  The time read from the Hardware Clock is compensated to account for systematic drift before using it to set the System Clock.  See the discussion below, under <b>The Adjust Function</b>.<div style="height: 1.00em;">
&#160;</div>
The System Clock must be kept in the UTC timescale for date-time applications to work correctly in conjunction with the timezone configured for the system.  If the Hardware Clock is kept in local time then the time read from it must be shifted to the UTC timescale before using it to set the System Clock.  The <b>--hctosys</b> function does this based upon the information in the <i>/etc/adjtime</i> file or the command line arguments <b>--localtime</b> and <b>--utc</b>. Note: no daylight saving adjustment is made.  See the discussion below, under <b>LOCAL vs UTC</b>.<div style="height: 1.00em;">
&#160;</div>
The kernel also keeps a timezone value, the <b>--hctosys</b> function sets it to the timezone configured for the system.  The system timezone is configured by the TZ environment variable or the <i>/etc/localtime</i> file, as <b>tzset</b>(3) would interpret them. The obsolete tz_dsttime field of the kernel's timezone value is set to zero.  (For details on what this field used to mean, see <b>settimeofday</b>(2).)<div style="height: 1.00em;">
&#160;</div>
When used in a startup script, making the <b>--hctosys</b> function the first caller of <b>settimeofday</b>(2) from boot, it will set the NTP '11&#160;minute&#160;mode' timescale via the <i>persistent_clock_is_local</i> kernel variable.  If the Hardware Clock's timescale configuration is changed then a reboot is required to inform the kernel.  See the discussion below, under <b>Automatic Hardware Clock Synchronization by the Kernel</b>.<div style="height: 1.00em;">
&#160;</div>
This is a good function to use in one of the system startup scripts before the file systems are mounted read/write.<div style="height: 1.00em;">
&#160;</div>
This function should never be used on a running system. Jumping system time will cause problems, such as corrupted filesystem timestamps.  Also, if something has changed the Hardware Clock, like NTP's '11&#160;minute&#160;mode', then <b>--hctosys</b> will set the time incorrectly by including drift compensation.<div style="height: 1.00em;">
&#160;</div>
Drift compensation can be inhibited by setting the drift factor in <i>/etc/adjtime</i> to zero.  This setting will be persistent as long as the <b>--update-drift</b> option is not used with <b>--systohc</b> at shutdown (or anywhere else).  Another way to inhibit this is by using the <b>--noadjfile</b> option when calling the <b>--hctosys</b> function.  A third method is to delete the <i>/etc/adjtime</i> file. <b>Hwclock</b> will then default to using the UTC timescale for the Hardware Clock.  If the Hardware Clock is ticking local time it will need to be defined in the file.  This can be done by calling <b>hwclock&#160;--localtime&#160;--adjust</b>; when the file is not present this command will not actually adjust the Clock, but it will create the file with local time configured, and a drift factor of zero.<div style="height: 1.00em;">
&#160;</div>
A condition under which inhibiting <b>hwclock</b>'s drift correction may be desired is when dual-booting multiple operating systems.  If while this instance of Linux is stopped, another OS changes the Hardware Clock's value, then when this instance is started again the drift correction applied will be incorrect.<div style="height: 1.00em;">
&#160;</div>
For <b>hwclock</b>'s drift correction to work properly it is imperative that nothing changes the Hardware Clock while its Linux instance is not running.</dd>
</dl>
<dl>
<dt>
<b>--set</b></dt>
<dd>
Set the Hardware Clock to the time given by the <b>--date</b> option, and update the timestamps in <i>/etc/adjtime</i>. With the <b>--update-drift</b> option (re)calculate the drift factor.</dd>
</dl>
<dl>
<dt>
<b>--systz</b></dt>
<dd>
This is an alternate to the <b>--hctosys</b> function that does not read the Hardware Clock nor set the System Clock; consequently there is not any drift correction.  It is intended to be used in a startup script on systems with kernels above version 2.6 where you know the System Clock has been set from the Hardware Clock by the kernel during boot.<div style="height: 1.00em;">
&#160;</div>
It does the following things that are detailed above in the <b>--hctosys</b> function:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
Corrects the System Clock timescale to UTC as needed.  Only instead of accomplishing this by setting the System Clock, <b>hwclock</b> simply informs the kernel and it handles the change.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Sets the kernel's NTP '11&#160;minute&#160;mode' timescale.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Sets the kernel's timezone.</dd>
</dl>
<div class="spacer">
</div>
The first two are only available on the first call of <b>settimeofday</b>(2) after boot.  Consequently this option only makes sense when used in a startup script.  If the Hardware Clocks timescale configuration is changed then a reboot would be required to inform the kernel.</div>
<dl>
<dt>
<b>-w</b>,<b>&#160;--systohc</b></dt>
<dd>
Set the Hardware Clock from the System Clock, and update the timestamps in <i>/etc/adjtime</i>. When the <b>--update-drift</b> option is given, then also (re)calculate the drift factor.</dd>
</dl>
<dl>
<dt>
<b>-V</b>,<b>&#160;--version</b></dt>
<dd>
Display version information and exit.</dd>
</dl>
<dl>
<dt>
<b>-h</b>,<b>&#160;--help</b></dt>
<dd>
Display help text and exit.</dd>
</dl>
</div>
<div class="section">
<h1>OPTIONS</h1><dl>
<dt>
<b>--adjfile=</b><i>filename</i></dt>
<dd>
Override the default <i>/etc/adjtime</i> file path.</dd>
</dl>
<dl>
<dt>
<b>--badyear</b></dt>
<dd>
Indicate that the Hardware Clock is incapable of storing years outside the range 1994-1999.  There is a problem in some BIOSes (almost all Award BIOSes made between 4/26/94 and 5/31/95) wherein they are unable to deal with years after 1999.  If one attempts to set the year-of-century value to something less than 94 (or 95 in some cases), the value that actually gets set is 94 (or 95).  Thus, if you have one of these machines, <b>hwclock</b> cannot set the year after 1999 and cannot use the value of the clock as the true time in the normal way.<div style="height: 1.00em;">
&#160;</div>
To compensate for this (without your getting a BIOS update, which would definitely be preferable), always use <b>--badyear</b> if you have one of these machines.  When <b>hwclock</b> knows it's working with a brain-damaged clock, it ignores the year part of the Hardware Clock value and instead tries to guess the year based on the last calibrated date in the adjtime file, by assuming that date is within the past year.  For this to work, you had better do a <b>hwclock&#160;--set</b> or <b>hwclock&#160;--systohc</b> at least once a year!<div style="height: 1.00em;">
&#160;</div>
Though <b>hwclock</b> ignores the year value when it reads the Hardware Clock, it sets the year value when it sets the clock.  It sets it to 1995, 1996, 1997, or 1998, whichever one has the same position in the leap year cycle as the true year.  That way, the Hardware Clock inserts leap days where they belong.  Again, if you let the Hardware Clock run for more than a year without setting it, this scheme could be defeated and you could end up losing a day.</dd>
</dl>
<dl>
<dt>
<b>--date=</b><i>date_string</i></dt>
<dd>
You need this option if you specify the <b>--set</b> or <b>--predict</b> functions, otherwise it is ignored. It specifies the time to which to set the Hardware Clock, or the time for which to predict the Hardware Clock reading. The value of this option is used as an argument to the <b>date</b>(1) program's <b>--date</b> option.  For example:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
<b>hwclock&#160;--set&#160;--date='2011-08-14&#160;16:45:05'</b></dd>
</dl>
<div class="spacer">
</div>
The argument must be in local time, even if you keep your Hardware Clock in UTC.  See the <b>--localtime</b> option.  The argument must not be a relative time like &quot;+5 minutes&quot;, because <b>hwclock</b>'s precision depends upon correlation between the argument's value and when the enter key is pressed.</div>
<dl>
<dt>
<b>-D</b>, <b>--debug</b></dt>
<dd>
Display a lot of information about what <b>hwclock</b> is doing internally.  Some of its functions are complex and this output can help you understand how the program works.</dd>
</dl>
<dl>
<dt>
<b>--directisa</b></dt>
<dd>
This option is meaningful for: ISA compatible machines including x86, and x86_64; and Alpha (which has a similar Hardware Clock interface).  For other machines, it has no effect.  This option tells <b>hwclock</b> to use explicit I/O instructions to access the Hardware Clock. Without this option, <b>hwclock</b> will use the rtc device, which it assumes to be driven by the RTC device driver.  As of v2.26 it will no longer automatically use directisa when the rtc driver is unavailable; this was causing an unsafe condition that could allow two processes to access the Hardware Clock at the same time. Direct hardware access from userspace should only be used for testing, troubleshooting, and as a last resort when all other methods fail.  See the <b>--rtc</b> option.</dd>
</dl>
<dl>
<dt>
<b>-f</b>,<b>&#160;--rtc=<i>filename</i></b></dt>
<dd>
Override <b>hwclock</b>'s default rtc device file name.  Otherwise it will use the first one found in this order:<br/>
<div style="height: 0.00em;">
&#160;</div>
<i>/dev/rtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/rtc0</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/misc/rtc</i><div style="height: 0.00em;">
&#160;</div>
<br/>
For <b>IA-64:</b><br/>
<div style="height: 0.00em;">
&#160;</div>
<i>/dev/efirtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/misc/efirtc</i><br/>
</dd>
</dl>
<dl>
<dt>
<b>--localtime</b></dt>
<dd>
<b>-u</b>, <b>--utc</b> Indicate which timescale the Hardware Clock is set to.<div style="height: 1.00em;">
&#160;</div>
The Hardware Clock may be configured to use either the UTC or the local timescale, but nothing in the clock itself says which alternative is being used.  The <b>--localtime</b> or <b>--utc</b> options give this information to the <b>hwclock</b> command.  If you specify the wrong one (or specify neither and take a wrong default), both setting and reading the Hardware Clock will be incorrect.<div style="height: 1.00em;">
&#160;</div>
If you specify neither <b>--utc</b> nor <b>--localtime</b> then the one last given with a set function (<b>--set</b>, <b>--systohc</b>, or <b>--adjust</b>), as recorded in <i>/etc/adjtime</i>, will be used.  If the adjtime file doesn't exist, the default is UTC.<div style="height: 1.00em;">
&#160;</div>
Note: daylight saving time changes may be inconsistent when the Hardware Clock is kept in local time.  See the discussion below, under <b>LOCAL vs UTC</b>.</dd>
</dl>
<dl>
<dt>
<b>--noadjfile</b></dt>
<dd>
Disable the facilities provided by <i>/etc/adjtime</i>. <b>hwclock</b> will not read nor write to that file with this option.  Either <b>--utc</b> or <b>--localtime</b> must be specified when using this option.</dd>
</dl>
<dl>
<dt>
<b>--test</b></dt>
<dd>
Do not actually change anything on the system, i.e., the Clocks or adjtime file.  This is useful, especially in conjunction with <b>--debug</b>, in learning about the internal operations of hwclock.</dd>
</dl>
<dl>
<dt>
<b>--update-drift</b></dt>
<dd>
Update the Hardware Clock's drift factor in <i>/etc/adjtime</i>. It is used with <b>--set</b> or <b>--systohc</b>, otherwise it is ignored.<div style="height: 1.00em;">
&#160;</div>
A minimum four hour period between settings is required.  This is to avoid invalid calculations.  The longer the period, the more precise the resulting drift factor will be.<div style="height: 1.00em;">
&#160;</div>
This option was added in v2.26, because it is typical for systems to call <b>hwclock&#160;--systohc</b> at shutdown; with the old behaviour this would automatically (re)calculate the drift factor which caused several problems:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
When using ntpd with an '11&#160;minute&#160;mode' kernel the drift factor would be clobbered to near zero.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
It would not allow the use of 'cold' drift correction.  With most configurations using 'cold' drift will yield favorable results.  Cold, means when the machine is turned off which can have a significant impact on the drift factor.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
(Re)calculating drift factor on every shutdown delivers suboptimal results.  For example, if ephemeral conditions cause the machine to be abnormally hot the drift factor calculation would be out of range.</dd>
</dl>
<div class="spacer">
</div>
Having <b>hwclock</b> calculate the drift factor is a good starting point, but for optimal results it will likely need to be adjusted by directly editing the <i>/etc/adjtime</i> file.  For most configurations once a machine's optimal drift factor is crafted it should not need to be changed.  Therefore, the old behavior to automatically (re)calculate drift was changed and now requires this option to be used.  See the discussion below, under <b>The Adjust Function</b>.</div>
</div>
<div class="section">
<h1>OPTIONS FOR ALPHA MACHINES ONLY</h1><dl>
<dt>
<b>--arc</b></dt>
<dd>
This option is equivalent to <b>--epoch=1980</b> and is used to specify the most common epoch on Alphas with an ARC console (although Ruffians have an epoch of 1900).</dd>
</dl>
<dl>
<dt>
<b>--epoch=</b><i>year</i></dt>
<dd>
Specifies the year which is the beginning of the Hardware Clock's epoch, that is the number of years into AD to which a zero value in the Hardware Clock's year counter refers.  It is used together with the <b>--setepoch</b> option to set the kernel's idea of the epoch of the Hardware Clock.<div style="height: 1.00em;">
&#160;</div>
For example, on a Digital Unix machine:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
<b>hwclock&#160;--setepoch&#160;--epoch=1952</b></dd>
</dl>
</div>
<dl>
<dt>
<b>--funky-toy</b></dt>
<dd>
<b>--jensen</b> These two options specify what kind of Alpha machine you have.  They are invalid if you do not have an Alpha and are usually unnecessary if you do; <b>hwclock</b> should be able to determine what it is running on when <i>/proc</i> is mounted.<div style="height: 1.00em;">
&#160;</div>
The <b>--jensen</b> option is used for Jensen models; <b>--funky-toy</b> means that the machine requires the UF bit instead of the UIP bit in the Hardware Clock to detect a time transition.  The &quot;toy&quot; in the option name refers to the Time Of Year facility of the machine.</dd>
</dl>
<dl>
<dt>
<b>--srm</b></dt>
<dd>
This option is equivalent to <b>--epoch=1900</b> and is used to specify the most common epoch on Alphas with an SRM console.</dd>
</dl>
</div>
<div class="section">
<h1>NOTES</h1><div class="subsection">
<h2>Clocks in a Linux System</h2> There are two types of date-time clocks:<div class="spacer">
</div>
<b>The Hardware Clock:</b> This clock is an independent hardware device, with its own power domain (battery, capacitor, etc), that operates when the machine is powered off, or even unplugged.<div class="spacer">
</div>
On an ISA compatible system, this clock is specified as part of the ISA standard.  A control program can read or set this clock only to a whole second, but it can also detect the edges of the 1 second clock ticks, so the clock actually has virtually infinite precision.<div class="spacer">
</div>
This clock is commonly called the hardware clock, the real time clock, the RTC, the BIOS clock, and the CMOS clock.  Hardware Clock, in its capitalized form, was coined for use by <b>hwclock</b>. The Linux kernel also refers to it as the persistent clock.<div class="spacer">
</div>
Some non-ISA systems have a few real time clocks with only one of them having its own power domain. A very low power external I2C or SPI clock chip might be used with a backup battery as the hardware clock to initialize a more functional integrated real-time clock which is used for most other purposes.<div class="spacer">
</div>
<b>The System Clock:</b> This clock is part of the Linux kernel and is driven by a timer interrupt.  (On an ISA machine, the timer interrupt is part of the ISA standard.)  It has meaning only while Linux is running on the machine.  The System Time is the number of seconds since 00:00:00 January 1, 1970 UTC (or more succinctly, the number of seconds since 1969 UTC).  The System Time is not an integer, though.  It has virtually infinite precision.<div class="spacer">
</div>
The System Time is the time that matters.  The Hardware Clock's basic purpose is to keep time when Linux is not running so that the System Clock can be initialized from it at boot.  Note that in DOS, for which ISA was designed, the Hardware Clock is the only real time clock.<div class="spacer">
</div>
It is important that the System Time not have any discontinuities such as would happen if you used the <b>date</b>(1) program to set it while the system is running.  You can, however, do whatever you want to the Hardware Clock while the system is running, and the next time Linux starts up, it will do so with the adjusted time from the Hardware Clock.  Note: currently this is not possible on most systems because <b>hwclock&#160;--systohc</b> is called at shutdown.<div class="spacer">
</div>
The Linux kernel's timezone is set by <b>hwclock</b>. But don't be misled -- almost nobody cares what timezone the kernel thinks it is in.  Instead, programs that care about the timezone (perhaps because they want to display a local time for you) almost always use a more traditional method of determining the timezone: They use the TZ environment variable or the <i>/etc/localtime</i> file, as explained in the man page for <b>tzset</b>(3). However, some programs and fringe parts of the Linux kernel such as filesystems use the kernel's timezone value.  An example is the vfat filesystem.  If the kernel timezone value is wrong, the vfat filesystem will report and set the wrong timestamps on files.  Another example is the kernel's NTP '11&#160;minute&#160;mode'. If the kernel's timezone value and/or the <i>persistent_clock_is_local</i> variable are wrong, then the Hardware Clock will be set incorrectly by '11&#160;minute&#160;mode'.  See the discussion below, under <b>Automatic Hardware Clock Synchronization by the Kernel</b>.<div class="spacer">
</div>
<b>hwclock</b> sets the kernel's timezone to the value indicated by TZ or <i>/etc/localtime</i> with the <b>--hctosys</b> or <b>--systz</b> functions.<div class="spacer">
</div>
The kernel's timezone value actually consists of two parts: 1) a field tz_minuteswest indicating how many minutes local time (not adjusted for DST) lags behind UTC, and 2) a field tz_dsttime indicating the type of Daylight Savings Time (DST) convention that is in effect in the locality at the present time. This second field is not used under Linux and is always zero. See also <b>settimeofday</b>(2).</div>
<div class="subsection">
<h2>Hardware Clock Access Methods</h2> <b>hwclock</b> uses many different ways to get and set Hardware Clock values.  The most normal way is to do I/O to the rtc device special file, which is presumed to be driven by the rtc device driver.  Also, Linux systems using the rtc framework with udev, are capable of supporting multiple Hardware Clocks.  This may bring about the need to override the default rtc device by specifying one with the <b>--rtc</b> option.<div class="spacer">
</div>
However, this method is not always available as older systems do not have an rtc driver.  On these systems, the method of accessing the Hardware Clock depends on the system hardware.<div class="spacer">
</div>
On an ISA compatible system, <b>hwclock</b> can directly access the &quot;CMOS memory&quot; registers that constitute the clock, by doing I/O to Ports 0x70 and 0x71.  It does this with actual I/O instructions and consequently can only do it if running with superuser effective userid.  This method may be used by specifying the <b>--directisa</b> option.<div class="spacer">
</div>
This is a really poor method of accessing the clock, for all the reasons that userspace programs are generally not supposed to do direct I/O and disable interrupts. <b>hwclock</b> provides it for testing, troubleshooting, and  because it may be the only method available on ISA compatible and Alpha systems which do not have a working rtc device driver.<div class="spacer">
</div>
In the case of a Jensen Alpha, there is no way for <b>hwclock</b> to execute those I/O instructions, and so it uses instead the <i>/dev/port</i> device special file, which provides almost as low-level an interface to the I/O subsystem.<div class="spacer">
</div>
On an m68k system, <b>hwclock</b> can access the clock with the console driver, via the device special file <i>/dev/tty1</i>.</div>
<div class="subsection">
<h2>The Adjust Function</h2> The Hardware Clock is usually not very accurate.  However, much of its inaccuracy is completely predictable - it gains or loses the same amount of time every day.  This is called systematic drift. <b>hwclock</b>'s <b>--adjust</b> function lets you apply systematic drift corrections to the Hardware Clock.<div class="spacer">
</div>
It works like this: <b>hwclock</b> keeps a file, <i>/etc/adjtime</i>, that keeps some historical information.  This is called the adjtime file.<div class="spacer">
</div>
Suppose you start with no adjtime file.  You issue a <b>hwclock&#160;--set</b> command to set the Hardware Clock to the true current time. <b>hwclock</b> creates the adjtime file and records in it the current time as the last time the clock was calibrated. Five days later, the clock has gained 10 seconds, so you issue a <b>hwclock&#160;--set&#160;--update-drift</b> command to set it back 10 seconds. <b>hwclock</b> updates the adjtime file to show the current time as the last time the clock was calibrated, and records 2 seconds per day as the systematic drift rate.  24 hours go by, and then you issue a <b>hwclock&#160;--adjust</b> command. <b>hwclock</b> consults the adjtime file and sees that the clock gains 2 seconds per day when left alone and that it has been left alone for exactly one day.  So it subtracts 2 seconds from the Hardware Clock.  It then records the current time as the last time the clock was adjusted. Another 24 hours go by and you issue another <b>hwclock&#160;--adjust</b>. <b>hwclock</b> does the same thing: subtracts 2 seconds and updates the adjtime file with the current time as the last time the clock was adjusted.<div class="spacer">
</div>
When you use the <b>--update-drift</b> option with <b>--set</b> or <b>--systohc</b>, the systematic drift rate is (re)calculated by comparing the fully drift corrected current Hardware Clock time with the new set time, from that it derives the 24 hour drift rate based on the last calibrated timestamp from the adjtime file.  This updated drift factor is then saved in <i>/etc/adjtime</i>.<div class="spacer">
</div>
A small amount of error creeps in when the Hardware Clock is set, so <b>--adjust</b> refrains from making any adjustment that is less than 1 second.  Later on, when you request an adjustment again, the accumulated drift will be more than 1 second and <b>--adjust</b> will make the adjustment including any fractional amount.<div class="spacer">
</div>
<b>hwclock&#160;--hctosys</b> also uses the adjtime file data to compensate the value read from the Hardware Clock before using it to set the System Clock.  It does not share the 1 second limitation of <b>--adjust</b>, and will correct sub-second drift values immediately.  It does not change the Hardware Clock time nor the adjtime file.  This may eliminate the need to use <b>--adjust</b>, unless something else on the system needs the Hardware Clock to be compensated.</div>
<div class="subsection">
<h2>The Adjtime File</h2> While named for its historical purpose of controlling adjustments only, it actually contains other information used by <b>hwclock</b> from one invocation to the next.<div class="spacer">
</div>
The format of the adjtime file is, in ASCII:<div class="spacer">
</div>
Line 1: Three numbers, separated by blanks: 1) the systematic drift rate in seconds per day, floating point decimal; 2) the resulting number of seconds since 1969 UTC of most recent adjustment or calibration, decimal integer; 3) zero (for compatibility with <b>clock</b>(8)) as a decimal integer.<div class="spacer">
</div>
Line 2: One number: the resulting number of seconds since 1969 UTC of most recent calibration.  Zero if there has been no calibration yet or it is known that any previous calibration is moot (for example, because the Hardware Clock has been found, since that calibration, not to contain a valid time).  This is a decimal integer.<div class="spacer">
</div>
Line 3: &quot;UTC&quot; or &quot;LOCAL&quot;.  Tells whether the Hardware Clock is set to Coordinated Universal Time or local time.  You can always override this value with options on the <b>hwclock</b> command line.<div class="spacer">
</div>
You can use an adjtime file that was previously used with the <b>clock</b>(8) program with <b>hwclock</b>.</div>
<div class="subsection">
<h2>Automatic Hardware Clock Synchronization by the Kernel</h2> You should be aware of another way that the Hardware Clock is kept synchronized in some systems.  The Linux kernel has a mode wherein it copies the System Time to the Hardware Clock every 11 minutes. This mode is a compile time option, so not all kernels will have this capability. This is a good mode to use when you are using something sophisticated like NTP to keep your System Clock synchronized. (NTP is a way to keep your System Time synchronized either to a time server somewhere on the network or to a radio clock hooked up to your system.  See RFC 1305.)<div class="spacer">
</div>
If the kernel is compiled with the '11&#160;minute&#160;mode' option it will be active when the kernel's clock discipline is in a synchronized state. When in this state, bit 6 (the bit that is set in the mask 0x0040) of the kernel's <i>time_status</i> variable is unset. This value is output as the 'status' line of the <b>adjtimex&#160;--print</b> or <b>ntptime</b> commands.<div class="spacer">
</div>
It takes an outside influence, like the NTP daemon <b>ntpd</b>(1), to put the kernel's clock discipline into a synchronized state, and therefore turn on '11&#160;minute&#160;mode'. It can be turned off by running anything that sets the System Clock the old fashioned way, including <b>hwclock&#160;--hctosys</b>. However, if the NTP daemon is still running, it will turn '11&#160;minute&#160;mode' back on again the next time it synchronizes the System Clock.<div class="spacer">
</div>
If your system runs with '11&#160;minute&#160;mode' on, it may need to use either <b>--hctosys</b> or <b>--systz</b> in a startup script, especially if the Hardware Clock is configured to use the local timescale. Unless the kernel is informed of what timescale the Hardware Clock is using, it may clobber it with the wrong one. The kernel uses UTC by default.<div class="spacer">
</div>
The first userspace command to set the System Clock informs the kernel what timescale the Hardware Clock is using.  This happens via the <i>persistent_clock_is_local</i> kernel variable.  If <b>--hctosys</b> or <b>--systz</b> is the first, it will set this variable according to the adjtime file or the appropriate command-line argument.  Note that when using this capability and the Hardware Clock timescale configuration is changed, then a reboot is required to notify the kernel.<div class="spacer">
</div>
<b>hwclock&#160;--adjust</b> should not be used with NTP '11&#160;minute&#160;mode'.</div>
<div class="subsection">
<h2>ISA Hardware Clock Century value</h2> There is some sort of standard that defines CMOS memory Byte 50 on an ISA machine as an indicator of what century it is. <b>hwclock</b> does not use or set that byte because there are some machines that don't define the byte that way, and it really isn't necessary anyway, since the year-of-century does a good job of implying which century it is.<div class="spacer">
</div>
If you have a bona fide use for a CMOS century byte, contact the <b>hwclock</b> maintainer; an option may be appropriate.<div class="spacer">
</div>
Note that this section is only relevant when you are using the &quot;direct ISA&quot; method of accessing the Hardware Clock. ACPI provides a standard way to access century values, when they are supported by the hardware.</div>
</div>
<div class="section">
<h1>DATE-TIME CONFIGURATION</h1><br/>
<div class="subsection">
<h2>Keeping Time without External Synchronization</h2><br/>
<div class="spacer">
</div>
This discussion is based on the following conditions:<dl>
<dt>
&#8226;</dt>
<dd>
Nothing is running that alters the date-time clocks, such as <b>ntpd</b>(1) or a cron job.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The system timezone is configured for the correct local time.  See below, under <b>POSIX vs 'RIGHT'</b>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Early during startup the following are called, in this order:<div style="height: 0.00em;">
&#160;</div>
<b>adjtimex&#160;--tick</b><i>&#160;value&#160;</i><b>--frequency</b><i>&#160;value</i><div style="height: 0.00em;">
&#160;</div>
<b>hwclock&#160;--hctosys</b></dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
During shutdown the following is called:<div style="height: 0.00em;">
&#160;</div>
<b>hwclock&#160;--systohc</b></dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>*</b> Systems without <b>adjtimex</b> may use <b>ntptime</b>.<br/>
<div class="spacer">
</div>
Whether maintaining precision time with <b>ntpd</b>(1) or not, it makes sense to configure the system to keep reasonably good date-time on its own.<div class="spacer">
</div>
The first step in making that happen is having a clear understanding of the big picture.  There are two completely separate hardware devices running at their own speed and drifting away from the 'correct' time at their own rates.  The methods and software for drift correction are different for each of them.  However, most systems are configured to exchange values between these two clocks at startup and shutdown.  Now the individual device's time keeping errors are transferred back and forth between each other.  Attempt to configure drift correction for only one of them, and the other's drift will be overlaid upon it.<div class="spacer">
</div>
This problem can be avoided when configuring drift correction for the System Clock by simply not shutting down the machine.  This, plus the fact that all of <b>hwclock</b>'s precision (including calculating drift factors) depends upon the System Clock's rate being correct, means that configuration of the System Clock should be done first.<div class="spacer">
</div>
The System Clock drift is corrected with the <b>adjtimex</b>(8) command's <b>--tick</b> and <b>--frequency</b> options.  These two work together: tick is the coarse adjustment and frequency is the fine adjustment.  (For systems that do not have an <b>adjtimex</b> package, <b>ntptime&#160;-f&#160;</b><i>ppm</i> may be used instead.)<div class="spacer">
</div>
Some Linux distributions attempt to automatically calculate the System Clock drift with <b>adjtimex</b>'s compare operation.  Trying to correct one drifting clock by using another drifting clock as a reference is akin to a dog trying to catch its own tail.  Success may happen eventually, but great effort and frustration will likely precede it.  This automation may yield an improvement over no configuration, but expecting optimum results would be in error.  A better choice for manual configuration would be <b>adjtimex</b>'s<b> --log </b>options.<div class="spacer">
</div>
It may be more effective to simply track the System Clock drift with <b>sntp</b>, or <b>date&#160;-Ins</b> and a precision timepiece, and then calculate the correction manually.<div class="spacer">
</div>
After setting the tick and frequency values, continue to test and refine the adjustments until the System Clock keeps good time.  See <b>adjtimex</b>(8) for more information and the example demonstrating manual drift calculations.<div class="spacer">
</div>
Once the System Clock is ticking smoothly, move on to the Hardware Clock.<div class="spacer">
</div>
As a rule, cold drift will work best for most use cases.  This should be true even for 24/7 machines whose normal downtime consists of a reboot. In that case the drift factor value makes little difference.  But on the rare occasion that the machine is shut down for an extended period, then cold drift should yield better results.<div class="spacer">
</div>
<b>Steps to calculate cold drift:</b><dl>
<dt>
1</dt>
<dd>
Ensure that <b>ntpd</b>(1) will not be launched at startup.</dd>
</dl>
<dl>
<dt>
2</dt>
<dd>
The<i> System Clock </i>time must be correct at shutdown!</dd>
</dl>
<dl>
<dt>
3</dt>
<dd>
Shut down the system.</dd>
</dl>
<dl>
<dt>
4</dt>
<dd>
Let an extended period pass without changing the Hardware Clock.</dd>
</dl>
<dl>
<dt>
5</dt>
<dd>
Start the system.</dd>
</dl>
<dl>
<dt>
6</dt>
<dd>
Immediately use <b>hwclock</b> to set the correct time, adding the <b>--update-drift</b> option.</dd>
</dl>
<div class="spacer">
</div>
Note: if step 6 uses <b>--systohc</b>, then the System Clock must be set correctly (step 6a) just before doing so.<div class="spacer">
</div>
Having <b>hwclock</b> calculate the drift factor is a good starting point, but for optimal results it will likely need to be adjusted by directly editing the <i>/etc/adjtime</i> file.  Continue to test and refine the drift factor until the Hardware Clock is corrected properly at startup.  To check this, first make sure that the System Time is correct before shutdown and then use <b>sntp</b>, or <b>date&#160;-Ins</b> and a precision timepiece, immediately after startup.</div>
<div class="subsection">
<h2>LOCAL vs UTC</h2> Keeping the Hardware Clock in a local timescale causes inconsistent daylight saving time results:<dl>
<dt>
&#8226;</dt>
<dd>
If Linux is running during a daylight saving time change, the time written to the Hardware Clock will be adjusted for the change.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If Linux is NOT running during a daylight saving time change, the time read from the Hardware Clock will NOT be adjusted for the change.</dd>
</dl>
<div class="spacer">
</div>
The Hardware Clock on an ISA compatible system keeps only a date and time, it has no concept of timezone nor daylight saving. Therefore, when <b>hwclock</b> is told that it is in local time, it assumes it is in the 'correct' local time and makes no adjustments to the time read from it.<div class="spacer">
</div>
Linux handles daylight saving time changes transparently only when the Hardware Clock is kept in the UTC timescale. Doing so is made easy for system administrators as <b>hwclock</b> uses local time for its output and as the argument to the <b>--date</b> option.<div class="spacer">
</div>
POSIX systems, like Linux, are designed to have the System Clock operate in the UTC timescale. The Hardware Clock's purpose is to initialize the System Clock, so also keeping it in UTC makes sense.<div class="spacer">
</div>
Linux does, however, attempt to accommodate the Hardware Clock being in the local timescale. This is primarily for dual-booting with older versions of MS Windows. From Windows 7 on, the RealTimeIsUniversal registry key is supposed to be working properly so that its Hardware Clock can be kept in UTC.</div>
<div class="subsection">
<h2>POSIX vs 'RIGHT'</h2> A discussion on date-time configuration would be incomplete without addressing timezones, this is mostly well covered by <b>tzset</b>(3). One area that seems to have no documentation is the 'right' directory of the Time Zone Database, sometimes called tz or zoneinfo.<div class="spacer">
</div>
There are two separate databases in the zoneinfo system, posix and 'right'. 'Right' (now named zoneinfo-leaps) includes leap seconds and posix does not. To use the 'right' database the System Clock must be set to (UTC&#160;+&#160;leap seconds), which is equivalent to (TAI&#160;-&#160;10). This allows calculating the exact number of seconds between two dates that cross a leap second epoch. The System Clock is then converted to the correct civil time, including UTC, by using the 'right' timezone files which subtract the leap seconds. Note: this configuration is considered experimental and is known to have issues.<div class="spacer">
</div>
To configure a system to use a particular database all of the files located in its directory must be copied to the root of <i>/usr/share/zoneinfo</i>. Files are never used directly from the posix or 'right' subdirectories, e.g., TZ='<i>right/Europe/Dublin</i>'. This habit was becoming so common that the upstream zoneinfo project restructured the system's file tree by moving the posix and 'right' subdirectories out of the zoneinfo directory and into sibling directories:<div class="spacer">
</div>
<br/>
<i>/usr/share/zoneinfo</i><div style="height: 0.00em;">
&#160;</div>
<i>/usr/share/zoneinfo-posix</i><div style="height: 0.00em;">
&#160;</div>
<i>/usr/share/zoneinfo-leaps</i><div class="spacer">
</div>
Unfortunately, some Linux distributions are changing it back to the old tree structure in their packages. So the problem of system administrators reaching into the 'right' subdirectory persists. This causes the system timezone to be configured to include leap seconds while the zoneinfo database is still configured to exclude them. Then when an application such as a World Clock needs the South_Pole timezone file; or an email MTA, or <b>hwclock</b> needs the UTC timezone file; they fetch it from the root of <i>/usr/share/zoneinfo</i> , because that is what they are supposed to do. Those files exclude leap seconds, but the System Clock now includes them, causing an incorrect time conversion.<div class="spacer">
</div>
Attempting to mix and match files from these separate databases will not work, because they each require the System Clock to use a different timescale. The zoneinfo database must be configured to use either posix or 'right', as described above, or by assigning a database path to the <small><b>TZDIR</b></small> environment variable.</div>
</div>
<div class="section">
<h1>ENVIRONMENT</h1><dl>
<dt>
<b>TZ</b></dt>
<dd>
If this variable is set its value takes precedence over the system configured timezone.</dd>
</dl>
<dl>
<dt>
<b>TZDIR</b></dt>
<dd>
If this variable is set its value takes precedence over the system configured timezone database directory path.</dd>
</dl>
</div>
<div class="section">
<h1>FILES</h1><dl>
<dt>
<i>/etc/adjtime</i></dt>
<dd>
The configuration and state file for hwclock.</dd>
</dl>
<dl>
<dt>
<i>/etc/localtime</i></dt>
<dd>
The system timezone file.</dd>
</dl>
<dl>
<dt>
<i>/usr/share/zoneinfo/</i></dt>
<dd>
The system timezone database directory.</dd>
</dl>
<div class="spacer">
</div>
Device files <b>hwclock</b> may try for Hardware Clock access:<div style="height: 0.00em;">
&#160;</div>
<i>/dev/rtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/rtc0</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/misc/rtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/efirtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/misc/efirtc</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/port</i><div style="height: 0.00em;">
&#160;</div>
<i>/dev/tty1</i></div>
<div class="section">
<h1>SEE ALSO</h1> <b>date</b>(1), <b>adjtimex</b>(8), <b>gettimeofday</b>(2), <b>settimeofday</b>(2), <b>crontab</b>(1), <b>tzset</b>(3)</div>
<div class="section">
<h1>AUTHORS</h1> Written by Bryan Henderson, September 1996 (bryanh@giraffe-data.com), based on work done on the <b>clock</b>(8) program by Charles Hedrick, Rob Hooft, and Harald Koenig. See the source code for complete history and credits.</div>
<div class="section">
<h1>AVAILABILITY</h1> The hwclock command is part of the util-linux package and is available from ftp://ftp.kernel.org/pub/linux/utils/util-linux/.</div>
<table class="foot">
<tr>
<td class="foot-date">
April 2015</td>
<td class="foot-os">
util-linux</td>
</tr>
</table>
</div>
</body>
</html>

