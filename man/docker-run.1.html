<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
DOCKER(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DOCKER(1)</td>
<td class="head-vol">
JUNE 2014</td>
<td class="head-rtitle">
DOCKER(1)</td>
</tr>
</tbody>
</table>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="section">
<h1>NAME</h1> docker-run - Run a command in a new container<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>docker run</b> [ <b>-a</b>|<b>--attach</b>[=<i>[]</i>]] [ <b>--add-host</b>[=<i>[]</i>]] [ <b>--blkio-weight</b>[=<i>[BLKIO-WEIGHT]</i>]] [ <b>--cpu-shares</b>[=<i>0</i>]] [ <b>--cap-add</b>[=<i>[]</i>]] [ <b>--cap-drop</b>[=<i>[]</i>]] [ <b>--cgroup-parent</b>[=<i>CGROUP-PATH</i>]] [ <b>--cidfile</b>[=<i>CIDFILE</i>]] [ <b>--cpu-period</b>[=<i>0</i>]] [ <b>--cpu-quota</b>[=<i>0</i>]] [ <b>--cpuset-cpus</b>[=<i>CPUSET-CPUS</i>]] [ <b>--cpuset-mems</b>[=<i>CPUSET-MEMS</i>]] [ <b>-d</b>|<b>--detach</b>[=<i>false</i>]] [ <b>--device</b>[=<i>[]</i>]] [ <b>--dns</b>[=<i>[]</i>]] [ <b>--dns-opt</b>[=<i>[]</i>]] [ <b>--dns-search</b>[=<i>[]</i>]] [ <b>-e</b>|<b>--env</b>[=<i>[]</i>]] [ <b>--entrypoint</b>[=<i>ENTRYPOINT</i>]] [ <b>--env-file</b>[=<i>[]</i>]] [ <b>--expose</b>[=<i>[]</i>]] [ <b>--group-add</b>[=<i>[]</i>]] [ <b>-h</b>|<b>--hostname</b>[=<i>HOSTNAME</i>]] [ <b>--help</b>] [ <b>-i</b>|<b>--interactive</b>[=<i>false</i>]] [ <b>--ipc</b>[=<i>IPC</i>]] [ <b>--kernel-memory</b>[=<i>KERNEL-MEMORY</i>]] [ <b>-l</b>|<b>--label</b>[=<i>[]</i>]] [ <b>--label-file</b>[=<i>[]</i>]] [ <b>--link</b>[=<i>[]</i>]] [ <b>--log-driver</b>[=<i>[]</i>]] [ <b>--log-opt</b>[=<i>[]</i>]] [ <b>--lxc-conf</b>[=<i>[]</i>]] [ <b>-m</b>|<b>--memory</b>[=<i>MEMORY</i>]] [ <b>--mac-address</b>[=<i>MAC-ADDRESS</i>]] [ <b>--memory-reservation</b>[=<i>MEMORY-RESERVATION</i>]] [ <b>--memory-swap</b>[=<i>MEMORY-SWAP</i>]] [ <b>--memory-swappiness</b>[=<i>MEMORY-SWAPPINESS</i>]] [ <b>--name</b>[=<i>NAME</i>]] [ <b>--net</b>[=<i>&quot;bridge&quot;</i>]] [ <b>--oom-kill-disable</b>[=<i>false</i>]] [ <b>-P</b>|<b>--publish-all</b>[=<i>false</i>]] [ <b>-p</b>|<b>--publish</b>[=<i>[]</i>]] [ <b>--pid</b>[=<i>[]</i>]] [ <b>--privileged</b>[=<i>false</i>]] [ <b>--read-only</b>[=<i>false</i>]] [ <b>--restart</b>[=<i>RESTART</i>]] [ <b>--rm</b>[=<i>false</i>]] [ <b>--security-opt</b>[=<i>[]</i>]] [ <b>--stop-signal</b>[=<i>SIGNAL</i>]] [ <b>--sig-proxy</b>[=<i>true</i>]] [ <b>-t</b>|<b>--tty</b>[=<i>false</i>]] [ <b>-u</b>|<b>--user</b>[=<i>USER</i>]] [ <b>-v</b>|<b>--volume</b>[=<i>[]</i>]] [ <b>--ulimit</b>[=<i>[]</i>]] [ <b>--uts</b>[=<i>[]</i>]] [ <b>--volumes-from</b>[=<i>[]</i>]] [ <b>-w</b>|<b>--workdir</b>[=<i>WORKDIR</i>]] IMAGE [COMMAND] [ARG...]<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Run a process in a new container.  <b>docker run</b> starts a process with its own file system, its own networking, and its own isolated process tree. The IMAGE which starts the process may define defaults related to the process that will be run in the container, the networking to expose, and more, but  <b>docker run</b> gives final control to the operator or administrator who starts the container from the image. For that reason  <b>docker run</b> has more options than any other Docker command.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If the IMAGE is not already loaded then <b>docker run</b> will pull the IMAGE, and all image dependencies, from the repository in the same way running  <b>docker</b>  <b>pull</b> IMAGE, before it starts the container from that image.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>OPTIONS</h1>  <b>-a</b>, <b>--attach</b>=[]<br/>
   Attach to STDIN, STDOUT or STDERR.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
In foreground mode (the default when <b>-d</b> is not specified),  <b>docker run</b> can start the process in the container and attach the console to the process&#8217;s standard input, output, and standard error. It can even pretend to be a TTY (this is what most commandline executables expect) and pass along signals. The  <b>-a</b> option can be set for each of stdin, stdout, and stderr.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--add-host</b>=[]<br/>
   Add a custom host-to-IP mapping (host:ip)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Add a line to /etc/hosts. The format is hostname:ip.  The <b>--add-host</b> option can be set multiple times.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--blkio-weight</b>=0<br/>
   Block IO weight (relative weight) accepts a weight value between 10 and 1000.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cpu-shares</b>=0<br/>
   CPU shares (relative weight)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
By default, all containers get the same proportion of CPU cycles. This proportion can be modified by changing the container's CPU share weighting relative to the weighting of all other running containers.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
To modify the proportion from the default of 1024, use the <b>--cpu-shares</b> flag to set the weighting to 2 or higher.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The proportion will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. The actual amount of CPU time will vary depending on the number of containers running on the system.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
For example, consider three containers, one has a cpu-share of 1024 and two others have a cpu-share setting of 512. When processes in all three containers attempt to use 100% of CPU, the first container would receive 50% of the total CPU time. If you add a fourth container with a cpu-share of 1024, the first container only gets 33% of the CPU. The remaining containers receive 16.5%, 16.5% and 33% of the CPU.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is limited to less than 100% of CPU time, it can use 100% of each individual CPU core.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
For example, consider a system with more than three cores. If you start one container  <b>{C0}</b> with <b>-c=512</b> running one process, and another container  <b>{C1}</b> with <b>-c=1024</b> running two processes, this can result in the following division of CPU shares:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
PID    container    CPU CPU share<br/>
100    {C0}     0   100% of CPU0<br/>
101    {C1}     1   100% of CPU1<br/>
102    {C1}     2   100% of CPU2<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cap-add</b>=[]<br/>
   Add Linux capabilities<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cap-drop</b>=[]<br/>
   Drop Linux capabilities<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cgroup-parent</b>=&quot;&quot;<br/>
   Path to cgroups under which the cgroup for the container will be created. If the path is not absolute, the path is considered to be relative to the cgroups path of the init process. Cgroups will be created if they do not already exist.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cidfile</b>=&quot;&quot;<br/>
   Write the container ID to the file<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cpu-period</b>=0<br/>
   Limit the CPU CFS (Completely Fair Scheduler) period<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Limit the container's CPU usage. This flag tell the kernel to restrict the container's CPU usage to the period you specify.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cpuset-cpus</b>=&quot;&quot;<br/>
   CPUs in which to allow execution (0-3, 0,1)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cpuset-mems</b>=&quot;&quot;<br/>
   Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If you have four memory nodes on your system (0-3), use <b></b>--cpuset-mems=0,1 then processes in your Docker container will only use memory from the first two memory nodes.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--cpu-quota</b>=0<br/>
   Limit the CPU CFS (Completely Fair Scheduler) quota<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Limit the container's CPU usage. By default, containers run with the full CPU resource. This flag tell the kernel to restrict the container's CPU usage to the quota you specify.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-d</b>, <b>--detach</b>=<i>true</i>|<i>false</i><br/>
   Detached mode: run the container in the background and print the new container ID. The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
At any time you can run <b>docker ps</b> in the other shell to view a list of the running containers. You can reattach to a detached container with  <b>docker attach</b>. If you choose to run a container in the detached mode, then you cannot use the  <b>-rm</b> option.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When attached in the tty mode, you can detach from a running container without stopping the process by pressing the keys CTRL-P CTRL-Q.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--device</b>=[]<br/>
   Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc:rwm)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--dns-search</b>=[]<br/>
   Set custom DNS search domains (Use --dns-search=. if you don't wish to set the search domain)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--dns-opt</b>=[]<br/>
   Set custom DNS options<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--dns</b>=[]<br/>
   Set custom DNS servers<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
This option can be used to override the DNS configuration passed to the container. Typically this is necessary when the host DNS configuration is invalid for the container (e.g., 127.0.0.1). When this is the case the  <b>--dns</b> flags is necessary for every run.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-e</b>, <b>--env</b>=[]<br/>
   Set environment variables<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
This option allows you to specify arbitrary environment variables that are available for the process that will be launched inside of the container.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--entrypoint</b>=&quot;&quot;<br/>
   Overwrite the default ENTRYPOINT of the image<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
This option allows you to overwrite the default entrypoint of the image that is set in the Dockerfile. The ENTRYPOINT of an image is similar to a COMMAND because it specifies what executable to run when the container starts, but it is (purposely) more difficult to override. The ENTRYPOINT gives a container its default nature or behavior, so that when you set an ENTRYPOINT you can run the container as if it were that binary, complete with default options, and you can pass in more options via the COMMAND. But, sometimes an operator may want to run something else inside the container, so you can override the default ENTRYPOINT at runtime by using a  <b>--entrypoint</b> and a string to specify the new ENTRYPOINT.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--env-file</b>=[]<br/>
   Read in a line delimited file of environment variables<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--expose</b>=[]<br/>
   Expose a port, or a range of ports (e.g. --expose=3300-3310) informs Docker that the container listens on the specified network ports at runtime. Docker uses this information to interconnect containers using links and to set up port redirection on the host system.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--group-add</b>=[]<br/>
   Add additional groups to run as<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-h</b>, <b>--hostname</b>=&quot;&quot;<br/>
   Container host name<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Sets the container host name that is available inside the container.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--help</b><br/>
  Print usage statement<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-i</b>, <b>--interactive</b>=<i>true</i>|<i>false</i><br/>
   Keep STDIN open even if not attached. The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When set to true, keep stdin open even if not attached. The default is false.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--ipc</b>=&quot;&quot;<br/>
   Default is to create a private IPC namespace (POSIX SysV IPC) for the container<br/>
                               'container:&lt;name|id&gt;': reuses another container shared memory, semaphores and message queues<br/>
                               'host': use the host shared memory,semaphores and message queues inside the container.  Note: the host mode gives the container full access to local shared memory and is therefore considered insecure.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-l</b>, <b>--label</b>=[]<br/>
   Set metadata on the container (e.g., --label com.example.key=value)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--kernel-memory</b>=&quot;&quot;<br/>
   Kernel memory limit (format: <b></b>&lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Constrains the kernel memory available to a container. If a limit of 0 is specified (not using  <b></b>--kernel-memory), the container's kernel memory is not limited. If you specify a limit, it may be rounded up to a multiple of the operating system's page size and the value can be very large, millions of trillions.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--label-file</b>=[]<br/>
   Read in a line delimited file of labels<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--link</b>=[]<br/>
   Add link to another container in the form of &lt;name or id&gt;:alias or just &lt;name or id&gt; in which case the alias will match the name<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If the operator uses  <b>--link</b> when starting the new client container, then the client container can access the exposed port via a private networking interface. Docker will set some environment variables in the client container to help indicate which interface and port to use.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--lxc-conf</b>=[]<br/>
   (lxc exec-driver only) Add custom lxc options --lxc-conf=&quot;lxc.cgroup.cpuset.cpus = 0,1&quot;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--log-driver</b>=&quot;|<i>json-file</i>|<i>syslog</i>|<i>journald</i>|<i>gelf</i>|<i>fluentd</i>|<i>awslogs</i>|<i>none</i>&quot;<br/>
  Logging driver for container. Default is defined by daemon <b></b>--log-driver flag.<br/>
  <b>Warning</b>: the <b></b>docker logs command works only for the <b></b>json-file and<br/>
  <b></b>journald logging drivers.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--log-opt</b>=[]<br/>
  Logging driver specific options.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-m</b>, <b>--memory</b>=&quot;&quot;<br/>
   Memory limit (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Allows you to constrain the memory available to a container. If the host supports swap memory, then the  <b>-m</b> memory setting can be larger than physical RAM. If a limit of 0 is specified (not using  <b>-m</b>), the container's memory is not limited. The actual limit may be rounded up to a multiple of the operating system's page size (the value would be very large, that's millions of trillions).<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--memory-reservation</b>=&quot;&quot;<br/>
   Memory soft limit (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
After setting memory reservation, when the system detects memory contention or low memory, containers are forced to restrict their consumption to their reservation. So you should always set the value below  <b>--memory</b>, otherwise the hard limit will take precedence. By default, memory reservation will be the same as memory limit.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--memory-swap</b>=&quot;&quot;<br/>
   Total memory limit (memory + swap)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Set <b></b>-1 to disable swap (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g). This value should always larger than  <b>-m</b>, so you should always use this with <b>-m</b>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--mac-address</b>=&quot;&quot;<br/>
   Container MAC address (e.g. 92:d0:c6:0a:29:33)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Remember that the MAC address in an Ethernet network must be unique. The IPv6 link-local address will be based on the device's MAC address according to RFC4862.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--name</b>=&quot;&quot;<br/>
   Assign a name to the container<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The operator can identify a container in three ways:<br/>
    UUID long identifier (&#8220;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&#8221;)<br/>
    UUID short identifier (&#8220;f78375b1c487&#8221;)<br/>
    Name (&#8220;jonah&#8221;)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The UUID identifiers come from the Docker daemon, and if a name is not assigned to the container with  <b>--name</b> then the daemon will also generate a random string name. The name is useful when defining links (see  <b>--link</b>) (or any other place you need to identify a container). This works for both background and foreground Docker containers.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--net</b>=&quot;bridge&quot;<br/>
   Set the Network mode for the container<br/>
                               'bridge': creates a new network stack for the container on the docker bridge<br/>
                               'none': no networking for this container<br/>
                               'container:&lt;name|id&gt;': reuses another container network stack<br/>
                               'host': use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--oom-kill-disable</b>=<i>true</i>|<i>false</i><br/>
   Whether to disable OOM Killer for the container or not.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-P</b>, <b>--publish-all</b>=<i>true</i>|<i>false</i><br/>
   Publish all exposed ports to random ports on the host interfaces. The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When set to true publish all exposed ports to the host interfaces. The default is false. If the operator uses -P (or -p) then Docker will make the exposed port accessible on the host and the ports will be available to any client that can reach the host. When using -P, Docker will bind any exposed port to a random port on the host within an  <i>ephemeral port range</i> defined by  <b></b>/proc/sys/net/ipv4/ip_local_port_range. To find the mapping between the host ports and the exposed ports, use  <b></b>docker port.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-p</b>, <b>--publish</b>=[]<br/>
   Publish a container's port, or range of ports, to the host.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Format: <b></b>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort Both hostPort and containerPort can be specified as a range of ports. When specifying ranges for both, the number of container ports in the range must match the number of host ports in the range. (e.g.,  <b></b>docker run -p 1234-1236:1222-1224 --name thisWorks -t busybox but not  <b></b>docker run -p 1230-1236:1230-1240 --name RangeContainerPortsBiggerThanRangeHostPorts -t busybox) With ip:  <b></b>docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage Use  <b></b>docker port to see the actual mapping: <b></b>docker port CONTAINER $CONTAINERPORT<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--pid</b>=host<br/>
   Set the PID mode for the container<br/>
     <b>host</b>: use the host's PID namespace inside the container.<br/>
     Note: the host mode gives the container full access to local PID and is therefore considered insecure.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--uts</b>=host<br/>
   Set the UTS mode for the container<br/>
     <b>host</b>: use the host's UTS namespace inside the container.<br/>
     Note: the host mode gives the container access to changing the host's hostname and is therefore considered insecure.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--privileged</b>=<i>true</i>|<i>false</i><br/>
   Give extended privileges to this container. The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
By default, Docker containers are &#8220;unprivileged&#8221; (=false) and cannot, for example, run a Docker daemon inside the Docker container. This is because by default a container is not allowed to access any devices. A &#8220;privileged&#8221; container is given access to all devices.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When the operator executes <b>docker run --privileged</b>, Docker will enable access to all devices on the host as well as set some configuration in AppArmor to allow the container nearly all the same access to the host as processes running outside of a container on the host.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--read-only</b>=<i>true</i>|<i>false</i><br/>
   Mount the container's root filesystem as read only.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
By default a container will have its root filesystem writable allowing processes to write files anywhere.  By specifying the  <b></b>--read-only flag the container will have its root filesystem mounted as read only prohibiting any writes.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--restart</b>=&quot;no&quot;<br/>
   Restart policy to apply when a container exits (no, on-failure[:max-retry], always, unless-stopped).<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--rm</b>=<i>true</i>|<i>false</i><br/>
   Automatically remove the container when it exits (incompatible with -d). The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--security-opt</b>=[]<br/>
   Security Options<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
&quot;label:user:USER&quot;   : Set the label user for the container<br/>
    &quot;label:role:ROLE&quot;   : Set the label role for the container<br/>
    &quot;label:type:TYPE&quot;   : Set the label type for the container<br/>
    &quot;label:level:LEVEL&quot; : Set the label level for the container<br/>
    &quot;label:disable&quot;     : Turn off label confinement for the container<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--stop-signal</b>=SIGTERM<br/>
  Signal to stop a container. Default is SIGTERM.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--sig-proxy</b>=<i>true</i>|<i>false</i><br/>
   Proxy received signals to the process (non-TTY mode only). SIGCHLD, SIGSTOP, and SIGKILL are not proxied. The default is <i>true</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--memory-swappiness</b>=&quot;&quot;<br/>
   Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-t</b>, <b>--tty</b>=<i>true</i>|<i>false</i><br/>
   Allocate a pseudo-TTY. The default is <i>false</i>.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When set to true Docker can allocate a pseudo-tty and attach to the standard input of any container. This can be used, for example, to run a throwaway interactive shell. The default is value is false.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The <b>-t</b> option is incompatible with a redirection of the docker client standard input.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-u</b>, <b>--user</b>=&quot;&quot;<br/>
   Sets the username or UID used and optionally the groupname or GID for the specified command.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The followings examples are all valid:<br/>
   --user [user | user:group | uid | uid:gid | user:gid | uid:group ]<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Without this argument the command will be run as root in the container.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
&quot;&quot;--ulimit&quot;&quot;=[]<br/>
    Ulimit options<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-v</b>, <b>--volume</b>=[] Create a bind mount<br/>
   (format: <b></b>[host-dir:]container-dir[:&lt;suffix options&gt;], where suffix options are comma delimited and selected from [rw|ro] and [z|Z].)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
(e.g., using -v /host-dir:/container-dir, bind mounts /host-dir in the host to /container-dir in the Docker container)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If 'host-dir' is missing, then docker automatically creates the new volume on the host.  <b>This auto-creation of the host path has been deprecated in</b>  <b>Release: v1.9.</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The <b>-v</b> option can be used one or more times to add one or more mounts to a container. These mounts can then be used in other containers using the  <b>--volumes-from</b> option.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The volume may be optionally suffixed with :ro or :rw to mount the volumes in read-only or read-write mode, respectively. By default, the volumes are mounted read-write. See examples.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Labeling systems like SELinux require that proper labels are placed on volume content mounted into a container. Without a label, the security system might prevent the processes running inside the container from using the content. By default, Docker does not change the labels set by the OS.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
To change a label in the container context, you can add either of two suffixes  <b></b>:z or <b></b>:Z to the volume mount. These suffixes tell Docker to relabel file objects on the shared volumes. The  <b></b>z option tells Docker that two containers share the volume content. As a result, Docker labels the content with a shared content label. Shared volume labels allow all containers to read/write content. The  <b></b>Z option tells Docker to label the content with a private unshared label. Only the current container can use a private volume.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The <b></b>container-dir must always be an absolute path such as <b></b>/src/docs. The  <b></b>host-dir can either be an absolute path or a <b></b>name value. If you supply an absolute path for the  <b></b>host-dir, Docker bind-mounts to the path you specify. If you supply a  <b></b>name, Docker creates a named volume by that <b></b>name.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
A <b></b>name value must start with start with an alphanumeric character, followed by  <b></b>a-z0-9, <b></b>_ (underscore), <b></b>. (period) or <b></b>- (hyphen). An absolute path starts with a  <b></b>/ (forward slash).<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
For example, you can specify either <b></b>/foo or <b></b>foo for a <b></b>host-dir value. If you supply the  <b></b>/foo value, Docker creates a bind-mount. If you supply the  <b></b>foo specification, Docker creates a named volume.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>--volumes-from</b>=[]<br/>
   Mount volumes from the specified container(s)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Mounts already mounted volumes from a source container onto another<br/>
   container. You must supply the source's container-id. To share<br/>
   a volume, use the <b>--volumes-from</b> option when running<br/>
   the target container. You can share volumes even if the source container<br/>
   is not running.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
By default, Docker mounts the volumes in the same mode (read-write or<br/>
   read-only) as it is mounted in the source container. Optionally, you<br/>
   can change this by suffixing the container-id with either the <b></b>:ro or<br/>
   <b></b>:rw keyword.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If the location of the volume from the source container overlaps with<br/>
   data residing on a target container, then the volume hides<br/>
   that data on the target.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>-w</b>, <b>--workdir</b>=&quot;&quot;<br/>
   Working directory inside the container<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
The default working directory for running binaries within a container is the root directory (/). The developer can set a different default with the Dockerfile WORKDIR instruction. The operator can override the working directory by using the  <b>-w</b> option.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>EXAMPLES</h1></div>
<div class="section">
<h1>Exposing log messages from the container to the host's log</h1> If you want messages that are logged in your container to show up in the host's syslog/journal then you should bind mount the /dev/log directory as follows.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run -v /dev/log:/dev/log -i -t fedora /bin/bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
From inside the container you can test this by sending a message to the log.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
(bash)# logger &quot;Hello from my container&quot;<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Then exit and check the journal.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# exit<div class="spacer">
</div>
<br/>
# journalctl -b | grep Hello<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
This should list the message sent to logger.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Attaching to one or more from STDIN, STDOUT, STDERR</h1> If you do not specify -a then Docker will attach everything (stdin,stdout,stderr) you&#8217;d like to connect instead, as in:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run -a stdin -a stdout -i -t fedora /bin/bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Sharing IPC between containers</h1> Using shm_server.c available here: &#10216;https://www.cs.cf.ac.uk/Dave/C/node27.html&#10217;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Testing <b></b>--ipc=host mode:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Host shows a shared memory segment with 7 pids attached, happens to be from httpd:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ sudo ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <br/>
 0x01128e25 0          root       600        1000       7                       <div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Now run a regular container, and it correctly does NOT see the shared memory segment from the host:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ docker run -it shm ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Run a container with the new <b></b>--ipc=host option, and it now sees the shared memory segment from the host httpd:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ docker run -it --ipc=host shm ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <br/>
 0x01128e25 0          root       600        1000       7                   <div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Testing <b></b>--ipc=container:CONTAINERID mode:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Start a container with a program to create a shared memory segment:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ docker run -it shm bash<br/>
 $ sudo shm/shm_server <br/>
 $ sudo ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <br/>
 0x0000162e 0          root       666        27         1                       <div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Create a 2nd container correctly shows no shared memory segment from 1st container:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ docker run shm ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Create a 3rd container using the new --ipc=container:CONTAINERID option, now it shows the shared memory segment from the first:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ docker run -it --ipc=container:ed735b2264ac shm ipcs -m<br/>
 $ sudo ipcs -m<div class="spacer">
</div>
<br/>
 ------ Shared Memory Segments --------<br/>
 key        shmid      owner      perms      bytes      nattch     status      <br/>
 0x0000162e 0          root       666        27         1<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Linking Containers</h1> The link feature allows multiple containers to communicate with each other. For example, a container whose Dockerfile has exposed port 80 can be run and named as follows:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --name=link-test -d -i -t fedora/httpd<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
A second container, in this case called linker, can communicate with the httpd container, named link-test, by running with the  <b>--link=&lt;name&gt;:&lt;alias&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run -t -i --link=link-test:lt --name=linker fedora /bin/bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Now the container linker is linked to container link-test with the alias lt. Running the  <b>env</b> command in the linker container shows environment variables<br/>
 with the LT (alias) context (<b>LT_</b>)<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# env<br/>
HOSTNAME=668231cb0978<br/>
TERM=xterm<br/>
LT_PORT_80_TCP=tcp://172.17.0.3:80<br/>
LT_PORT_80_TCP_PORT=80<br/>
LT_PORT_80_TCP_PROTO=tcp<br/>
LT_PORT=tcp://172.17.0.3:80<br/>
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br/>
PWD=/<br/>
LT_NAME=/linker/lt<br/>
SHLVL=1<br/>
HOME=/<br/>
LT_PORT_80_TCP_ADDR=172.17.0.3<br/>
_=/usr/bin/env<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When linking two containers Docker will use the exposed ports of the container to create a secure tunnel for the parent to access.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If a container is connected to the default bridge network and <b></b>linked with other containers, then the container's  <b></b>/etc/hosts file is updated with the linked container's name.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>Note</b> Since Docker may live update the container&#8217;s <b></b>/etc/hosts file, there may be situations when processes inside the container can end up reading an empty or incomplete  <b></b>/etc/hosts file. In most cases, retrying the read again should fix the problem.</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Mapping Ports for External Usage</h1> The exposed port of an application can be mapped to a host port using the  <b>-p</b> flag. For example, a httpd port 80 can be mapped to the host port 8080 using the following:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run -p 8080:80 -d -i -t fedora/httpd<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Creating and Mounting a Data Volume Container</h1> Many applications require the sharing of persistent data across several containers. Docker allows you to create a Data Volume Container that other containers can mount from. For example, create a named container that contains directories /var/volume1 and /tmp/volume2. The image will need to contain these directories so a couple of RUN mkdir instructions might be required for you fedora-data image:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --name=data -v /var/volume1 -v /tmp/volume2 -i -t fedora-data true<br/>
# docker run --volumes-from=data --name=fedora-container1 -i -t fedora bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Multiple --volumes-from parameters will bring together multiple data volumes from multiple containers. And it's possible to mount the volumes that came from the DATA container in yet another container via the fedora-container1 intermediary container, allowing to abstract the actual data source from users of that data:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --volumes-from=fedora-container1 --name=fedora-container2 -i -t fedora bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Mounting External Volumes</h1> To mount a host directory as a container volume, specify the absolute path to the directory and the absolute path for the container directory separated by a colon:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run -v /var/db:/data1 -i -t fedora bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
When using SELinux, be aware that the host has no knowledge of container SELinux policy. Therefore, in the above example, if SELinux policy is enforced, the  <b></b>/var/db directory is not writable to the container. A &quot;Permission Denied&quot; message will occur and an avc: message in the host's syslog.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
To work around this, at time of writing this man page, the following command needs to be run in order for the proper SELinux policy type label to be attached to the host directory:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# chcon -Rt svirt_sandbox_file_t /var/db<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Now, writing to the /data1 volume in the container will be allowed and the changes will also be reflected on the host in /var/db.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Using alternative security labeling</h1> You can override the default labeling scheme for each container by specifying the  <b></b>--security-opt flag. For example, you can specify the MCS/MLS level, a requirement for MLS systems. Specifying the level in the following command allows you to share the same content between containers.<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --security-opt label:level:s0:c100,c200 -i -t fedora bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
An MLS example might be:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --security-opt label:level:TopSecret -i -t rhel7 bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
To disable the security labeling for this container versus running with the  <b></b>--permissive flag, use the following command:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --security-opt label:disable -i -t fedora bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
If you want a tighter security policy on the processes within a container, you can specify an alternate type for the container. You could run a container that is only allowed to listen on Apache ports by executing the following command:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<br/>
# docker run --security-opt label:type:svirt_apache_t -i -t centos bash<div class="spacer">
</div>
<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
Note:<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
You would have to write policy defining a <b></b>svirt_apache_t type.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>HISTORY</h1> April 2014, Originally compiled by William Henry (whenry at redhat dot com) based on docker.com source material and internal work. June 2014, updated by Sven Dowideit &#10216;SvenDowideit@home.org.au&#10217; July 2014, updated by Sven Dowideit &#10216;SvenDowideit@home.org.au&#10217;</div>
<table class="foot">
<tr>
<td class="foot-date">
 Docker User Manuals</td>
<td class="foot-os">
Docker Community</td>
</tr>
</table>
</div>
</body>
</html>

