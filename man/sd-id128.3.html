<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
SD-ID128(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SD-ID128(3)</td>
<td class="head-vol">
sd-id128</td>
<td class="head-rtitle">
SD-ID128(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> sd-id128, sd_id128_t, SD_ID128_MAKE, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL, sd_id128_equal - APIs for processing 128-bit IDs</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
#include &lt;systemd/sd-id128.h&gt;<br/>
<div class="spacer">
</div>
<div style="margin-left: 38.00ex;text-indent: -38.00ex;" class="spacer">
<b>pkg-config --cflags --libs libsystemd</b></div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> sd-id128.h provides APIs to process and generate 128-bit ID values. The 128-bit ID values processed and generated by these APIs are a generalization of OSF UUIDs as defined by  <b>RFC 4122</b>[1] but use a simpler string format. These functions impose no structure on the used IDs, much unlike OSF UUIDs or Microsoft GUIDs, but are fully compatible with those types of IDs.<div class="spacer">
</div>
See  <b>sd_id128_to_string</b>(3),  <b>sd_id128_randomize</b>(3) and  <b>sd_id128_get_machine</b>(3) for more information about the implemented functions.<div class="spacer">
</div>
A 128-bit ID is implemented as the following union type:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
typedef union sd_id128 {<br/>
  uint8_t bytes[16];<br/>
  uint64_t qwords[2];<br/>
} sd_id128_t;<br/>
</div>
<div class="spacer">
</div>
This union type allows accessing the 128-bit ID as 16 separate bytes or two 64-bit words. It is generally safer to access the ID components by their 8-bit array to avoid endianness issues. This union is intended to be passed call-by-value (as opposed to call-by-reference) and may be directly manipulated by clients.<div class="spacer">
</div>
A couple of macros are defined to denote and decode 128-bit IDs:<div class="spacer">
</div>
<b>SD_ID128_MAKE()</b> may be used to denote a constant 128-bit ID in source code. A commonly used idiom is to assign a name to a 128-bit ID using this macro:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
#define SD_MESSAGE_COREDUMP SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)<br/>
</div>
<div class="spacer">
</div>
<b>SD_ID128_CONST_STR()</b> may be used to convert constant 128-bit IDs into constant strings for output. The following example code will output the string &quot;fc2e22bc6ee647b6b90729ab34a250b1&quot;:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
int main(int argc, char *argv[]) {<br/>
  puts(SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP));<br/>
}<br/>
</div>
<div class="spacer">
</div>
<b>SD_ID128_FORMAT_STR</b> and  <b>SD_ID128_FORMAT_VAL()</b> may be used to format a 128-bit ID in a  <b>printf</b>(3) format string, as shown in the following example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
int main(int argc, char *argv[]) {<br/>
  sd_id128_t id;<br/>
  id = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);<br/>
  printf(&quot;The ID encoded in this C file is &quot; SD_ID128_FORMAT_STR &quot;.\n&quot;, SD_ID128_FORMAT_VAL(id));<br/>
  return 0;<br/>
}<br/>
</div>
<div class="spacer">
</div>
Use  <b>sd_id128_equal()</b> to compare two 128-bit IDs:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
int main(int argc, char *argv[]) {<br/>
  sd_id128_t a, b, c;<br/>
  a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);<br/>
  b = SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);<br/>
  c = a;<br/>
  assert(sd_id128_equal(a, c));<br/>
  assert(!sd_id128_equal(a, b));<br/>
  return 0;<br/>
}<br/>
</div>
<div class="spacer">
</div>
Note that new, randomized IDs may be generated with  <b>journalctl</b>(1)'s  <b>--new-id</b> option.</div>
<div class="section">
<h1>NOTES</h1> These APIs are implemented as a shared library, which can be compiled and linked to with the  <b>libsystemd</b>&#160;<b>pkg-config</b>(1) file.</div>
<div class="section">
<h1>SEE ALSO</h1><div style="height: 1.00em;">
&#160;</div>
<b>systemd</b>(1),  <b>sd_id128_to_string</b>(3),  <b>sd_id128_randomize</b>(3),  <b>sd_id128_get_machine</b>(3),  <b>printf</b>(3),  <b>journalctl</b>(1),  <b>sd-journal</b>(7),  <b>pkg-config</b>(1),  <b>machine-id</b>(5)</div>
<div class="section">
<h1>NOTES</h1><dl>
<dt>
 1.</dt>
<dd>
RFC 4122</dd>
</dl>
<div style="margin-left: 4.00ex;">
https://tools.ietf.org/html/rfc4122</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
</td>
<td class="foot-os">
systemd 226</td>
</tr>
</table>
</div>
</body>
</html>

