<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
Filesystem(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Filesystem(3)</td>
<td class="head-vol">
Tcl Library Procedures</td>
<td class="head-rtitle">
Filesystem(3)</td>
</tr>
</tbody>
</table>
<br/>
<br/>
<div class="section">
<h1>NAME</h1> Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_AllocStatBuf - procedures to interact with any filesystem</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<b>#include &lt;tcl.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSRegister</b>(<i>clientData, fsPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSUnregister</b>(<i>fsPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
ClientData<br/>
<b>Tcl_FSData</b>(<i>fsPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
void<br/>
<b>Tcl_FSMountsChanged</b>(<i>fsPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Filesystem*<br/>
<b>Tcl_FSGetFileSystemForPath</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_PathType<br/>
<b>Tcl_FSGetPathType</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSCopyFile</b>(<i>srcPathPtr, destPathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSCopyDirectory</b>(<i>srcPathPtr, destPathPtr, errorPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSCreateDirectory</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSDeleteFile</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSRemoveDirectory</b>(<i>pathPtr, int recursive, errorPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSRenameFile</b>(<i>srcPathPtr, destPathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSListVolumes</b>(<i>void</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSEvalFileEx</b>(<i>interp, pathPtr, encodingName</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSEvalFile</b>(<i>interp, pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSLoadFile</b>(<i>interp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr,</i><br/>
<i>               handlePtr, unloadProcPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSMatchInDirectory</b>(<i>interp, resultPtr, pathPtr, pattern, types</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSLink</b>(<i>linkNamePtr, toPtr, linkAction</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSLstat</b>(<i>pathPtr, statPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSUtime</b>(<i>pathPtr, tval</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSFileAttrsGet</b>(<i>interp, int index, pathPtr, objPtrRef</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSFileAttrsSet</b>(<i>interp, int index, pathPtr, Tcl_Obj *objPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
const char**<br/>
<b>Tcl_FSFileAttrStrings</b>(<i>pathPtr, objPtrRef</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSStat</b>(<i>pathPtr, statPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSAccess</b>(<i>pathPtr, mode</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Channel<br/>
<b>Tcl_FSOpenFileChannel</b>(<i>interp, pathPtr, modeString, permissions</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSGetCwd</b>(<i>interp</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSChdir</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSPathSeparator</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSJoinPath</b>(<i>listObj, elements</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSSplitPath</b>(<i>pathPtr, lenPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSEqualPaths</b>(<i>firstPtr, secondPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSGetNormalizedPath</b>(<i>interp, pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSJoinToPath</b>(<i>basePtr, objc, objv</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_FSConvertToPathType</b>(<i>interp, pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
ClientData<br/>
<b>Tcl_FSGetInternalRep</b>(<i>pathPtr, fsPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj *<br/>
<b>Tcl_FSGetTranslatedPath</b>(<i>interp, pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
const char *<br/>
<b>Tcl_FSGetTranslatedStringPath</b>(<i>interp, pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSNewNativePath</b>(<i>fsPtr, clientData</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
const char *<br/>
<b>Tcl_FSGetNativePath</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Obj*<br/>
<b>Tcl_FSFileSystemInfo</b>(<i>pathPtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_StatBuf*<br/>
<b>Tcl_AllocStatBuf</b>()</div>
<div class="section">
<h1>ARGUMENTS</h1><dl>
<dt>
Tcl_Filesystem <i>*fsPtr</i> (in)</dt>
<dd>
Points to a structure containing the addresses of procedures that can be called to perform the various filesystem operations.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*pathPtr</i> (in)</dt>
<dd>
The path represented by this object is used for the operation in question.  If the object does not already have an internal  <b>path</b> representation, it will be converted to have one.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*srcPathPtr</i> (in)</dt>
<dd>
As for <i>pathPtr</i>, but used for the source file for a copy or rename operation.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*destPathPtr</i> (in)</dt>
<dd>
As for <i>pathPtr</i>, but used for the destination filename for a copy or rename operation.</dd>
</dl>
<dl>
<dt>
const char <i>*encodingName</i> (in)</dt>
<dd>
The encoding of the data stored in the file identified by  <i>pathPtr</i> and to be evaluated.</dd>
</dl>
<dl>
<dt>
const char <i>*pattern</i> (in)</dt>
<dd>
Only files or directories matching this pattern will be returned.</dd>
</dl>
<dl>
<dt>
Tcl_GlobTypeData <i>*types</i> (in)</dt>
<dd>
Only files or directories matching the type descriptions contained in this structure will be returned.  This parameter may be NULL.</dd>
</dl>
<dl>
<dt>
Tcl_Interp <i>*interp</i> (in)</dt>
<dd>
Interpreter to use either for results, evaluation, or reporting error messages.</dd>
</dl>
<dl>
<dt>
ClientData <i>clientData</i> (in)</dt>
<dd>
The native description of the path object to create.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*firstPtr</i> (in)</dt>
<dd>
The first of two path objects to compare.  The object may be converted to  <b>path</b> type.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*secondPtr</i> (in)</dt>
<dd>
The second of two path objects to compare.  The object may be converted to  <b>path</b> type.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*listObj</i> (in)</dt>
<dd>
The list of path elements to operate on with a <b>join</b> operation.</dd>
</dl>
<dl>
<dt>
int <i>elements</i> (in)</dt>
<dd>
If non-negative, the number of elements in the <i>listObj</i> which should be joined together.  If negative, then all elements are joined.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>**errorPtr</i> (out)</dt>
<dd>
In the case of an error, filled with an object containing the name of the file which caused an error in the various copy/rename operations.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>**objPtrRef</i> (out)</dt>
<dd>
Filled with an object containing the result of the operation.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*resultPtr</i> (out)</dt>
<dd>
Pre-allocated object in which to store (using  <b>Tcl_ListObjAppendElement</b>) the list of files or directories which are successfully matched.</dd>
</dl>
<dl>
<dt>
int <i>mode</i> (in)</dt>
<dd>
Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.  R_OK, W_OK and X_OK request checking whether the file exists and  has  read, write and  execute  permissions, respectively.  F_OK just requests checking for the existence of the file.</dd>
</dl>
<dl>
<dt>
Tcl_StatBuf <i>*statPtr</i> (out)</dt>
<dd>
The structure that contains the result of a stat or lstat operation.</dd>
</dl>
<dl>
<dt>
const char <i>*sym1</i> (in)</dt>
<dd>
Name of a procedure to look up in the file's symbol table</dd>
</dl>
<dl>
<dt>
const char <i>*sym2</i> (in)</dt>
<dd>
Name of a procedure to look up in the file's symbol table</dd>
</dl>
<dl>
<dt>
Tcl_PackageInitProc <i>**proc1Ptr</i> (out)</dt>
<dd>
Filled with the init function for this code.</dd>
</dl>
<dl>
<dt>
Tcl_PackageInitProc <i>**proc2Ptr</i> (out)</dt>
<dd>
Filled with the safe-init function for this code.</dd>
</dl>
<dl>
<dt>
ClientData <i>*clientDataPtr</i> (out)</dt>
<dd>
Filled with the clientData value to pass to this code's unload function when it is called.</dd>
</dl>
<dl>
<dt>
Tcl_LoadHandle <i>*handlePtr</i> (out)</dt>
<dd>
Filled with an abstract token representing the loaded file.</dd>
</dl>
<dl>
<dt>
Tcl_FSUnloadFileProc <i>**unloadProcPtr</i> (out)</dt>
<dd>
Filled with the function to use to unload this piece of code.</dd>
</dl>
<dl>
<dt>
utimbuf <i>*tval</i> (in)</dt>
<dd>
The access and modification times in this structure are read and used to set those values for a given file.</dd>
</dl>
<dl>
<dt>
const char <i>*modeString</i> (in)</dt>
<dd>
Specifies how the file is to be accessed.  May have any of the values allowed for the  <i>mode</i> argument to the Tcl <b>open</b> command.</dd>
</dl>
<dl>
<dt>
int <i>permissions</i> (in)</dt>
<dd>
POSIX-style permission flags such as 0644.  If a new file is created, these permissions will be set on the created file.</dd>
</dl>
<dl>
<dt>
int <i>*lenPtr</i> (out)</dt>
<dd>
If non-NULL, filled with the number of elements in the split path.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*basePtr</i> (in)</dt>
<dd>
The base path on to which to join the given elements.  May be NULL.</dd>
</dl>
<dl>
<dt>
int <i>objc</i> (in)</dt>
<dd>
The number of elements in <i>objv</i>.</dd>
</dl>
<dl>
<dt>
Tcl_Obj *const <i>objv[]</i> (in)</dt>
<dd>
The elements to join to the given base path.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*linkNamePtr</i> (in)</dt>
<dd>
The name of the link to be created or read.</dd>
</dl>
<dl>
<dt>
Tcl_Obj <i>*toPtr</i> (in)</dt>
<dd>
What the link called <i>linkNamePtr</i> should be linked to, or NULL if the symbolic link specified by  <i>linkNamePtr</i> is to be read.</dd>
</dl>
<dl>
<dt>
int <i>linkAction</i> (in)</dt>
<dd>
OR-ed combination of flags indicating what kind of link should be created (will be ignored if  <i>toPtr</i> is NULL). Valid bits to set are  <b>TCL_CREATE_SYMBOLIC_LINK</b> and <b>TCL_CREATE_HARD_LINK</b>. When both flags are set and the underlying filesystem can do either, symbolic links are preferred.<br/>
<br/>
<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>DESCRIPTION</h1> There are several reasons for calling the  <b>Tcl_FS</b> API functions (e.g.  <b>Tcl_FSAccess</b> and <b>Tcl_FSStat</b>) rather than calling system level functions like  <b>access</b> and  <b>stat</b> directly.  First, they will work cross-platform, so an extension which calls them should work unmodified on Unix and Windows.  Second, the Windows implementation of some of these functions fixes some bugs in the system level calls.  Third, these function calls deal with any &#8220;Utf to platform-native&#8221; path conversions which may be required (and may cache the results of such conversions for greater efficiency on subsequent calls).  Fourth, and perhaps most importantly, all of these functions are &#8220;virtual filesystem aware&#8221;. Any virtual filesystem (VFS for short) which has been registered (through  <b>Tcl_FSRegister</b>) may reroute file access to alternative media or access methods.  This means that all of these functions (and therefore the corresponding  <b>file</b>, <b>glob</b>, <b>pwd</b>, <b>cd</b>,  <b>open</b>, etc.  Tcl commands) may be operate on &#8220;files&#8221; which are not native files in the native filesystem.  This also means that any Tcl extension which accesses the filesystem (FS for short) through this API is automatically &#8220;virtual filesystem aware&#8221;. Of course, if an extension accesses the native filesystem directly (through platform-specific APIs, for example), then Tcl cannot intercept such calls.<div class="spacer">
</div>
If appropriate VFSes have been registered, the &#8220;files&#8221; may, to give two examples, be remote (e.g. situated on a remote ftp server) or archived (e.g. lying inside a .zip archive).  Such registered filesystems provide a lookup table of functions to implement all or some of the functionality listed here.  Finally, the  <b>Tcl_FSStat</b> and <b>Tcl_FSLstat</b> calls abstract away from what the &#8220;struct stat&#8221; buffer is actually declared to be, allowing the same code to be used both on systems with and systems without support for files larger than 2GB in size.<div class="spacer">
</div>
The <b>Tcl_FS</b> API is objectified and may cache internal representations and other path-related strings (e.g. the current working directory).  One side-effect of this is that one must not pass in objects with a reference count of zero to any of these functions.  If such calls were handled, they might result in memory leaks (under some circumstances, the filesystem code may wish to retain a reference to the passed in object, and so one must not assume that after any of these calls return, the object still has a reference count of zero - it may have been incremented) or in a direct segmentation fault (or other memory access error) due to the object being freed part way through the complex object manipulation required to ensure that the path is fully normalized and absolute for filesystem determination.  The practical lesson to learn from this is that<div style="margin-left: 5.00ex;">
<br/>
Tcl_Obj *path = Tcl_NewStringObj(...);<br/>
Tcl_FS<i>Whatever</i>(path);<br/>
Tcl_DecrRefCount(path);<br/>
</div>
is wrong, and may cause memory errors. The <i>path</i> must have its reference count incremented before passing it in, or decrementing it.  For this reason, objects with a reference count of zero are considered not to be valid filesystem paths and calling any Tcl_FS API function with such an object will result in no action being taken.<div class="subsection">
<h2>FS API FUNCTIONS</h2>  <b>Tcl_FSCopyFile</b> attempts to copy the file given by <i>srcPathPtr</i> to the path name given by  <i>destPathPtr</i>.  If the two paths given lie in the same filesystem (according to  <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#8220;copy file&#8221; function is called (if it is non-NULL). Otherwise the function returns -1 and sets the  <b>errno</b> global C variable to the &#8220;EXDEV&#8221; POSIX error code (which signifies a &#8220;cross-domain link&#8221;).<div class="spacer">
</div>
<b>Tcl_FSCopyDirectory</b> attempts to copy the directory given by <i>srcPathPtr</i> to the path name given by  <i>destPathPtr</i>.  If the two paths given lie in the same filesystem (according to  <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#8220;copy file&#8221; function is called (if it is non-NULL). Otherwise the function returns -1 and sets the  <b>errno</b> global C variable to the &#8220;EXDEV&#8221; POSIX error code (which signifies a &#8220;cross-domain link&#8221;).<div class="spacer">
</div>
<b>Tcl_FSCreateDirectory</b> attempts to create the directory given by  <i>pathPtr</i> by calling the owning filesystem's &#8220;create directory&#8221; function.<div class="spacer">
</div>
<b>Tcl_FSDeleteFile</b> attempts to delete the file given by  <i>pathPtr</i> by calling the owning filesystem's &#8220;delete file&#8221; function.<div class="spacer">
</div>
<b>Tcl_FSRemoveDirectory</b> attempts to remove the directory given by  <i>pathPtr</i> by calling the owning filesystem's &#8220;remove directory&#8221; function.<div class="spacer">
</div>
<b>Tcl_FSRenameFile</b> attempts to rename the file or directory given by  <i>srcPathPtr</i> to the path name given by <i>destPathPtr</i>.  If the two paths given lie in the same filesystem (according to  <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#8220;rename file&#8221; function is called (if it is non-NULL).  Otherwise the function returns -1 and sets the  <b>errno</b> global C variable to the &#8220;EXDEV&#8221; POSIX error code (which signifies a &#8220;cross-domain link&#8221;).<div class="spacer">
</div>
<b>Tcl_FSListVolumes</b> calls each filesystem which has a non-NULL &#8220;list volumes&#8221; function and asks them to return their list of root volumes.  It accumulates the return values in a list which is returned to the caller (with a reference count of 0).<div class="spacer">
</div>
<b>Tcl_FSEvalFileEx</b> reads the file given by <i>pathPtr</i> using the encoding identified by  <i>encodingName</i> and evaluates its contents as a Tcl script.  It returns the same information as  <b>Tcl_EvalObjEx</b>. If  <i>encodingName</i> is NULL, the system encoding is used for reading the file contents. If the file could not be read then a Tcl error is returned to describe why the file could not be read. The eofchar for files is &#8220;\32&#8221; (^Z) for all platforms. If you require a &#8220;^Z&#8221; in code for string comparison, you can use &#8220;\032&#8221; or &#8220;\u001a&#8221;, which will be safely substituted by the Tcl interpreter into &#8220;^Z&#8221;.  <b>Tcl_FSEvalFile</b> is a simpler version of  <b>Tcl_FSEvalFileEx</b> that always uses the system encoding when reading the file.<div class="spacer">
</div>
<b>Tcl_FSLoadFile</b> dynamically loads a binary code file into memory and returns the addresses of two procedures within that file, if they are defined.  The appropriate function for the filesystem to which  <i>pathPtr</i> belongs will be called.  If that filesystem does not implement this function (most virtual filesystems will not, because of OS limitations in dynamically loading binary code), Tcl will attempt to copy the file to a temporary directory and load that temporary file.<div class="spacer">
</div>
Returns a standard Tcl completion code.  If an error occurs, an error message is left in the  <i>interp</i>'s result.<div class="spacer">
</div>
<b>Tcl_FSMatchInDirectory</b> is used by the globbing code to search a directory for all files which match a given pattern.  The appropriate function for the filesystem to which  <i>pathPtr</i> belongs will be called.<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in globbing.  Error messages are placed in interp (unless interp is NULL, which is allowed), but good results are placed in the resultPtr given.<div class="spacer">
</div>
Note that the <b>glob</b> code implements recursive patterns internally, so this function will only ever be passed simple patterns, which can be matched using the logic of  <b>string match</b>.  To handle recursion, Tcl will call this function frequently asking only for directories to be returned.  A special case of being called with a NULL pattern indicates that the path needs to be checked only for the correct type.<div class="spacer">
</div>
<b>Tcl_FSLink</b> replaces the library version of <b>readlink</b>, and extends it to support the creation of links.  The appropriate function for the filesystem to which  <i>linkNamePtr</i> belongs will be called.<div class="spacer">
</div>
If the <i>toPtr</i> is NULL, a &#8220;read link&#8221; action is performed.  The result is a Tcl_Obj specifying the contents of the symbolic link given by  <i>linkNamePtr</i>, or NULL if the link could not be read.  The result is owned by the caller, which should call Tcl_DecrRefCount when the result is no longer needed.  If the  <i>toPtr</i> is not NULL, Tcl should create a link of one of the types passed in in the  <i>linkAction</i> flag.  This flag is an ORed combination of  <b>TCL_CREATE_SYMBOLIC_LINK</b> and <b>TCL_CREATE_HARD_LINK</b>. Where a choice exists (i.e. more than one flag is passed in), the Tcl convention is to prefer symbolic links.  When a link is successfully created, the return value should be  <i>toPtr</i> (which is therefore already owned by the caller).  If unsuccessful, NULL is returned.<div class="spacer">
</div>
<b>Tcl_FSLstat</b> fills the stat structure <i>statPtr</i> with information about the specified file.  You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file.  The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time.<div class="spacer">
</div>
If <i>path</i> exists, <b>Tcl_FSLstat</b> returns 0 and the stat structure is filled with data.  Otherwise, -1 is returned, and no stat info is given.<div class="spacer">
</div>
<b>Tcl_FSUtime</b> replaces the library version of utime.<div class="spacer">
</div>
This returns 0 on success and -1 on error (as per the <b>utime</b> documentation).  If successful, the function will update the &#8220;atime&#8221; and &#8220;mtime&#8221; values of the file given.<div class="spacer">
</div>
<b>Tcl_FSFileAttrsGet</b> implements read access for the hookable <b>file</b>  <b>attributes</b> subcommand.  The appropriate function for the filesystem to which  <i>pathPtr</i> belongs will be called.<div class="spacer">
</div>
If the result is <b>TCL_OK</b>, then an object was placed in  <i>objPtrRef</i>, which will only be temporarily valid (unless  <b>Tcl_IncrRefCount</b> is called).<div class="spacer">
</div>
<b>Tcl_FSFileAttrsSet</b> implements write access for the hookable <b>file</b>  <b>attributes</b> subcommand.  The appropriate function for the filesystem to which  <i>pathPtr</i> belongs will be called.<div class="spacer">
</div>
<b>Tcl_FSFileAttrStrings</b> implements part of the hookable <b>file</b>  <b>attributes</b> subcommand.  The appropriate function for the filesystem to which  <i>pathPtr</i> belongs will be called.<div class="spacer">
</div>
The called procedure may either return an array of strings, or may instead return NULL and place a Tcl list into the given  <i>objPtrRef</i>.  Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count.  Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it retains a reference count to the object.<div class="spacer">
</div>
<b>Tcl_FSAccess</b> checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is  <i>pathname</i>.   If <i>pathname</i> is a symbolic link on Unix, then permissions of the file referred by this symbolic link are tested.<div class="spacer">
</div>
On success (all requested permissions granted), zero is returned.  On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned.<div class="spacer">
</div>
<b>Tcl_FSStat</b> fills the stat structure <i>statPtr</i> with information about the specified file.  You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file.  The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time.<div class="spacer">
</div>
If <i>path</i> exists, <b>Tcl_FSStat</b> returns 0 and the stat structure is filled with data.  Otherwise, -1 is returned, and no stat info is given.<div class="spacer">
</div>
<b>Tcl_FSOpenFileChannel</b> opens a file specified by <i>pathPtr</i> and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the  <b>fopen</b> procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl  <b>open</b> command when opening a file. If an error occurs while opening the channel,  <b>Tcl_FSOpenFileChannel</b> returns NULL and records a POSIX error code that can be retrieved with  <b>Tcl_GetErrno</b>. In addition, if  <i>interp</i> is non-NULL, <b>Tcl_FSOpenFileChannel</b> leaves an error message in  <i>interp</i>'s result after any error.<div class="spacer">
</div>
The newly created channel is not registered in the supplied interpreter; to register it, use  <b>Tcl_RegisterChannel</b>. If one of the standard channels,  <b>stdin, stdout</b> or <b>stderr</b> was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.<div class="spacer">
</div>
<b>Tcl_FSGetCwd</b> replaces the library version of <b>getcwd</b>.<div class="spacer">
</div>
It returns the Tcl library's current working directory.  This may be different to the native platform's working directory, which happens when the current working directory is not in the native filesystem.<div class="spacer">
</div>
The result is a pointer to a Tcl_Obj specifying the current directory, or NULL if the current directory could not be determined.  If NULL is returned, an error message is left in the  <i>interp</i>'s result.<div class="spacer">
</div>
The result already has its reference count incremented for the caller.  When it is no longer needed, that reference count should be decremented.  This is needed for thread-safety purposes, to allow multiple threads to access this and related functions, while ensuring the results are always valid.<div class="spacer">
</div>
<b>Tcl_FSChdir</b> replaces the library version of <b>chdir</b>.  The path is normalized and then passed to the filesystem which claims it.  If that filesystem does not implement this function, Tcl will fallback to a combination of  <b>stat</b> and <b>access</b> to check whether the directory exists and has appropriate permissions.<div class="spacer">
</div>
For results, see <b>chdir</b> documentation.  If successful, we keep a record of the successful path in  <i>cwdPathPtr</i> for subsequent calls to  <b>Tcl_FSGetCwd</b>.<div class="spacer">
</div>
<b>Tcl_FSPathSeparator</b> returns the separator character to be used for most specific element of the path specified by  <i>pathPtr</i> (i.e. the last part of the path).<div class="spacer">
</div>
The separator is returned as a Tcl_Obj containing a string of length 1.  If the path is invalid, NULL is returned.<div class="spacer">
</div>
<b>Tcl_FSJoinPath</b> takes the given Tcl_Obj, which must be a valid list (which is allowed to have a reference count of zero), and returns the path object given by considering the first  <i>elements</i> elements as valid path segments (each path segment may be a complete path, a partial path or just a single possible directory or file name).  If any path segment is actually an absolute path, then all prior path segments are discarded. If  <i>elements</i> is less than 0, we use the entire list.<div class="spacer">
</div>
It is possible that the returned object is actually an element of the given list, so the caller should be careful to increment the reference count of the result before freeing the list.<div class="spacer">
</div>
The returned object, typically with a reference count of zero (but it could be shared under some conditions), contains the joined path.  The caller must add a reference count to the object before using it.  In particular, the returned object could be an element of the given list, so freeing the list might free the object prematurely if no reference count has been taken. If the number of elements is zero, then the returned object will be an empty-string Tcl_Obj.<div class="spacer">
</div>
<b>Tcl_FSSplitPath</b> takes the given Tcl_Obj, which should be a valid path, and returns a Tcl list object containing each segment of that path as an element. It returns a list object with a reference count of zero.  If the passed in  <i>lenPtr</i> is non-NULL, the variable it points to will be updated to contain the number of elements in the returned list.<div class="spacer">
</div>
<b>Tcl_FSEqualPaths</b> tests whether the two paths given represent the same filesystem object<div class="spacer">
</div>
It returns 1 if the paths are equal, and 0 if they are different.  If either path is NULL, 0 is always returned.<div class="spacer">
</div>
<b>Tcl_FSGetNormalizedPath</b> this important function attempts to extract from the given Tcl_Obj a unique normalized path representation, whose string value can be used as a unique identifier for the file.<div class="spacer">
</div>
It returns the normalized path object, owned by Tcl, or NULL if the path was invalid or could otherwise not be successfully converted. Extraction of absolute, normalized paths is very efficient (because the filesystem operates on these representations internally), although the result when the filesystem contains numerous symbolic links may not be the most user-friendly version of a path.  The return value is owned by Tcl and has a lifetime equivalent to that of the  <i>pathPtr</i> passed in (unless that is a relative path, in which case the normalized path object may be freed any time the cwd changes) - the caller can of course increment the refCount if it wishes to maintain a copy for longer.<div class="spacer">
</div>
<b>Tcl_FSJoinToPath</b> takes the given object, which should usually be a valid path or NULL, and joins onto it the array of paths segments given.<div class="spacer">
</div>
Returns object, typically with refCount of zero (but it could be shared under some conditions), containing the joined path.  The caller must add a refCount to the object before using it.  If any of the objects passed into this function (pathPtr or path elements) have a refCount of zero, they will be freed when this function returns.<div class="spacer">
</div>
<b>Tcl_FSConvertToPathType</b> tries to convert the given Tcl_Obj to a valid Tcl path type, taking account of the fact that the cwd may have changed even if this object is already supposedly of the correct type. The filename may begin with &#8220;~&#8221; (to indicate current user's home directory) or &#8220;~&lt;user&gt;&#8221; (to indicate any user's home directory).<div class="spacer">
</div>
If the conversion succeeds (i.e. the object is a valid path in one of the current filesystems), then  <b>TCL_OK</b> is returned.  Otherwise  <b>TCL_ERROR</b> is returned, and an error message may be left in the interpreter.<div class="spacer">
</div>
<b>Tcl_FSGetInternalRep</b> extracts the internal representation of a given path object, in the given filesystem.  If the path object belongs to a different filesystem, we return NULL. If the internal representation is currently NULL, we attempt to generate it, by calling the filesystem's  <b>Tcl_FSCreateInternalRepProc</b>.<div class="spacer">
</div>
Returns NULL or a valid internal path representation.  This internal representation is cached, so that repeated calls to this function will not require additional conversions.<div class="spacer">
</div>
<b>Tcl_FSGetTranslatedPath</b> attempts to extract the translated path from the given Tcl_Obj.<div class="spacer">
</div>
If the translation succeeds (i.e. the object is a valid path), then it is returned.  Otherwise NULL will be returned, and an error message may be left in the interpreter.  A &#8220;translated&#8221; path is one which contains no &#8220;~&#8221; or &#8220;~user&#8221; sequences (these have been expanded to their current representation in the filesystem).  The object returned is owned by the caller, which must store it or call Tcl_DecrRefCount to ensure memory is freed.  This function is of little practical use, and  <b>Tcl_FSGetNormalizedPath</b> or <b>Tcl_GetNativePath</b> are usually better functions to use for most purposes.<div class="spacer">
</div>
<b>Tcl_FSGetTranslatedStringPath</b> does the same as  <b>Tcl_FSGetTranslatedPath</b>, but returns a character string or NULL. The string returned is dynamically allocated and owned by the caller, which must store it or call  <b>ckfree</b> to ensure it is freed.  Again,  <b>Tcl_FSGetNormalizedPath</b> or <b>Tcl_GetNativePath</b> are usually better functions to use for most purposes.<div class="spacer">
</div>
<b>Tcl_FSNewNativePath</b> performs something like the reverse of the usual obj-&gt;path-&gt;nativerep conversions.  If some code retrieves a path in native form (from, e.g.  <b>readlink</b> or a native dialog), and that path is to be used at the Tcl level, then calling this function is an efficient way of creating the appropriate path object type.<div class="spacer">
</div>
The resulting object is a pure &#8220;path&#8221; object, which will only receive a UTF-8 string representation if that is required by some Tcl code.<div class="spacer">
</div>
<b>Tcl_FSGetNativePath</b> is for use by the Win/Unix native filesystems, so that they can easily retrieve the native (char* or TCHAR*) representation of a path.  This function is a convenience wrapper around  <b>Tcl_FSGetInternalRep</b>, and assumes the native representation is string-based.  It may be desirable in the future to have non-string-based native representations (for example, on MacOSX, a representation using a fileSpec of FSRef structure would probably be more efficient).  On Windows a full Unicode representation would allow for paths of unlimited length.  Currently the representation is simply a character string which may contain either the relative path or a complete, absolute normalized path in the native encoding (complex conditions dictate which of these will be provided, so neither can be relied upon, unless the path is known to be absolute).  If you need a native path which must be absolute, then you should ask for the native version of a normalized path.  If for some reason a non-absolute, non-normalized version of the path is needed, that must be constructed separately (e.g. using  <b>Tcl_FSGetTranslatedPath</b>).<div class="spacer">
</div>
The native representation is cached so that repeated calls to this function will not require additional conversions.  The return value is owned by Tcl and has a lifetime equivalent to that of the  <i>pathPtr</i> passed in (unless that is a relative path, in which case the native representation may be freed any time the cwd changes).<div class="spacer">
</div>
<b>Tcl_FSFileSystemInfo</b> returns a list of two elements.  The first element is the name of the filesystem (e.g. &#8220;native&#8221;, &#8220;vfs&#8221;, &#8220;zip&#8221;, or &#8220;prowrap&#8221;, perhaps), and the second is the particular type of the given path within that filesystem (which is filesystem dependent).  The second element may be empty if the filesystem does not provide a further categorization of files.<div class="spacer">
</div>
A valid list object is returned, unless the path object is not recognized, when NULL will be returned.<div class="spacer">
</div>
<b>Tcl_FSGetFileSystemForPath</b> returns the a pointer to the  <b>Tcl_Filesystem</b> which accepts this path as valid.<div class="spacer">
</div>
If no filesystem will accept the path, NULL is returned.<div class="spacer">
</div>
<b>Tcl_FSGetPathType</b> determines whether the given path is relative to the current directory, relative to the current volume, or absolute.<div class="spacer">
</div>
It returns one of <b>TCL_PATH_ABSOLUTE</b>, <b>TCL_PATH_RELATIVE</b>, or  <b>TCL_PATH_VOLUME_RELATIVE</b><div class="spacer">
</div>
<b>Tcl_AllocStatBuf</b> allocates a <i>Tcl_StatBuf</i> on the system heap (which may be deallocated by being passed to  <b>ckfree</b>.)  This allows extensions to invoke  <b>Tcl_FSStat</b> and <b>Tcl_FSLStat</b> without being dependent on the size of the buffer.  That in turn depends on the flags used to build Tcl.</div>
</div>
<div class="section">
<h1>THE VIRTUAL FILESYSTEM API</h1> A filesystem provides a  <b>Tcl_Filesystem</b> structure that contains pointers to functions that implement the various operations on a filesystem; these operations are invoked as needed by the generic layer, which generally occurs through the functions listed above.<div class="spacer">
</div>
The <b>Tcl_Filesystem</b> structures are manipulated using the following methods.<div class="spacer">
</div>
<b>Tcl_FSRegister</b> takes a pointer to a filesystem structure and an optional piece of data to associated with that filesystem.  On calling this function, Tcl will attach the filesystem to the list of known filesystems, and it will become fully functional immediately.  Tcl does not check if the same filesystem is registered multiple times (and in general that is not a good thing to do).   <b>TCL_OK</b> will be returned.<div class="spacer">
</div>
<b>Tcl_FSUnregister</b> removes the given filesystem structure from the list of known filesystems, if it is known, and returns  <b>TCL_OK</b>.  If the filesystem is not currently registered,  <b>TCL_ERROR</b> is returned.<div class="spacer">
</div>
<b>Tcl_FSData</b> will return the ClientData associated with the given filesystem, if that filesystem is registered.  Otherwise it will return NULL.<div class="spacer">
</div>
<b>Tcl_FSMountsChanged</b> is used to inform the Tcl's core that the set of mount points for the given (already registered) filesystem have changed, and that cached file representations may therefore no longer be correct.<div class="subsection">
<h2>THE TCL_FILESYSTEM STRUCTURE</h2> The  <b>Tcl_Filesystem</b> structure contains the following fields:<div style="margin-left: 5.00ex;">
<br/>
typedef struct Tcl_Filesystem {<br/>
    const char *<i>typeName</i>;<br/>
    int <i>structureLength</i>;<br/>
    Tcl_FSVersion <i>version</i>;<br/>
    Tcl_FSPathInFilesystemProc *<i>pathInFilesystemProc</i>;<br/>
    Tcl_FSDupInternalRepProc *<i>dupInternalRepProc</i>;<br/>
    Tcl_FSFreeInternalRepProc *<i>freeInternalRepProc</i>;<br/>
    Tcl_FSInternalToNormalizedProc *<i>internalToNormalizedProc</i>;<br/>
    Tcl_FSCreateInternalRepProc *<i>createInternalRepProc</i>;<br/>
    Tcl_FSNormalizePathProc *<i>normalizePathProc</i>;<br/>
    Tcl_FSFilesystemPathTypeProc *<i>filesystemPathTypeProc</i>;<br/>
    Tcl_FSFilesystemSeparatorProc *<i>filesystemSeparatorProc</i>;<br/>
    Tcl_FSStatProc *<i>statProc</i>;<br/>
    Tcl_FSAccessProc *<i>accessProc</i>;<br/>
    Tcl_FSOpenFileChannelProc *<i>openFileChannelProc</i>;<br/>
    Tcl_FSMatchInDirectoryProc *<i>matchInDirectoryProc</i>;<br/>
    Tcl_FSUtimeProc *<i>utimeProc</i>;<br/>
    Tcl_FSLinkProc *<i>linkProc</i>;<br/>
    Tcl_FSListVolumesProc *<i>listVolumesProc</i>;<br/>
    Tcl_FSFileAttrStringsProc *<i>fileAttrStringsProc</i>;<br/>
    Tcl_FSFileAttrsGetProc *<i>fileAttrsGetProc</i>;<br/>
    Tcl_FSFileAttrsSetProc *<i>fileAttrsSetProc</i>;<br/>
    Tcl_FSCreateDirectoryProc *<i>createDirectoryProc</i>;<br/>
    Tcl_FSRemoveDirectoryProc *<i>removeDirectoryProc</i>;<br/>
    Tcl_FSDeleteFileProc *<i>deleteFileProc</i>;<br/>
    Tcl_FSCopyFileProc *<i>copyFileProc</i>;<br/>
    Tcl_FSRenameFileProc *<i>renameFileProc</i>;<br/>
    Tcl_FSCopyDirectoryProc *<i>copyDirectoryProc</i>;<br/>
    Tcl_FSLstatProc *<i>lstatProc</i>;<br/>
    Tcl_FSLoadFileProc *<i>loadFileProc</i>;<br/>
    Tcl_FSGetCwdProc *<i>getCwdProc</i>;<br/>
    Tcl_FSChdirProc *<i>chdirProc</i>;<br/>
} Tcl_Filesystem;<br/>
</div>
<div class="spacer">
</div>
Except for the first three fields in this structure which contain simple data elements, all entries contain addresses of functions called by the generic filesystem layer to perform the complete range of filesystem related actions.<div class="spacer">
</div>
The many functions in this structure are broken down into three categories: infrastructure functions (almost all of which must be implemented), operational functions (which must be implemented if a complete filesystem is provided), and efficiency functions (which need only be implemented if they can be done so efficiently, or if they have side-effects which are required by the filesystem; Tcl has less efficient emulations it can fall back on).  It is important to note that, in the current version of Tcl, most of these fallbacks are only used to handle commands initiated in Tcl, not in C. What this means is, that if a  <b>file rename</b> command is issued in Tcl, and the relevant filesystem(s) do not implement their  <i>Tcl_FSRenameFileProc</i>, Tcl's core will instead fallback on a combination of other filesystem functions (it will use  <i>Tcl_FSCopyFileProc</i> followed by  <i>Tcl_FSDeleteFileProc</i>, and if <i>Tcl_FSCopyFileProc</i> is not implemented there is a further fallback).  However, if a  <i>Tcl_FSRenameFileProc</i> command is issued at the C level, no such fallbacks occur.  This is true except for the last four entries in the filesystem table ( <b>lstat</b>, <b>load</b>, <b>getcwd</b> and <b>chdir</b>) for which fallbacks do in fact occur at the C level.<div class="spacer">
</div>
Any functions which take path names in Tcl_Obj form take those names in UTF-8 form.  The filesystem infrastructure API is designed to support efficient, cached conversion of these UTF-8 paths to other native representations.</div>
<div class="subsection">
<h2>EXAMPLE FILESYSTEM DEFINITION</h2> Here is the filesystem lookup table used by the &#8220;vfs&#8221; extension which allows filesystem actions to be implemented in Tcl.<div style="margin-left: 5.00ex;">
<br/>
static Tcl_Filesystem vfsFilesystem = {<br/>
    &quot;tclvfs&quot;,<br/>
    sizeof(Tcl_Filesystem),<br/>
    TCL_FILESYSTEM_VERSION_1,<br/>
    &amp;VfsPathInFilesystem,<br/>
    &amp;VfsDupInternalRep,<br/>
    &amp;VfsFreeInternalRep,<br/>
    /* No internal to normalized, since we don't create<br/>
     * any pure 'internal' Tcl_Obj path representations */<br/>
    NULL,<br/>
    /* No create native rep function, since we don't use<br/>
     * it and don't choose to support uses of<br/>
     * Tcl_FSNewNativePath */<br/>
    NULL,<br/>
    /* Normalize path isn't needed - we assume paths only<br/>
     * have one representation */<br/>
    NULL,<br/>
    &amp;VfsFilesystemPathType,<br/>
    &amp;VfsFilesystemSeparator,<br/>
    &amp;VfsStat,<br/>
    &amp;VfsAccess,<br/>
    &amp;VfsOpenFileChannel,<br/>
    &amp;VfsMatchInDirectory,<br/>
    &amp;VfsUtime,<br/>
    /* We choose not to support symbolic links inside our<br/>
     * VFS's */<br/>
    NULL,<br/>
    &amp;VfsListVolumes,<br/>
    &amp;VfsFileAttrStrings,<br/>
    &amp;VfsFileAttrsGet,<br/>
    &amp;VfsFileAttrsSet,<br/>
    &amp;VfsCreateDirectory,<br/>
    &amp;VfsRemoveDirectory,<br/>
    &amp;VfsDeleteFile,<br/>
    /* No copy file; use the core fallback mechanism */<br/>
    NULL,<br/>
    /* No rename file; use the core fallback mechanism */<br/>
    NULL,<br/>
    /* No copy directory; use the core fallback mechanism */<br/>
    NULL,<br/>
    /* Core will use stat for lstat */<br/>
    NULL,<br/>
    /* No load; use the core fallback mechanism */<br/>
    NULL,<br/>
    /* We don't need a getcwd or chdir; the core's own<br/>
     * internal value is suitable */<br/>
    NULL,<br/>
    NULL<br/>
};<br/>
</div>
</div>
</div>
<div class="section">
<h1>FILESYSTEM INFRASTRUCTURE</h1> These fields contain basic information about the filesystem structure and addresses of functions which are used to associate a particular filesystem with a file path, and deal with the internal handling of path representations, for example copying and freeing such representations.<div class="subsection">
<h2>TYPENAME</h2> The  <i>typeName</i> field contains a null-terminated string that identifies the type of the filesystem implemented, e.g. &#8220;native&#8221;, &#8220;zip&#8221; or &#8220;vfs&#8221;.</div>
<div class="subsection">
<h2>STRUCTURE LENGTH</h2> The  <i>structureLength</i> field is generally implemented as  <i>sizeof(Tcl_Filesystem)</i>, and is there to allow easier binary backwards compatibility if the size of the structure changes in a future Tcl release.</div>
<div class="subsection">
<h2>VERSION</h2> The  <i>version</i> field should be set to <b>TCL_FILESYSTEM_VERSION_1</b>.</div>
<div class="subsection">
<h2>PATHINFILESYSTEMPROC</h2> The  <i>pathInFilesystemProc</i> field contains the address of a function which is called to determine whether a given path object belongs to this filesystem or not.  Tcl will only call the rest of the filesystem functions with a path for which this function has returned  <b>TCL_OK</b>. If the path does not belong, -1 should be returned (the behaviour of Tcl for any other return value is not defined).  If  <b>TCL_OK</b> is returned, then the optional  <i>clientDataPtr</i> output parameter can be used to return an internal (filesystem specific) representation of the path, which will be cached inside the path object, and may be retrieved efficiently by the other filesystem functions.  Tcl will simultaneously cache the fact that this path belongs to this filesystem.  Such caches are invalidated when filesystem structures are added or removed from Tcl's internal list of known filesystems.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSPathInFilesystemProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        ClientData *<i>clientDataPtr</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>DUPINTERNALREPPROC</h2> This function makes a copy of a path's internal representation, and is called when Tcl needs to duplicate a path object.  If NULL, Tcl will simply not copy the internal representation, which may then need to be regenerated later.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef ClientData Tcl_FSDupInternalRepProc(<br/>
        ClientData <i>clientData</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>FREEINTERNALREPPROC</h2> Free the internal representation.  This must be implemented if internal representations need freeing (i.e. if some memory is allocated when an internal representation is generated), but may otherwise be NULL.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef void Tcl_FSFreeInternalRepProc(<br/>
        ClientData <i>clientData</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>INTERNALTONORMALIZEDPROC</h2> Function to convert internal representation to a normalized path.  Only required if the filesystem creates pure path objects with no string/path representation.  The return value is a Tcl object whose string representation is the normalized path.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(<br/>
        ClientData <i>clientData</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>CREATEINTERNALREPPROC</h2> Function to take a path object, and calculate an internal representation for it, and store that native representation in the object.  May be NULL if paths have no internal representation, or if the  <i>Tcl_FSPathInFilesystemProc</i> for this filesystem always immediately creates an internal representation for paths it accepts.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef ClientData Tcl_FSCreateInternalRepProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>NORMALIZEPATHPROC</h2> Function to normalize a path.  Should be implemented for all filesystems which can have multiple string representations for the same path object.  In Tcl, every &#8220;path&#8221; must have a single unique &#8220;normalized&#8221; string representation.  Depending on the filesystem, there may be more than one unnormalized string representation which refers to that path (e.g. a relative path, a path with different character case if the filesystem is case insensitive, a path contain a reference to a home directory such as &#8220;~&#8221;, a path containing symbolic links, etc).  If the very last component in the path is a symbolic link, it should not be converted into the object it points to (but its case or other aspects should be made unique).  All other path components should be converted from symbolic links.  This one exception is required to agree with Tcl's semantics with  <b>file</b>  <b>delete</b>, <b>file rename</b>, <b>file copy</b> operating on symbolic links. This function may be called with  <i>nextCheckpoint</i> either at the beginning of the path (i.e. zero), at the end of the path, or at any intermediate file separator in the path.  It will never point to any other arbitrary position in the path. In the last of the three valid cases, the implementation can assume that the path up to and including the file separator is known and normalized.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSNormalizePathProc(<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        int <i>nextCheckpoint</i>);<br/>
</div>
</div>
</div>
<div class="section">
<h1>FILESYSTEM OPERATIONS</h1> The fields in this section of the structure contain addresses of functions which are called to carry out the basic filesystem operations.  A filesystem which expects to be used with the complete standard Tcl command set must implement all of these.  If some of them are not implemented, then certain Tcl commands may fail when operating on paths within that filesystem.  However, in some instances this may be desirable (for example, a read-only filesystem should not implement the last four functions, and a filesystem which does not support symbolic links need not implement the  <b>readlink</b> function, etc.  The Tcl core expects filesystems to behave in this way).<div class="subsection">
<h2>FILESYSTEMPATHTYPEPROC</h2> Function to determine the type of a path in this filesystem.  May be NULL, in which case no type information will be available to users of the filesystem.  The &#8220;type&#8221; is used only for informational purposes, and should be returned as the string representation of the Tcl_Obj which is returned.  A typical return value might be &#8220;networked&#8221;, &#8220;zip&#8221; or &#8220;ftp&#8221;. The Tcl_Obj result is owned by the filesystem and so Tcl will increment the refCount of that object if it wishes to retain a reference to it.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>FILESYSTEMSEPARATORPROC</h2> Function to return the separator character(s) for this filesystem. This need only be implemented if the filesystem wishes to use a different separator than the standard string &#8220;/&#8221;. Amongst other uses, it is returned by the  <b>file separator</b> command.  The return value should be an object with refCount of zero.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>STATPROC</h2> Function to process a  <b>Tcl_FSStat</b> call.  Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g.  <b>file atime</b>, <b>file isdirectory</b>, <b>file size</b>,  <b>glob</b>).<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSStatProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_StatBuf *<i>statPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The <b>Tcl_FSStatProc</b> fills the stat structure <i>statPtr</i> with information about the specified file.  You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file.  The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time.<div class="spacer">
</div>
If the file represented by <i>pathPtr</i> exists, the  <b>Tcl_FSStatProc</b> returns 0 and the stat structure is filled with data.  Otherwise, -1 is returned, and no stat info is given.</div>
<div class="subsection">
<h2>ACCESSPROC</h2> Function to process a  <b>Tcl_FSAccess</b> call.  Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g.  <b>file exists</b>, <b>file readable</b>).<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSAccessProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        int <i>mode</i>);<br/>
</div>
<div class="spacer">
</div>
The <b>Tcl_FSAccessProc</b> checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is in  <i>pathPtr</i>.  If the pathname refers to a symbolic link, then the permissions of the file referred by this symbolic link should be tested.<div class="spacer">
</div>
On success (all requested permissions granted), zero is returned.  On error (at least one bit in mode asked for a permission that is denied, or some other  error occurred), -1 is returned.</div>
<div class="subsection">
<h2>OPENFILECHANNELPROC</h2> Function to process a  <b>Tcl_FSOpenFileChannel</b> call.  Must be implemented for any reasonable filesystem, since any operations which require open or accessing a file's contents will use it (e.g.  <b>open</b>, <b>encoding</b>, and many Tk commands).<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Channel Tcl_FSOpenFileChannelProc(<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        int <i>mode</i>,<br/>
        int <i>permissions</i>);<br/>
</div>
<div class="spacer">
</div>
The <b>Tcl_FSOpenFileChannelProc</b> opens a file specified by  <i>pathPtr</i> and returns a channel handle that can be used to perform input and output on the file.  This API is modeled after the  <b>fopen</b> procedure of the Unix standard I/O library.  The syntax and meaning of all arguments is similar to those given in the Tcl  <b>open</b> command when opening a file, where the  <i>mode</i> argument is a combination of the POSIX flags O_RDONLY, O_WRONLY, etc.  If an error occurs while opening the channel, the  <b>Tcl_FSOpenFileChannelProc</b> returns NULL and records a POSIX error code that can be retrieved with  <b>Tcl_GetErrno</b>. In addition, if  <i>interp</i> is non-NULL, the  <b>Tcl_FSOpenFileChannelProc</b> leaves an error message in <i>interp</i>'s result after any error.<div class="spacer">
</div>
The newly created channel must not registered in the supplied interpreter; that task is up to the caller of  <b>Tcl_FSOpenFileChannel</b> (if necessary). If one of the standard channels,  <b>stdin, stdout</b> or <b>stderr</b> was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.</div>
<div class="subsection">
<h2>MATCHINDIRECTORYPROC</h2> Function to process a  <b>Tcl_FSMatchInDirectory</b> call.  If not implemented, then glob and recursive copy functionality will be lacking in the filesystem (and this may impact commands like  <b>encoding names</b> which use glob functionality internally).<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSMatchInDirectoryProc(<br/>
        Tcl_Interp* <i>interp</i>,<br/>
        Tcl_Obj *<i>resultPtr</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        const char *<i>pattern</i>,<br/>
        Tcl_GlobTypeData *<i>types</i>);<br/>
</div>
<div class="spacer">
</div>
The function should return all files or directories (or other filesystem objects) which match the given pattern and accord with the  <i>types</i> specification given.  There are two ways in which this function may be called.  If  <i>pattern</i> is NULL, then <i>pathPtr</i> is a full path specification of a single file or directory which should be checked for existence and correct type.  Otherwise,  <i>pathPtr</i> is a directory, the contents of which the function should search for files or directories which have the correct type.  In either case,  <i>pathPtr</i> can be assumed to be both non-NULL and non-empty.  It is not currently documented whether  <i>pathPtr</i> will have a file separator at its end of not, so code should be flexible to both possibilities.<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the matching process.  Error messages are placed in  <i>interp</i>, unless <i>interp</i> in NULL in which case no error message need be generated; on a  <b>TCL_OK</b> result, results should be added to the  <i>resultPtr</i> object given (which can be assumed to be a valid unshared Tcl list).  The matches added to  <i>resultPtr</i> should include any path prefix given in <i>pathPtr</i> (this usually means they will be absolute path specifications). Note that if no matches are found, that simply leads to an empty result; errors are only signaled for actual file or filesystem problems which may occur during the matching process.<div class="spacer">
</div>
The <b>Tcl_GlobTypeData</b> structure passed in the <i>types</i> parameter contains the following fields:<div style="margin-left: 5.00ex;">
<br/>
typedef struct Tcl_GlobTypeData {<br/>
        /* Corresponds to bcdpfls as in 'find -t' */<br/>
        int <i>type</i>;<br/>
        /* Corresponds to file permissions */<br/>
        int <i>perm</i>;<br/>
        /* Acceptable mac type */<br/>
        Tcl_Obj *<i>macType</i>;<br/>
        /* Acceptable mac creator */<br/>
        Tcl_Obj *<i>macCreator</i>;<br/>
} Tcl_GlobTypeData;<br/>
</div>
<div class="spacer">
</div>
There are two specific cases which it is important to handle correctly, both when  <i>types</i> is non-NULL. The two cases are when <i>types-&gt;types</i>  <i>&amp; TCL_GLOB_TYPE_DIR</i> or <i>types-&gt;types &amp; TCL_GLOB_TYPE_MOUNT</i> are true (and in particular when the other flags are false).  In the first of these cases, the function must list the contained directories.  Tcl uses this to implement recursive globbing, so it is critical that filesystems implement directory matching correctly.  In the second of these cases, with  <b>TCL_GLOB_TYPE_MOUNT</b>, the filesystem must list the mount points which lie within the given  <i>pathPtr</i> (and in this case, <i>pathPtr</i> need not lie within the same filesystem - different to all other cases in which this function is called).  Support for this is critical if Tcl is to have seamless transitions between from one filesystem to another.</div>
<div class="subsection">
<h2>UTIMEPROC</h2> Function to process a  <b>Tcl_FSUtime</b> call.  Required to allow setting (not reading) of times with  <b>file mtime</b>, <b>file atime</b> and the open-r/open-w/fcopy implementation of  <b>file copy</b>.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSUtimeProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        struct utimbuf *<i>tval</i>);<br/>
</div>
<div class="spacer">
</div>
The access and modification times of the file specified by <i>pathPtr</i> should be changed to the values given in the  <i>tval</i> structure.<div class="spacer">
</div>
The return value should be 0 on success and -1 on an error, as with the system  <b>utime</b>.</div>
<div class="subsection">
<h2>LINKPROC</h2> Function to process a  <b>Tcl_FSLink</b> call.  Should be implemented only if the filesystem supports links, and may otherwise be NULL.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSLinkProc(<br/>
        Tcl_Obj *<i>linkNamePtr</i>,<br/>
        Tcl_Obj *<i>toPtr</i>,<br/>
        int <i>linkAction</i>);<br/>
</div>
<div class="spacer">
</div>
If <i>toPtr</i> is NULL, the function is being asked to read the contents of a link.  The result is a Tcl_Obj specifying the contents of the link given by  <i>linkNamePtr</i>, or NULL if the link could not be read.  The result is owned by the caller (and should therefore have its ref count incremented before being returned).  Any callers should call Tcl_DecrRefCount on this result when it is no longer needed. If  <i>toPtr</i> is not NULL, the function should attempt to create a link. The result in this case should be  <i>toPtr</i> if the link was successful and NULL otherwise.  In this case the result is not owned by the caller (i.e. no ref count manipulation on either end is needed). See the documentation for  <b>Tcl_FSLink</b> for the correct interpretation of the  <i>linkAction</i> flags.</div>
<div class="subsection">
<h2>LISTVOLUMESPROC</h2> Function to list any filesystem volumes added by this filesystem. Should be implemented only if the filesystem adds volumes at the head of the filesystem, so that they can be returned by  <b>file volumes</b>.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);<br/>
</div>
<div class="spacer">
</div>
The result should be a list of volumes added by this filesystem, or NULL (or an empty list) if no volumes are provided.  The result object is considered to be owned by the filesystem (not by Tcl's core), but should be given a refCount for Tcl.  Tcl will use the contents of the list and then decrement that refCount.  This allows filesystems to choose whether they actually want to retain a &#8220;master list&#8221; of volumes or not (if not, they generate the list on the fly and pass it to Tcl with a refCount of 1 and then forget about the list, if yes, then they simply increment the refCount of their master list and pass it to Tcl which will copy the contents and then decrement the count back to where it was).<div class="spacer">
</div>
Therefore, Tcl considers return values from this proc to be read-only.</div>
<div class="subsection">
<h2>FILEATTRSTRINGSPROC</h2> Function to list all attribute strings which are valid for this filesystem.  If not implemented the filesystem will not support the  <b>file attributes</b> command.  This allows arbitrary additional information to be attached to files in the filesystem.  If it is not implemented, there is no need to implement the  <b>get</b> and <b>set</b> methods.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef const char** Tcl_FSFileAttrStringsProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_Obj** <i>objPtrRef</i>);<br/>
</div>
<div class="spacer">
</div>
The called function may either return an array of strings, or may instead return NULL and place a Tcl list into the given  <i>objPtrRef</i>.  Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count.  Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it returns an object with a reference count of at least one.</div>
<div class="subsection">
<h2>FILEATTRSGETPROC</h2> Function to process a  <b>Tcl_FSFileAttrsGet</b> call, used by <b>file</b>  <b>attributes</b>.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSFileAttrsGetProc(<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        int <i>index</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_Obj **<i>objPtrRef</i>);<br/>
</div>
<div class="spacer">
</div>
Returns a standard Tcl return code.  The attribute value retrieved, which corresponds to the  <i>index</i>'th element in the list returned by the  <b>Tcl_FSFileAttrStringsProc</b>, is a Tcl_Obj placed in <i>objPtrRef</i> (if  <b>TCL_OK</b> was returned) and is likely to have a reference count of zero.  Either way we must either store it somewhere (e.g. the Tcl result), or Incr/Decr its reference count to ensure it is properly freed.</div>
<div class="subsection">
<h2>FILEATTRSSETPROC</h2> Function to process a  <b>Tcl_FSFileAttrsSet</b> call, used by <b>file</b>  <b>attributes</b>.  If the filesystem is read-only, there is no need to implement this.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSFileAttrsSetProc(<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        int <i>index</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_Obj *<i>objPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The attribute value of the <i>index</i>'th element in the list returned by the Tcl_FSFileAttrStringsProc should be set to the  <i>objPtr</i> given.</div>
<div class="subsection">
<h2>CREATEDIRECTORYPROC</h2> Function to process a  <b>Tcl_FSCreateDirectory</b> call.  Should be implemented unless the FS is read-only.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSCreateDirectoryProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the process.  If successful, a new directory should have been added to the filesystem in the location specified by  <i>pathPtr</i>.</div>
<div class="subsection">
<h2>REMOVEDIRECTORYPROC</h2> Function to process a  <b>Tcl_FSRemoveDirectory</b> call.  Should be implemented unless the FS is read-only.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSRemoveDirectoryProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        int <i>recursive</i>,<br/>
        Tcl_Obj **<i>errorPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the process.  If successful, the directory specified by  <i>pathPtr</i> should have been removed from the filesystem.  If the  <i>recursive</i> flag is given, then a non-empty directory should be deleted without error.  If this flag is not given, then and the directory is non-empty a POSIX &#8220;EEXIST&#8221; error should be signaled.  If an error does occur, the name of the file or directory which caused the error should be placed in  <i>errorPtr</i>.</div>
<div class="subsection">
<h2>DELETEFILEPROC</h2> Function to process a  <b>Tcl_FSDeleteFile</b> call.  Should be implemented unless the FS is read-only.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSDeleteFileProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the process.  If successful, the file specified by  <i>pathPtr</i> should have been removed from the filesystem.  Note that, if the filesystem supports symbolic links, Tcl will always call this function and not Tcl_FSRemoveDirectoryProc when needed to delete them (even if they are symbolic links to directories).</div>
</div>
<div class="section">
<h1>FILESYSTEM EFFICIENCY</h1> These functions need not be implemented for a particular filesystem because the core has a fallback implementation available. See each individual description for the consequences of leaving the field NULL.<div class="subsection">
<h2>LSTATPROC</h2> Function to process a  <b>Tcl_FSLstat</b> call.  If not implemented, Tcl will attempt to use the  <i>statProc</i> defined above instead.  Therefore it need only be implemented if a filesystem can differentiate between  <b>stat</b> and <b>lstat</b> calls.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSLstatProc(<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_StatBuf *<i>statPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The behavior of this function is very similar to that of the  <b>Tcl_FSStatProc</b> defined above, except that if it is applied to a symbolic link, it returns information about the link, not about the target file.</div>
<div class="subsection">
<h2>COPYFILEPROC</h2> Function to process a  <b>Tcl_FSCopyFile</b> call.  If not implemented Tcl will fall back on  <b>open</b>-r, <b>open</b>-w and <b>fcopy</b> as a copying mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSCopyFileProc(<br/>
        Tcl_Obj *<i>srcPathPtr</i>,<br/>
        Tcl_Obj *<i>destPathPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the copying process.  Note that,  <i>destPathPtr</i> is the name of the file which should become the copy of  <i>srcPathPtr</i>. It is never the name of a directory into which  <i>srcPathPtr</i> could be copied (i.e. the function is much simpler than the Tcl level  <b>file</b>  <b>copy</b> subcommand).  Note that, if the filesystem supports symbolic links, Tcl will always call this function and not  <i>copyDirectoryProc</i> when needed to copy them (even if they are symbolic links to directories).  Finally, if the filesystem determines it cannot support the  <b>file copy</b> action, calling  <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will tell Tcl to use its standard fallback mechanisms.</div>
<div class="subsection">
<h2>RENAMEFILEPROC</h2> Function to process a  <b>Tcl_FSRenameFile</b> call.  If not implemented, Tcl will fall back on a copy and delete mechanism.  Therefore it need only be implemented if the filesystem can perform that action more efficiently.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSRenameFileProc(<br/>
        Tcl_Obj *<i>srcPathPtr</i>,<br/>
        Tcl_Obj *<i>destPathPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the renaming process.  If the filesystem determines it cannot support the  <b>file rename</b> action, calling  <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will tell Tcl to use its standard fallback mechanisms.</div>
<div class="subsection">
<h2>COPYDIRECTORYPROC</h2> Function to process a  <b>Tcl_FSCopyDirectory</b> call.  If not implemented, Tcl will fall back on a recursive  <b>file mkdir</b>, <b>file copy</b> mechanism.  Therefore it need only be implemented if the filesystem can perform that action more efficiently.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSCopyDirectoryProc(<br/>
        Tcl_Obj *<i>srcPathPtr</i>,<br/>
        Tcl_Obj *<i>destPathPtr</i>,<br/>
        Tcl_Obj **<i>errorPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The return value is a standard Tcl result indicating whether an error occurred in the copying process.  If an error does occur, the name of the file or directory which caused the error should be placed in  <i>errorPtr</i>. Note that, <i>destPathPtr</i> is the name of the directory-name which should become the mirror-image of  <i>srcPathPtr</i>. It is not the name of a directory into which  <i>srcPathPtr</i> should be copied (i.e. the function is much simpler than the Tcl level  <b>file copy</b> subcommand).  Finally, if the filesystem determines it cannot support the directory copy action, calling  <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will tell Tcl to use its standard fallback mechanisms.</div>
<div class="subsection">
<h2>LOADFILEPROC</h2> Function to process a  <b>Tcl_FSLoadFile</b> call.  If not implemented, Tcl will fall back on a copy to native-temp followed by a  <b>Tcl_FSLoadFile</b> on that temporary copy.  Therefore it need only be implemented if the filesystem can load code directly, or it can be implemented simply to return  <b>TCL_ERROR</b> to disable load functionality in this filesystem entirely.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSLoadFileProc(<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        Tcl_Obj *<i>pathPtr</i>,<br/>
        Tcl_LoadHandle *<i>handlePtr</i>,<br/>
        Tcl_FSUnloadFileProc *<i>unloadProcPtr</i>);<br/>
</div>
<div class="spacer">
</div>
Returns a standard Tcl completion code.  If an error occurs, an error message is left in the  <i>interp</i>'s result.  The function dynamically loads a binary code file into memory.  On a successful load, the  <i>handlePtr</i> should be filled with a token for the dynamically loaded file, and the  <i>unloadProcPtr</i> should be filled in with the address of a procedure. The unload procedure will be called with the given  <b>Tcl_LoadHandle</b> as its only parameter when Tcl needs to unload the file.  For example, for the native filesystem, the  <b>Tcl_LoadHandle</b> returned is currently a token which can be used in the private  <b>TclpFindSymbol</b> to access functions in the new code.  Each filesystem is free to define the  <b>Tcl_LoadHandle</b> as it requires.  Finally, if the filesystem determines it cannot support the file load action, calling  <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will tell Tcl to use its standard fallback mechanisms.</div>
<div class="subsection">
<h2>UNLOADFILEPROC</h2> Function to unload a previously successfully loaded file.  If load was implemented, then this should also be implemented, if there is any cleanup action required.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef void Tcl_FSUnloadFileProc(<br/>
        Tcl_LoadHandle <i>loadHandle</i>);<br/>
</div>
</div>
<div class="subsection">
<h2>GETCWDPROC</h2> Function to process a  <b>Tcl_FSGetCwd</b> call.  Most filesystems need not implement this.  It will usually only be called once, if  <b>getcwd</b> is called before  <b>chdir</b>.  May be NULL.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_Obj* Tcl_FSGetCwdProc(<br/>
        Tcl_Interp *<i>interp</i>);<br/>
</div>
<div class="spacer">
</div>
If the filesystem supports a native notion of a current working directory (which might perhaps change independent of Tcl), this function should return that cwd as the result, or NULL if the current directory could not be determined (e.g. the user does not have appropriate permissions on the cwd directory).  If NULL is returned, an error message is left in the  <i>interp</i>'s result.</div>
<div class="subsection">
<h2>CHDIRPROC</h2> Function to process a  <b>Tcl_FSChdir</b> call.  If filesystems do not implement this, it will be emulated by a series of directory access checks.  Otherwise, virtual filesystems which do implement it need only respond with a positive return result if the  <i>pathPtr</i> is a valid, accessible directory in their filesystem.  They need not remember the result, since that will be automatically remembered for use by  <b>Tcl_FSGetCwd</b>. Real filesystems should carry out the correct action (i.e. call the correct system  <b>chdir</b> API).<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_FSChdirProc(<br/>
        Tcl_Obj *<i>pathPtr</i>);<br/>
</div>
<div class="spacer">
</div>
The <b>Tcl_FSChdirProc</b> changes the applications current working directory to the value specified in  <i>pathPtr</i>. The function returns -1 on error or 0 on success.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> cd(n), file(n), load(n), open(n), pwd(n), unload(n)</div>
<div class="section">
<h1>KEYWORDS</h1> stat, access, filesystem, vfs, virtual</div>
<table class="foot">
<tr>
<td class="foot-date">
8.4</td>
<td class="foot-os">
Tcl</td>
</tr>
</table>
</div>
</body>
</html>

