<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
Mono(Mono 3.0)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Mono(Mono 3.0)</td>
<td class="head-vol">
</td>
<td class="head-rtitle">
Mono(Mono 3.0)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> mono - Mono's ECMA-CLI native code generator (Just-in-Time and Ahead-of-Time)</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>mono [options] file [arguments...]</b><div class="spacer">
</div>
<b>mono-sgen [options] file [arguments...]</b></div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>mono</i> is a runtime implementation of the ECMA Common Language Infrastructure.  This can be used to run ECMA and .NET applications.<div class="spacer">
</div>
The runtime contains a native code generator that transforms the Common Intermediate Language into native code.<div class="spacer">
</div>
The code generator can operate in two modes: just in time compilation (JIT) or ahead of time compilation (AOT).  Since code can be dynamically loaded, the runtime environment and the JIT are always present, even if code is compiled ahead of time.<div class="spacer">
</div>
The runtime loads the specified <i>file</i> and optionally passes the <i>arguments</i> to it.  The <i>file</i> is an ECMA assembly.  They typically have a .exe or .dll extension.<div class="spacer">
</div>
The runtime provides a number of configuration options for running applications, for developing and debugging, and for testing and debugging the runtime itself.<div class="spacer">
</div>
The <i>mono</i> command uses the Boehm conservative garbage collector while the  <i>mono-sgen</i> command uses a moving and generational garbage collector.</div>
<div class="section">
<h1>PORTABILITY</h1> On Unix-based systems, Mono provides a mechanism to emulate the Windows-style file access, this includes providing a case insensitive view of the file system, directory separator mapping (from \ to /) and stripping the drive letters.<div class="spacer">
</div>
This functionality is enabled by setting the <b>MONO_IOMAP</b> environment variable to one of <b>all, drive</b> and <b>case.</b><div class="spacer">
</div>
See the description for <b>MONO_IOMAP</b> in the environment variables section for more details.</div>
<div class="section">
<h1>RUNTIME OPTIONS</h1> The following options are available:<dl>
<dt>
<b>--aot</b>, <b>--aot[=options]</b></dt>
<dd>
This option is used to precompile the CIL code in the specified assembly to native code.  The generated code is stored in a file with the extension .so.  This file will be automatically picked up by the runtime when the assembly is executed. Ahead-of-Time compilation is most useful if you use it in combination with the -O=all,-shared flag which enables all of the optimizations in the code generator to be performed.  Some of those optimizations are not practical for Just-in-Time compilation since they might be very time consuming. Unlike the .NET Framework, Ahead-of-Time compilation will not generate domain independent code: it generates the same code that the Just-in-Time compiler would produce.   Since most applications use a single domain, this is fine.   If you want to optimize the generated code for use in multi-domain applications, consider using the -O=shared flag. This pre-compiles the methods, but the original assembly is still required to execute as this one contains the metadata and exception information which is not available on the generated file.  When precompiling code, you might want to compile with all optimizations (-O=all).  Pre-compiled code is position independent code. Pre compilation is just a mechanism to reduce startup time, increase code sharing across multiple mono processes and avoid just-in-time compilation program startup costs.  The original assembly must still be present, as the metadata is contained there. AOT code typically can not be moved from one computer to another (CPU-specific optimizations that are detected at runtime) so you should not try to move the pre-generated assemblies or package the pre-generated assemblies for deployment. A few options are available as a parameter to the <b>--aot</b> command line option.   The options are separated by commas, and more than one can be specified:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<i>autoreg</i></dt>
<dd>
The AOT compiler will emit a (ELF only) library initializer to automatically register the aot compiled module with the runtime.  This is only useful in static mode</dd>
</dl>
<dl>
<dt>
<i>asmonly</i></dt>
<dd>
Instructs the AOT compiler to output assembly code instead of an object file.</dd>
</dl>
<dl>
<dt>
<i>bind-to-runtime-version</i></dt>
<dd>
If specified, forces the generated AOT files to be bound to the runtime version of the compiling Mono.   This will prevent the AOT files from being consumed by a different Mono runtime. <i>full</i> This is currently an experimental feature as it is not complete. This instructs Mono to precompile code that has historically not been precompiled with AOT.</dd>
</dl>
<dl>
<dt>
<i>direct-pinvoke</i></dt>
<dd>
When this option is specified, P/Invoke methods are invoked directly instead of going through the operating system symbol lookup operation.</dd>
</dl>
<dl>
<dt>
<i>llvm-path=&lt;PREFIX&gt;</i></dt>
<dd>
Same for the llvm tools 'opt' and 'llc'.</dd>
</dl>
<dl>
<dt>
<i>mtriple=&lt;TRIPLE&gt;</i></dt>
<dd>
Use the GNU style target triple &lt;TRIPLE&gt; to determine some code generation options, i.e. --mtriple=armv7-linux-gnueabi will generate code that targets ARMv7. This is currently only supported by the ARM backend. In LLVM mode, this triple is passed on to the LLVM llc compiler.</dd>
</dl>
<dl>
<dt>
<i>nimt-trampolines=[number]</i></dt>
<dd>
When compiling in full aot mode, the IMT trampolines must be precreated in the AOT image.  You can add additional method trampolines with this argument. Defaults to 128.</dd>
</dl>
<dl>
<dt>
<i>nodebug</i></dt>
<dd>
Instructs the AOT compiler to not output any debugging information.</dd>
</dl>
<dl>
<dt>
<i>dwarfdebug</i></dt>
<dd>
Instructs the AOT compiler to emit DWARF debugging information. When used together with the nodebug option, only DWARF debugging information is emitted, but not the information that can be used at runtime.</dd>
</dl>
<dl>
<dt>
<i>nrgctx-trampolines=[number]</i></dt>
<dd>
When compiling in full aot mode, the generic sharing trampolines must be precreated in the AOT image.  You can add additional method trampolines with this argument. Defaults to 1024.</dd>
</dl>
<dl>
<dt>
<i>ntrampolines=[number]</i></dt>
<dd>
When compiling in full aot mode, the method trampolines must be precreated in the AOT image.  You can add additional method trampolines with this argument. Defaults to 1024.</dd>
</dl>
<dl>
<dt>
<i>outfile=[filename]</i></dt>
<dd>
Instructs the AOT compiler to save the output to the specified file.</dd>
</dl>
<dl>
<dt>
<i>print-skipped-methods</i></dt>
<dd>
If the AOT compiler cannot compile a method for any reason, enabling this flag will output the skipped methods to the console.</dd>
</dl>
<dl>
<dt>
<i>readonly-value=namespace.typename.fieldname=type/value</i></dt>
<dd>
Override the value of a static readonly field. Usually, during JIT compilation, the static constructor is ran eagerly, so the value of a static readonly field is known at compilation time and the compiler can do a number of optimizations based on it. During AOT, instead, the static constructor can't be ran, so this option can be used to set the value of such a field and enable the same set of optimizations. Type can be any of i1, i2, i4 for integers of the respective sizes (in bytes). Note that signed/unsigned numbers do not matter here, just the storage size. This option can be specified multiple times and it doesn't prevent the static constructor for the type defining the field to execute with the usual rules at runtime (hence possibly computing a different value for the field).<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<i>save-temps,keep-temps</i></dt>
<dd>
Instructs the AOT compiler to keep temporary files.</dd>
</dl>
<dl>
<dt>
<i>soft-debug</i></dt>
<dd>
This instructs the compiler to generate sequence point checks that allow Mono's soft debugger to debug applications even on systems where it is not possible to set breakpoints or to single step (certain hardware configurations like the cell phones and video gaming consoles).</dd>
</dl>
<dl>
<dt>
<i>static</i></dt>
<dd>
Create an ELF object file (.o) or .s file which can be statically linked into an executable when embedding the mono runtime. When this option is used, the object file needs to be registered with the embedded runtime using the mono_aot_register_module function which takes as its argument the mono_aot_module_&lt;ASSEMBLY NAME&gt;_info global symbol from the object file:<div style="height: 1.00em;">
&#160;</div>
<br/>
extern void *mono_aot_module_hello_info;<div class="spacer">
</div>
<br/>
mono_aot_register_module (mono_aot_module_hello_info);<br/>
</dd>
</dl>
<dl>
<dt>
<i>stats</i></dt>
<dd>
Print various stats collected during AOT compilation.</dd>
</dl>
<dl>
<dt>
<i>threads=[number]</i></dt>
<dd>
This is an experimental option for the AOT compiler to use multiple threads when compiling the methods.</dd>
</dl>
<dl>
<dt>
<i>tool-prefix=&lt;PREFIX&gt;</i></dt>
<dd>
Prepends &lt;PREFIX&gt; to the name of tools ran by the AOT compiler, i.e. 'as'/'ld'. For example, --tool=prefix=arm-linux-gnueabi- will make the AOT compiler run</dd>
</dl>
<dl>
<dt>
<i>write-symbols</i></dt>
<dd>
Instructs the AOT compiler to emit debug symbol information.</dd>
</dl>
<div class="spacer">
</div>
For more information about AOT, see: http://www.mono-project.com/docs/advanced/aot/</div>
<dl>
<dt>
<b>--attach=[options]</b></dt>
<dd>
Currently the only option supported by this command line argument is  <b>disable</b> which disables the attach functionality.</dd>
</dl>
<dl>
<dt>
<b>--config filename</b></dt>
<dd>
Load the specified configuration file instead of the default one(s). The default files are /etc/mono/config and ~/.mono/config or the file specified in the MONO_CONFIG environment variable, if set.  See the mono-config(5) man page for details on the format of this file.</dd>
</dl>
<dl>
<dt>
<b>--debugger-agent=[options]</b></dt>
<dd>
This instructs the Mono runtime to start a debugging agent inside the Mono runtime and connect it to a client user interface will control the Mono process. This option is typically used by IDEs, like the MonoDevelop IDE.</dd>
</dl>
<div class="spacer">
</div>
The configuration is specified using one of more of the following options:<div style="margin-left: 5.00ex;">
<dl>
<dt>
<i>address=host:port</i></dt>
<dd>
Use this option to specify the IP address where your debugger client is listening to.</dd>
</dl>
<dl>
<dt>
<i>loglevel=LEVEL</i></dt>
<dd>
Specifies the diagnostics log level for</dd>
</dl>
<dl>
<dt>
<i>logfile=filename</i></dt>
<dd>
Used to specify the file where the log will be stored, it defaults to standard output.</dd>
</dl>
<dl>
<dt>
<i>server=[y/n]</i></dt>
<dd>
Defaults to no, with the default option Mono will actively connect to the host/port configured with the  <b>address</b> option.  If you set it to 'y', it instructs the Mono runtime to start debugging in server mode, where Mono actively waits for the debugger front end to connect to the Mono process. Mono will print out to stdout the IP address and port where it is listening.</dd>
</dl>
<dl>
<dt>
<i>setpgid=[y/n]</i></dt>
<dd>
If set to yes, Mono will call <b>setpgid(0, 0)</b><b> on startup, if that function</b>  <b>is available on the system. This is useful for ensuring that signals delivered</b>  <b>to a process that is executing the debuggee are not propagated to the debuggee,</b>  <b>e.g. when Ctrl-C sends </b><b>SIGINT</b><b> to the </b><b>sdb</b><b> tool.</b></dd>
</dl>
<dl>
<dt>
<i>suspend=[y/n]</i></dt>
<dd>
Defaults to yes, with the default option Mono will suspend the vm on startup until it connects successfully to a debugger front end.  If you set it to 'n', in conjunction with  <b>server=y</b>, it instructs the Mono runtime to run as normal, while caching metadata to send to the debugger front end on connection..</dd>
</dl>
<dl>
<dt>
<i>transport=transport_name</i></dt>
<dd>
This is used to specify the transport that the debugger will use to communicate.   It must be specified and currently requires this to be 'dt_socket'.</dd>
</dl>
</div>
<dl>
<dt>
<b>--desktop</b></dt>
<dd>
Configures the virtual machine to be better suited for desktop applications.  Currently this sets the GC system to avoid expanding the heap as much as possible at the expense of slowing down garbage collection a bit.</dd>
</dl>
<dl>
<dt>
<b>--full-aot</b></dt>
<dd>
This is an experimental flag that instructs the Mono runtime to not generate any code at runtime and depend exclusively on the code generated from using mono --aot=full previously.   This is useful for platforms that do not permit dynamic code generation. Notice that this feature will abort execution at runtime if a codepath in your program, or Mono's class libraries attempts to generate code dynamically.  You should test your software upfront and make sure that you do not use any dynamic features.</dd>
</dl>
<dl>
<dt>
<b>--gc=boehm</b>, <b>--gc=sgen</b></dt>
<dd>
Selects the Garbage Collector engine for Mono to use, Boehm or SGen. Currently this merely ensures that you are running either the  <i>mono</i> or <i>mono-sgen</i> commands.    This flag can be set in the  <b>MONO_ENV_OPTIONS</b> environment variable to force all of your child processes to use one particular kind of GC with the Mono runtime.</dd>
</dl>
<dl>
<dt>
<b>--help</b>, <b>-h</b></dt>
<dd>
Displays usage instructions.</dd>
</dl>
<dl>
<dt>
<b>--llvm</b></dt>
<dd>
If the Mono runtime has been compiled with LLVM support (not available in all configurations), Mono will use the LLVM optimization and code generation engine to JIT or AOT compile. For more information, consult: http://www.mono-project.com/docs/advanced/mono-llvm/</dd>
</dl>
<dl>
<dt>
<b>--nollvm</b></dt>
<dd>
When using a Mono that has been compiled with LLVM support, it forces Mono to fallback to its JIT engine and not use the LLVM backend.</dd>
</dl>
<dl>
<dt>
<b>--optimize=MODE</b>, <b>-O=MODE</b></dt>
<dd>
MODE is a comma separated list of optimizations.  They also allow optimizations to be turned off by prefixing the optimization name with a minus sign. In general, Mono has been tuned to use the default set of flags, before using these flags for a deployment setting, you might want to actually measure the benefits of using them. The following optimizations are implemented:<br/>
             all        Turn on all optimizations<br/>
             peephole   Peephole postpass<br/>
             branch     Branch optimizations<br/>
             inline     Inline method calls<br/>
             cfold      Constant folding<br/>
             consprop   Constant propagation<br/>
             copyprop   Copy propagation<br/>
             deadce     Dead code elimination<br/>
             linears    Linear scan global reg allocation<br/>
             cmov       Conditional moves [arch-dependency]<br/>
             shared     Emit per-domain code<br/>
             sched      Instruction scheduling<br/>
             intrins    Intrinsic method implementations<br/>
             tailc      Tail recursion and tail calls<br/>
             loop       Loop related optimizations<br/>
             fcmov      Fast x86 FP compares [arch-dependency]<br/>
             leaf       Leaf procedures optimizations<br/>
             aot        Usage of Ahead Of Time compiled code<br/>
             precomp    Precompile all methods before executing Main<br/>
             abcrem     Array bound checks removal<br/>
             ssapre     SSA based Partial Redundancy Elimination<br/>
             sse2       SSE2 instructions on x86 [arch-dependency]<br/>
             gshared    Enable generic code sharing.<br/>
For example, to enable all the optimization but dead code elimination and inlining, you can use:<br/>
	-O=all,-deadce,-inline<br/>
The flags that are flagged with [arch-dependency] indicate that the given option if used in combination with Ahead of Time compilation (--aot flag) would produce pre-compiled code that will depend on the current CPU and might not be safely moved to another computer.</dd>
</dl>
<dl>
<dt>
<b>--runtime=VERSION</b></dt>
<dd>
Mono supports different runtime versions. The version used depends on the program that is being run or on its configuration file (named program.exe.config). This option can be used to override such autodetection, by forcing a different runtime version to be used. Note that this should only be used to select a later compatible runtime version than the one the program was compiled against. A typical usage is for running a 1.1 program on a 2.0 version:<br/>
         mono --runtime=v2.0.50727 program.exe<br/>
</dd>
</dl>
<dl>
<dt>
<b>--security</b>, <b>--security=mode</b></dt>
<dd>
Activate the security manager, a currently experimental feature in Mono and it is OFF by default. The new code verifier can be enabled with this option as well.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
Using security without parameters is equivalent as calling it with the &quot;cas&quot; parameter.<div class="spacer">
</div>
The following modes are supported:<dl>
<dt>
<i>cas</i></dt>
<dd>
This allows mono to support declarative security attributes, e.g. execution of Code Access Security (CAS) or non-CAS demands.</dd>
</dl>
<dl>
<dt>
<i>core-clr</i></dt>
<dd>
Enables the core-clr security system, typically used for Moonlight/Silverlight applications.  It provides a much simpler security system than CAS, see http://www.mono-project.com/docs/web/moonlight/ for more details and links to the descriptions of this new system.</dd>
</dl>
<dl>
<dt>
<i>validil</i></dt>
<dd>
Enables the new verifier and performs basic verification for code validity.  In this mode, unsafe code and P/Invoke are allowed. This mode provides a better safety guarantee but it is still possible for managed code to crash Mono.</dd>
</dl>
<dl>
<dt>
<i>verifiable</i></dt>
<dd>
Enables the new verifier and performs full verification of the code being executed.  It only allows verifiable code to be executed. Unsafe code is not allowed but P/Invoke is.  This mode should not allow managed code to crash mono.  The verification is not as strict as ECMA 335 standard in order to stay compatible with the MS runtime.</dd>
</dl>
<div class="spacer">
</div>
The security system acts on user code: code contained in mscorlib or the global assembly cache is always trusted.</div>
<dl>
<dt>
<b>--server</b></dt>
<dd>
Configures the virtual machine to be better suited for server operations (currently, allows a heavier threadpool initialization).</dd>
</dl>
<dl>
<dt>
<b>--verify-all</b></dt>
<dd>
Verifies mscorlib and assemblies in the global assembly cache for valid IL, and all user code for IL verifiability.<div style="height: 1.00em;">
&#160;</div>
This is different from <b>--security</b>'s verifiable or validil in that these options only check user code and skip mscorlib and assemblies located on the global assembly cache.</dd>
</dl>
<dl>
<dt>
<b>-V</b>, <b>--version</b></dt>
<dd>
Prints JIT version information (system configuration, release number and branch names if available).<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>DEVELOPMENT OPTIONS</h1> The following options are used to help when developing a JITed application.<dl>
<dt>
<b>--debug</b>, <b>--debug=OPTIONS</b></dt>
<dd>
Turns on the debugging mode in the runtime.  If an assembly was compiled with debugging information, it will produce line number information for stack traces.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
The optional OPTIONS argument is a comma separated list of debugging options.  These options are turned off by default since they generate much larger and slower code at runtime.<dl>
<dt>
The following options are supported:</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>casts</i></dt>
<dd>
Produces a detailed error when throwing a InvalidCastException.   This option needs to be enabled as this generates more verbose code at execution time.</dd>
</dl>
<dl>
<dt>
<i>mdb-optimizations</i></dt>
<dd>
Disable some JIT optimizations which are usually only disabled when running inside the debugger.  This can be helpful if you want to attach to the running process with mdb.</dd>
</dl>
<dl>
<dt>
<i>gdb</i></dt>
<dd>
Generate and register debugging information with gdb. This is only supported on some platforms, and only when using gdb 7.0 or later.</dd>
</dl>
</div>
<dl>
<dt>
<b>--profile[=profiler[:profiler_args]]</b></dt>
<dd>
Turns on profiling.  For more information about profiling applications and code coverage see the sections &quot;PROFILING&quot; and &quot;CODE COVERAGE&quot; below.</dd>
</dl>
<dl>
<dt>
This option can be used multiple times, each time will load an</dt>
<dd>
additional profiler.   This allows developers to use modules that extend the JIT through the Mono profiling interface.</dd>
</dl>
<dl>
<dt>
<b>--trace[=expression]</b></dt>
<dd>
Shows method names as they are invoked.  By default all methods are traced. The trace can be customized to include or exclude methods, classes or assemblies.  A trace expression is a comma separated list of targets, each target can be prefixed with a minus sign to turn off a particular target.  The words `program', `all' and `disabled' have special meaning.  `program' refers to the main program being executed, and `all' means all the method calls. The `disabled' option is used to start up with tracing disabled.  It can be enabled at a later point in time in the program by sending the SIGUSR2 signal to the runtime. Assemblies are specified by their name, for example, to trace all calls in the System assembly, use:<div class="spacer">
</div>
<br/>
	mono --trace=System app.exe<div class="spacer">
</div>
<br/>
Classes are specified with the T: prefix.  For example, to trace all calls to the System.String class, use:<div class="spacer">
</div>
<br/>
	mono --trace=T:System.String app.exe<div class="spacer">
</div>
<br/>
And individual methods are referenced with the M: prefix, and the standard method notation:<div class="spacer">
</div>
<br/>
	mono --trace=M:System.Console:WriteLine app.exe<div class="spacer">
</div>
<br/>
Exceptions can also be traced, it will cause a stack trace to be printed every time an exception of the specified type is thrown. The exception type can be specified with or without the namespace, and to trace all exceptions, specify 'all' as the type name.<div class="spacer">
</div>
<br/>
	mono --trace=E:System.Exception app.exe<div class="spacer">
</div>
<br/>
As previously noted, various rules can be specified at once:<div class="spacer">
</div>
<br/>
	mono --trace=T:System.String,T:System.Random app.exe<div class="spacer">
</div>
<br/>
You can exclude pieces, the next example traces calls to System.String except for the System.String:Concat method.<div class="spacer">
</div>
<br/>
	mono --trace=T:System.String,-M:System.String:Concat<div class="spacer">
</div>
<br/>
You can trace managed to unmanaged transitions using the wrapper qualifier:<div class="spacer">
</div>
<br/>
	mono --trace=wrapper app.exe<div class="spacer">
</div>
<br/>
Finally, namespaces can be specified using the N: prefix:<div class="spacer">
</div>
<br/>
	mono --trace=N:System.Xml<div class="spacer">
</div>
<br/>
</dd>
</dl>
<dl>
<dt>
<b>--no-x86-stack-align</b></dt>
<dd>
Don't align stack frames on the x86 architecture.  By default, Mono aligns stack frames to 16 bytes on x86, so that local floating point and SIMD variables can be properly aligned.  This option turns off the alignment, which usually saves one intruction per call, but might result in significantly lower floating point and SIMD performance.</dd>
</dl>
<dl>
<dt>
<b>--jitmap</b></dt>
<dd>
Generate a JIT method map in a /tmp/perf-PID.map file. This file is then used, for example, by the perf tool included in recent Linux kernels. Each line in the file has:<div class="spacer">
</div>
<br/>
	HEXADDR HEXSIZE methodname<div class="spacer">
</div>
<br/>
Currently this option is only supported on Linux.</dd>
</dl>
</div>
<div class="section">
<h1>JIT MAINTAINER OPTIONS</h1> The maintainer options are only used by those developing the runtime itself, and not typically of interest to runtime users or developers.<dl>
<dt>
<b>--break method</b></dt>
<dd>
Inserts a breakpoint before the method whose name is `method' (namespace.class:methodname).  Use `Main' as method name to insert a breakpoint on the application's main method.  You can use it also with generics, for example &quot;System.Collections.Generic.Queue`1:Peek&quot;</dd>
</dl>
<dl>
<dt>
<b>--breakonex</b></dt>
<dd>
Inserts a breakpoint on exceptions.  This allows you to debug your application with a native debugger when an exception is thrown.</dd>
</dl>
<dl>
<dt>
<b>--compile name</b></dt>
<dd>
This compiles a method (namespace.name:methodname), this is used for testing the compiler performance or to examine the output of the code generator.</dd>
</dl>
<dl>
<dt>
<b>--compileall</b></dt>
<dd>
Compiles all the methods in an assembly.  This is used to test the compiler performance or to examine the output of the code generator</dd>
</dl>
<dl>
<dt>
<b>--graph=TYPE METHOD</b></dt>
<dd>
This generates a postscript file with a graph with the details about the specified method (namespace.name:methodname).  This requires `dot' and ghostview to be installed (it expects Ghostview to be called &quot;gv&quot;). The following graphs are available:<br/>
          cfg        Control Flow Graph (CFG)<br/>
          dtree      Dominator Tree<br/>
          code       CFG showing code<br/>
          ssa        CFG showing code after SSA translation<br/>
          optcode    CFG showing code after IR optimizations<br/>
Some graphs will only be available if certain optimizations are turned on.</dd>
</dl>
<dl>
<dt>
<b>--ncompile</b></dt>
<dd>
Instruct the runtime on the number of times that the method specified by --compile (or all the methods if --compileall is used) to be compiled.  This is used for testing the code generator performance.</dd>
</dl>
<dl>
<dt>
<b>--stats</b></dt>
<dd>
Displays information about the work done by the runtime during the execution of an application.</dd>
</dl>
<dl>
<dt>
<b>--wapi=hps|semdel</b></dt>
<dd>
Perform maintenance of the process shared data. semdel will delete the global semaphore. hps will list the currently used handles.</dd>
</dl>
<dl>
<dt>
<b>-v</b>, <b>--verbose</b></dt>
<dd>
Increases the verbosity level, each time it is listed, increases the verbosity level to include more information (including, for example, a disassembly of the native code produced, code selector info etc.).</dd>
</dl>
</div>
<div class="section">
<h1>ATTACH SUPPORT</h1> The Mono runtime allows external processes to attach to a running process and load assemblies into the running program.   To attach to the process, a special protocol is implemented in the Mono.Management assembly.<div class="spacer">
</div>
With this support it is possible to load assemblies that have an entry point (they are created with -target:exe or -target:winexe) to be loaded and executed in the Mono process.<div class="spacer">
</div>
The code is loaded into the root domain, and it starts execution on the special runtime attach thread.    The attached program should create its own threads and return after invocation.<div class="spacer">
</div>
This support allows for example debugging applications by having the csharp shell attach to running processes.</div>
<div class="section">
<h1>PROFILING</h1> The mono runtime includes a profiler that can be used to explore various performance related problems in your application.  The profiler is activated by passing the --profile command line argument to the Mono runtime, the format is:<div class="spacer">
</div>
<br/>
	--profile[=profiler[:profiler_args]]<div class="spacer">
</div>
<br/>
Mono has a built-in profiler called 'default' (and is also the default if no arguments are specified), but developers can write custom profilers, see the section &quot;CUSTOM PROFILERS&quot; for more details.<div class="spacer">
</div>
If a <i>profiler</i> is not specified, the default profiler is used. The <i>profiler_args</i> is a profiler-specific string of options for the profiler itself. The default profiler accepts the following options 'alloc' to profile memory consumption by the application; 'time' to profile the time spent on each routine; 'jit' to collect time spent JIT-compiling methods and 'stat' to perform sample statistical profiling. If no options are provided the default is 'alloc,time,jit'.<div class="spacer">
</div>
By default the profile data is printed to stdout: to change this, use the 'file=filename' option to output the data to filename. For example:<div class="spacer">
</div>
<br/>
	mono --profile program.exe<div class="spacer">
</div>
<br/>
That will run the program with the default profiler and will do time and allocation profiling.<div class="spacer">
</div>
<br/>
	mono --profile=default:stat,alloc,file=prof.out program.exe<div class="spacer">
</div>
<br/>
Will do  sample statistical profiling and allocation profiling on program.exe. The profile data is put in prof.out. Note that the statistical profiler has a very low overhead and should be the preferred profiler to use (for better output use the full path to the mono binary when running and make sure you have installed the addr2line utility that comes from the binutils package).</div>
<div class="section">
<h1>LOG PROFILER</h1> This is the most advanced profiler.<div class="spacer">
</div>
The Mono <i>log</i> profiler can be used to collect a lot of information about a program running in the Mono runtime. This data can be used (both while the process is running and later) to do analyses of the program behaviour, determine resource usage, performance issues or even look for particular execution patterns.<div class="spacer">
</div>
This is accomplished by logging the events provided by the Mono runtime through the profiling interface and periodically writing them to a file which can be later inspected with the mprof-report(1) tool.<div class="spacer">
</div>
More information about how to use the log profiler is available on the mprof-report(1) page.</div>
<div class="section">
<h1>CUSTOM PROFILERS</h1> Mono provides a mechanism for loading other profiling modules which in the form of shared libraries.  These profiling modules can hook up to various parts of the Mono runtime to gather information about the code being executed.<div class="spacer">
</div>
To use a third party profiler you must pass the name of the profiler to Mono, like this:<div class="spacer">
</div>
<br/>
	mono --profile=custom program.exe<div class="spacer">
</div>
<br/>
<div class="spacer">
</div>
In the above sample Mono will load the user defined profiler from the shared library `mono-profiler-custom.so'.  This profiler module must be on your dynamic linker library path.<div class="spacer">
</div>
A list of other third party profilers is available from Mono's web site (www.mono-project.com/docs/advanced/performance-tips/)<div class="spacer">
</div>
Custom profiles are written as shared libraries.  The shared library must be called `mono-profiler-NAME.so' where `NAME' is the name of your profiler.<div class="spacer">
</div>
For a sample of how to write your own custom profiler look in the Mono source tree for in the samples/profiler.c.</div>
<div class="section">
<h1>CODE COVERAGE</h1> Mono ships with a code coverage module.  This module is activated by using the Mono --profile=cov option.  The format is:  <b>--profile=cov[:assembly-name[/namespace]] test-suite.exe</b><div class="spacer">
</div>
By default code coverage will default to all the assemblies loaded, you can limit this by specifying the assembly name, for example to perform code coverage in the routines of your program use, for example the following command line limits the code coverage to routines in the &quot;demo&quot; assembly:<div class="spacer">
</div>
<br/>
	mono --profile=cov:demo demo.exe<div class="spacer">
</div>
<br/>
<div class="spacer">
</div>
Notice that the <i>assembly-name</i> does not include the extension.<div class="spacer">
</div>
You can further restrict the code coverage output by specifying a namespace:<div class="spacer">
</div>
<br/>
	mono --profile=cov:demo/My.Utilities demo.exe<div class="spacer">
</div>
<br/>
<div class="spacer">
</div>
Which will only perform code coverage in the given assembly and namespace.<div class="spacer">
</div>
Typical output looks like this:<div class="spacer">
</div>
<br/>
	Not covered: Class:.ctor ()<br/>
	Not covered: Class:A ()<br/>
	Not covered: Driver:.ctor ()<br/>
	Not covered: Driver:method ()<br/>
	Partial coverage: Driver:Main ()<br/>
		offset 0x000a<div class="spacer">
</div>
<br/>
<div class="spacer">
</div>
The offsets displayed are IL offsets.<div class="spacer">
</div>
A more powerful coverage tool is available in the module `monocov'. See the monocov(1) man page for details.</div>
<div class="section">
<h1>DEBUGGING AIDS</h1> To debug managed applications, you can use the <b>mdb</b> command, a command line debugger.<div class="spacer">
</div>
It is possible to obtain a stack trace of all the active threads in Mono by sending the QUIT signal to Mono, you can do this from the command line, like this:<div class="spacer">
</div>
<br/>
	kill -QUIT pid<div class="spacer">
</div>
<br/>
Where pid is the Process ID of the Mono process you want to examine. The process will continue running afterwards, but its state is not guaranteed.<div class="spacer">
</div>
<b>Important:</b> this is a last-resort mechanism for debugging applications and should not be used to monitor or probe a production application.  The integrity of the runtime after sending this signal is not guaranteed and the application might crash or terminate at any given point afterwards.<div class="spacer">
</div>
The <b>--debug=casts</b> option can be used to get more detailed information for Invalid Cast operations, it will provide information about the types involved.<div class="spacer">
</div>
You can use the MONO_LOG_LEVEL and MONO_LOG_MASK environment variables to get verbose debugging output about the execution of your application within Mono.<div class="spacer">
</div>
The <i>MONO_LOG_LEVEL</i> environment variable if set, the logging level is changed to the set value. Possible values are &quot;error&quot;, &quot;critical&quot;, &quot;warning&quot;, &quot;message&quot;, &quot;info&quot;, &quot;debug&quot;. The default value is &quot;error&quot;. Messages with a logging level greater then or equal to the log level will be printed to stdout/stderr.<div class="spacer">
</div>
Use &quot;info&quot; to track the dynamic loading of assemblies.<div class="spacer">
</div>
Use the <i>MONO_LOG_MASK</i> environment variable to limit the extent of the messages you get: If set, the log mask is changed to the set value. Possible values are &quot;asm&quot; (assembly loader), &quot;type&quot;, &quot;dll&quot; (native library loader), &quot;gc&quot; (garbage collector), &quot;cfg&quot; (config file loader), &quot;aot&quot; (precompiler), &quot;security&quot; (e.g. Moonlight CoreCLR support) and &quot;all&quot;. The default value is &quot;all&quot;. Changing the mask value allows you to display only messages for a certain component. You can use multiple masks by comma separating them. For example to see config file messages and assembly loader messages set you mask to &quot;asm,cfg&quot;.<div class="spacer">
</div>
The following is a common use to track down problems with P/Invoke:<div class="spacer">
</div>
<br/>
	$ MONO_LOG_LEVEL=&quot;debug&quot; MONO_LOG_MASK=&quot;dll&quot; mono glue.exe<div class="spacer">
</div>
<br/>
</div>
<div class="section">
<h1>DEBUGGING WITH LLDB</h1> If you are using LLDB, you can use the <b>mono.py</b> script to print some internal data structures with it.   To use this, add this to your <b>$HOME/.lldbinit</b> file:<br/>
command script import $PREFIX/lib/mono/lldb/mono.py<br/>
<div class="spacer">
</div>
Where $PREFIX is the prefix value that you used when you configured Mono (typically /usr).<div class="spacer">
</div>
Once this is done, then you can inspect some Mono Runtime data structures, for example:<br/>
(lldb) p method<div class="spacer">
</div>
<br/>
(MonoMethod *) $0 = 0x05026ac0 [mscorlib]System.OutOfMemoryException:.ctor()<br/>
</div>
<div class="section">
<h1>SERIALIZATION</h1> Mono's XML serialization engine by default will use a reflection-based approach to serialize which might be slow for continuous processing (web service applications).  The serialization engine will determine when a class must use a hand-tuned serializer based on a few parameters and if needed it will produce a customized C# serializer for your types at runtime.  This customized serializer then gets dynamically loaded into your application.<div class="spacer">
</div>
You can control this with the MONO_XMLSERIALIZER_THS environment variable.<div class="spacer">
</div>
The possible values are <b>`no'</b> to disable the use of a C# customized serializer, or an integer that is the minimum number of uses before the runtime will produce a custom serializer (0 will produce a custom serializer on the first access, 50 will produce a serializer on the 50th use). Mono will fallback to an interpreted serializer if the serializer generation somehow fails. This behavior can be disabled by setting the option <b>`nofallback'</b> (for example: MONO_XMLSERIALIZER_THS=0,nofallback).</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES</h1><dl>
<dt>
<b>GC_DONT_GC</b></dt>
<dd>
Turns off the garbage collection in Mono.  This should be only used for debugging purposes</dd>
</dl>
<dl>
<dt>
<b>LVM_COUNT</b></dt>
<dd>
When Mono is compiled with LLVM support, this instructs the runtime to stop using LLVM after the specified number of methods are JITed. This is a tool used in diagnostics to help isolate problems in the code generation backend.   For example  <b>LLVM_COUNT=10</b> would only compile 10 methods with LLVM and then switch to the Mono JIT engine.  <b>LLVM_COUNT=0</b> would disable the LLVM engine altogether.</dd>
</dl>
<dl>
<dt>
<b>MONO_AOT_CACHE</b></dt>
<dd>
If set, this variable will instruct Mono to ahead-of-time compile new assemblies on demand and store the result into a cache in ~/.mono/aot-cache.</dd>
</dl>
<dl>
<dt>
<b>MONO_ASPNET_INHIBIT_SETTINGSMAP</b></dt>
<dd>
Mono contains a feature which allows modifying settings in the .config files shipped with Mono by using config section mappers. The mappers and the mapping rules are defined in the $prefix/etc/mono/2.0/settings.map file and, optionally, in the settings.map file found in the top-level directory of your ASP.NET application. Both files are read by System.Web on application startup, if they are found at the above locations. If you don't want the mapping to be performed you can set this variable in your environment before starting the application and no action will be taken.</dd>
</dl>
<dl>
<dt>
<b>MONO_ASPNET_WEBCONFIG_CACHESIZE</b></dt>
<dd>
Mono has a cache of ConfigSection objects for speeding up WebConfigurationManager queries. Its default size is 100 items, and when more items are needed, cache evictions start happening. If evictions are too frequent this could impose unnecessary overhead, which could be avoided by using this environment variable to set up a higher cache size (or to lower memory requirements by decreasing it).</dd>
</dl>
<dl>
<dt>
<b>MONO_CAIRO_DEBUG_DISPOSE</b></dt>
<dd>
If set, causes Mono.Cairo to collect stack traces when objects are allocated, so that the finalization/Dispose warnings include information about the instance's origin.</dd>
</dl>
<dl>
<dt>
<b>MONO_CFG_DIR</b></dt>
<dd>
If set, this variable overrides the default system configuration directory ($PREFIX/etc). It's used to locate machine.config file.</dd>
</dl>
<dl>
<dt>
<b>MONO_COM</b></dt>
<dd>
Sets the style of COM interop.  If the value of this variable is &quot;MS&quot; Mono will use string marhsalling routines from the liboleaut32 for the BSTR type library, any other values will use the mono-builtin BSTR string marshalling.</dd>
</dl>
<dl>
<dt>
<b>MONO_CONFIG</b></dt>
<dd>
If set, this variable overrides the default runtime configuration file ($PREFIX/etc/mono/config). The --config command line options overrides the environment variable.</dd>
</dl>
<dl>
<dt>
<b>MONO_CPU_ARCH</b></dt>
<dd>
Override the automatic cpu detection mechanism. Currently used only on arm. The format of the value is as follows:<div class="spacer">
</div>
<br/>
	&quot;armvV [thumb[2]]&quot;<div class="spacer">
</div>
<br/>
where V is the architecture number 4, 5, 6, 7 and the options can be currently be &quot;thumb&quot; or &quot;thumb2&quot;. Example:<div class="spacer">
</div>
<br/>
	MONO_CPU_ARCH=&quot;armv4 thumb&quot; mono ...<div class="spacer">
</div>
<br/>
</dd>
</dl>
<dl>
<dt>
<b>MONO_ARM_FORCE_SOFT_FLOAT</b></dt>
<dd>
When Mono is built with a soft float fallback on ARM and this variable is set to &quot;1&quot;, Mono will always emit soft float code, even if a VFP unit is detected.</dd>
</dl>
<dl>
<dt>
<b>MONO_DISABLE_AIO</b></dt>
<dd>
If set, tells mono NOT to attempt using native asynchronous I/O services. In that case, a default select/poll implementation is used. Currently only epoll() is supported.</dd>
</dl>
<dl>
<dt>
<b>MONO_DISABLE_MANAGED_COLLATION</b></dt>
<dd>
If this environment variable is `yes', the runtime uses unmanaged collation (which actually means no culture-sensitive collation). It internally disables managed collation functionality invoked via the members of System.Globalization.CompareInfo class. Collation is enabled by default.</dd>
</dl>
<dl>
<dt>
<b>MONO_DISABLE_SHM</b></dt>
<dd>
Unix only: If set, disables the shared memory files used for cross-process handles: process have only private handles.  This means that process and thread handles are not available to other processes, and named mutexes, named events and named semaphores are not visible between processes. This is can also be enabled by default by passing the &quot;--disable-shared-handles&quot; option to configure. This is the default from mono 2.8 onwards.</dd>
</dl>
<dl>
<dt>
<b>MONO_DISABLE_SHARED_AREA</b></dt>
<dd>
Unix only: If set, disable usage of shared memory for exposing performance counters. This means it will not be possible to both externally read performance counters from this processes or read those of external processes.</dd>
</dl>
<dl>
<dt>
<b>MONO_DNS</b></dt>
<dd>
When set, enables the use of a fully managed DNS resolver instead of the regular libc functions. This resolver performs much better when multiple queries are run in parallel.<div style="height: 1.00em;">
&#160;</div>
Note that /etc/nsswitch.conf will be ignored.</dd>
</dl>
<dl>
<dt>
<b>MONO_EGD_SOCKET</b></dt>
<dd>
For platforms that do not otherwise have a way of obtaining random bytes this can be set to the name of a file system socket on which an egd or prngd daemon is listening.</dd>
</dl>
<dl>
<dt>
<b>MONO_ENABLE_SHM</b></dt>
<dd>
Unix only: Enable support for cross-process handles.  Cross-process handles are used to expose process handles, thread handles, named mutexes, named events and named semaphores across Unix processes.</dd>
</dl>
<dl>
<dt>
<b>MONO_ENV_OPTIONS</b></dt>
<dd>
This environment variable allows you to pass command line arguments to a Mono process through the environment.   This is useful for example to force all of your Mono processes to use LLVM or SGEN without having to modify any launch scripts.</dd>
</dl>
<dl>
<dt>
<b>MONO_ENV_OPTIONS</b></dt>
<dd>
Used to pass extra options to the debugger agent in the runtime, as they were passed using --debugger-agent=.</dd>
</dl>
<dl>
<dt>
<b>MONO_EVENTLOG_TYPE</b></dt>
<dd>
Sets the type of event log provider to use (for System.Diagnostics.EventLog). Possible values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<i>local[:path]</i></dt>
<dd>
Persists event logs and entries to the local file system. The directory in which to persist the event logs, event sources and entries can be specified as part of the value. If the path is not explicitly set, it defaults to &quot;/var/lib/mono/eventlog&quot; on unix and &quot;%APPDATA%no\ventlog&quot; on Windows.</dd>
</dl>
<dl>
<dt>
<i>win32</i></dt>
<dd>
<b>Uses the native win32 API to write events and registers event logs and</b> event sources in the registry.   This is only available on Windows. On Unix, the directory permission for individual event log and event source directories is set to 777 (with +t bit) allowing everyone to read and write event log entries while only allowing entries to be deleted by the user(s) that created them.</dd>
</dl>
<dl>
<dt>
<i>null</i></dt>
<dd>
Silently discards any events.</dd>
</dl>
<div class="spacer">
</div>
The default is &quot;null&quot; on Unix (and versions of Windows before NT), and &quot;win32&quot; on Windows NT (and higher).</div>
<dl>
<dt>
<b>MONO_EXTERNAL_ENCODINGS</b></dt>
<dd>
If set, contains a colon-separated list of text encodings to try when turning externally-generated text (e.g. command-line arguments or filenames) into Unicode.  The encoding names come from the list provided by iconv, and the special case &quot;default_locale&quot; which refers to the current locale's default encoding.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
When reading externally-generated text strings UTF-8 is tried first, and then this list is tried in order with the first successful conversion ending the search.  When writing external text (e.g. new filenames or arguments to new processes) the first item in this list is used, or UTF-8 if the environment variable is not set.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The problem with using MONO_EXTERNAL_ENCODINGS to process your files is that it results in a problem: although its possible to get the right file name it is not necessarily possible to open the file. In general if you have problems with encodings in your filenames you should use the &quot;convmv&quot; program.</dd>
</dl>
<dl>
<dt>
<b>MONO_GC_PARAMS</b></dt>
<dd>
When using Mono with the SGen garbage collector this variable controls several parameters of the collector.  The variable's value is a comma separated list of words.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>nursery-size=</b><i>size</i></dt>
<dd>
Sets the size of the nursery.  The size is specified in bytes and must be a power of two.  The suffixes `k', `m' and `g' can be used to specify kilo-, mega- and gigabytes, respectively.  The nursery is the first generation (of two).  A larger nursery will usually speed up the program but will obviously use more memory.  The default nursery size 4 MB.</dd>
</dl>
<dl>
<dt>
<b>major=</b><i>collector</i> Specifies which major collector to use.</dt>
<dd>
Options are `marksweep' for the Mark&amp;Sweep collector, and `marksweep-conc' for concurrent Mark&amp;Sweep.  The non-concurrent Mark&amp;Sweep collector is the default.</dd>
</dl>
<dl>
<dt>
<b>soft-heap-limit=</b><i>size</i></dt>
<dd>
Once the heap size gets larger than this size, ignore what the default major collection trigger metric says and only allow four nursery size's of major heap growth between major collections.</dd>
</dl>
<dl>
<dt>
<b>evacuation-threshold=</b><i>threshold</i></dt>
<dd>
Sets the evacuation threshold in percent.  This option is only available on the Mark&amp;Sweep major collectors.  The value must be an integer in the range 0 to 100.  The default is 66.  If the sweep phase of the collection finds that the occupancy of a specific heap block type is less than this percentage, it will do a copying collection for that block type in the next major collection, thereby restoring occupancy to close to 100 percent.  A value of 0 turns evacuation off.</dd>
</dl>
<dl>
<dt>
<b>(no-)lazy-sweep</b></dt>
<dd>
Enables or disables lazy sweep for the Mark&amp;Sweep collector.  If enabled, the sweep phase of the garbage collection is done piecemeal whenever the need arises, typically during nursery collections.  Lazy sweeping is enabled by default.</dd>
</dl>
<dl>
<dt>
<b>stack-mark=</b><i>mark-mode</i></dt>
<dd>
Specifies how application threads should be scanned. Options are `precise` and `conservative`. Precise marking allow the collector to know what values on stack are references and what are not. Conservative marking threats all values as potentially references and leave them untouched. Precise marking reduces floating garbage and can speed up nursery collection and allocation rate, it has the downside of requiring a significant extra memory per compiled method. The right option, unfortunately, requires experimentation.</dd>
</dl>
<dl>
<dt>
<b>save-target-ratio=</b><i>ratio</i></dt>
<dd>
Specifies the target save ratio for the major collector. The collector lets a given amount of memory to be promoted from the nursery due to minor collections before it triggers a major collection. This amount is based on how much memory it expects to free. It is represented as a ratio of the size of the heap after a major collection. Valid values are between 0.1 and 2.0. The default is 0.5. Smaller values will keep the major heap size smaller but will trigger more major collections. Likewise, bigger values will use more memory and result in less frequent major collections. This option is EXPERIMENTAL, so it might disappear in later versions of mono.</dd>
</dl>
<dl>
<dt>
<b>default-allowance-ratio=</b><i>ratio</i></dt>
<dd>
Specifies the default allocation allowance when the calculated size is too small. The allocation allowance is how much memory the collector let be promoted before triggered a major collection. It is a ratio of the nursery size. Valid values are between 1.0 and 10.0. The default is 4.0. Smaller values lead to smaller heaps and more frequent major collections. Likewise, bigger values will allow the heap to grow faster but use more memory when it reaches a stable size. This option is EXPERIMENTAL, so it might disappear in later versions of mono.</dd>
</dl>
<dl>
<dt>
<b>minor=</b><i>minor-collector</i></dt>
<dd>
Specifies which minor collector to use. Options are 'simple' which promotes all objects from the nursery directly to the old generation and 'split' which lets object stay longer on the nursery before promoting.</dd>
</dl>
<dl>
<dt>
<b>alloc-ratio=</b><i>ratio</i></dt>
<dd>
Specifies the ratio of memory from the nursery to be use by the alloc space. This only can only be used with the split minor collector. Valid values are integers between 1 and 100. Default is 60.</dd>
</dl>
<dl>
<dt>
<b>promotion-age=</b><i>age</i></dt>
<dd>
Specifies the required age of an object must reach inside the nursery before been promoted to the old generation. This only can only be used with the split minor collector. Valid values are integers between 1 and 14. Default is 2.</dd>
</dl>
<dl>
<dt>
<b>(no-)cementing</b></dt>
<dd>
Enables or disables cementing.  This can dramatically shorten nursery collection times on some benchmarks where pinned objects are referred to from the major heap.</dd>
</dl>
</div>
<dl>
<dt>
<b>MONO_GC_DEBUG</b></dt>
<dd>
When using Mono with the SGen garbage collector this environment variable can be used to turn on various debugging features of the collector.  The value of this variable is a comma separated list of words.  Do not use these options in production.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<i>number</i></dt>
<dd>
Sets the debug level to the specified number.</dd>
</dl>
<dl>
<dt>
<b>print-allowance</b></dt>
<dd>
After each major collection prints memory consumption for before and after the collection and the allowance for the minor collector, i.e. how much the heap is allowed to grow from minor collections before the next major collection is triggered.</dd>
</dl>
<dl>
<dt>
<b>print-pinning</b></dt>
<dd>
Gathers statistics on the classes whose objects are pinned in the nursery and for which global remset entries are added.  Prints those statistics when shutting down.</dd>
</dl>
<dl>
<dt>
<b>collect-before-allocs</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>check-at-minor-collections</b></dt>
<dd>
This performs a consistency check on minor collections and also clears the nursery at collection time, instead of the default, when buffers are allocated (clear-at-gc).   The consistency check ensures that there are no major to minor references that are not on the remembered sets.</dd>
</dl>
<dl>
<dt>
<b>mod-union-consistency-check</b></dt>
<dd>
Checks that the mod-union cardtable is consistent before each finishing major collection pause.  This check is only applicable to concurrent major collectors.</dd>
</dl>
<dl>
<dt>
<b>check-mark-bits</b></dt>
<dd>
Checks that mark bits in the major heap are consistent at the end of each major collection.  Consistent mark bits mean that if an object is marked, all objects that it had references to must also be marked.</dd>
</dl>
<dl>
<dt>
<b>check-nursery-pinned</b></dt>
<dd>
After nursery collections, and before starting concurrent collections, check whether all nursery objects are pinned, or not pinned - depending on context.  Does nothing when the split nursery collector is used.</dd>
</dl>
<dl>
<dt>
<b>xdomain-checks</b></dt>
<dd>
Performs a check to make sure that no references are left to an unloaded AppDomain.</dd>
</dl>
<dl>
<dt>
<b>clear-at-tlab-creation</b></dt>
<dd>
Clears the nursery incrementally when the thread local allocation buffers (TLAB) are created.  The default setting clears the whole nursery at GC time.</dd>
</dl>
<dl>
<dt>
<b>debug-clear-at-tlab-creation</b></dt>
<dd>
Clears the nursery incrementally when the thread local allocation buffers (TLAB) are created, but at GC time fills it with the byte `0xff`, which should result in a crash more quickly if `clear-at-tlab-creation` doesn't work properly.</dd>
</dl>
<dl>
<dt>
<b>clear-at-gc</b></dt>
<dd>
This clears the nursery at GC time instead of doing it when the thread local allocation buffer (TLAB) is created.  The default is to clear the nursery at TLAB creation time.</dd>
</dl>
<dl>
<dt>
<b>disable-minor</b></dt>
<dd>
Don't do minor collections.  If the nursery is full, a major collection is triggered instead, unless it, too, is disabled.</dd>
</dl>
<dl>
<dt>
<b>disable-major</b></dt>
<dd>
Don't do major collections.</dd>
</dl>
<dl>
<dt>
<b>conservative-stack-mark</b></dt>
<dd>
Forces the GC to scan the stack conservatively, even if precise scanning is available.</dd>
</dl>
<dl>
<dt>
<b>no-managed-allocator</b></dt>
<dd>
Disables the managed allocator.</dd>
</dl>
<dl>
<dt>
<b>check-scan-starts</b></dt>
<dd>
If set, does a plausibility check on the scan_starts before and after each collection</dd>
</dl>
<dl>
<dt>
<b>verify-nursery-at-minor-gc</b></dt>
<dd>
If set, does a complete object walk of the nursery at the start of each minor collection.</dd>
</dl>
<dl>
<dt>
<b>dump-nursery-at-minor-gc</b></dt>
<dd>
If set, dumps the contents of the nursery at the start of each minor collection. Requires verify-nursery-at-minor-gc to be set.</dd>
</dl>
<dl>
<dt>
<b>heap-dump=</b><i>file</i></dt>
<dd>
Dumps the heap contents to the specified file.   To visualize the information, use the mono-heapviz tool.</dd>
</dl>
<dl>
<dt>
<b>binary-protocol=</b><i>file</i></dt>
<dd>
Outputs the debugging output to the specified file.   For this to work, Mono needs to be compiled with the BINARY_PROTOCOL define on sgen-gc.c.   You can then use this command to explore the output<br/>
                sgen-grep-binprot 0x1234 0x5678 &lt; file</dd>
</dl>
<dl>
<dt>
<b>nursery-canaries</b></dt>
<dd>
If set, objects allocated in the nursery are suffixed with a canary (guard)<br/>
word, which is checked on each minor collection. Can be used to detect/debug<br/>
heap corruption issues.<br/>
</dd>
</dl>
</div>
<dl>
<dt>
<b>do-not-finalize</b></dt>
<dd>
If enabled, finalizers will not be run.  Everything else will be unaffected: finalizable objects will still be put into the finalization queue where they survive until they're scheduled to finalize.  Once they're not in the queue anymore they will be collected regularly.<br/>
</dd>
</dl>
<dl>
<dt>
<b>MONO_GAC_PREFIX</b></dt>
<dd>
Provides a prefix the runtime uses to look for Global Assembly Caches. Directories are separated by the platform path separator (colons on unix). MONO_GAC_PREFIX should point to the top directory of a prefixed install. Or to the directory provided in the gacutil /gacdir command. Example: <b>/home/username/.mono:/usr/local/mono/</b></dd>
</dl>
<dl>
<dt>
<b>MONO_IOMAP</b></dt>
<dd>
Enables some filename rewriting support to assist badly-written applications that hard-code Windows paths.  Set to a colon-separated list of &quot;drive&quot; to strip drive letters, or &quot;case&quot; to do case-insensitive file matching in every directory in a path.  &quot;all&quot; enables all rewriting methods.  (Backslashes are always mapped to slashes if this variable is set to a valid option).<br/>
For example, this would work from the shell:<div class="spacer">
</div>
<br/>
	MONO_IOMAP=drive:case<br/>
	export MONO_IOMAP<div class="spacer">
</div>
<br/>
If you are using mod_mono to host your web applications, you can use the <b>MonoIOMAP</b> directive instead, like this:<div class="spacer">
</div>
<br/>
	MonoIOMAP &lt;appalias&gt; all<div class="spacer">
</div>
<br/>
See mod_mono(8) for more details.<div style="height: 1.00em;">
&#160;</div>
Additionally. Mono includes a profiler module which allows one to track what adjustements to file paths IOMAP code needs to do. The tracking code reports the managed location (full stack trace) from which the IOMAP-ed call was made and, on process exit, the locations where all the IOMAP-ed strings were created in managed code. The latter report is only approximate as it is not always possible to estimate the actual location where the string was created. The code uses simple heuristics - it analyzes stack trace leading back to the string allocation location and ignores all the managed code which lives in assemblies installed in GAC as well as in the class libraries shipped with Mono (since they are assumed to be free of case-sensitivity issues). It then reports the first location in the user's code - in most cases this will be the place where the string is allocated or very close to the location. The reporting code is implemented as a custom profiler module (see the &quot;PROFILING&quot; section) and can be loaded in the following way:<br/>
<div class="spacer">
</div>
<br/>
	mono --profile=iomap yourapplication.exe<div class="spacer">
</div>
<br/>
Note, however, that Mono currently supports only one profiler module at a time.</dd>
</dl>
<dl>
<dt>
<b>MONO_LLVM</b></dt>
<dd>
When Mono is using the LLVM code generation backend you can use this environment variable to pass code generation options to the LLVM compiler.</dd>
</dl>
<dl>
<dt>
<b>MONO_MANAGED_WATCHER</b></dt>
<dd>
If set to &quot;disabled&quot;, System.IO.FileSystemWatcher will use a file watcher implementation which silently ignores all the watching requests. If set to any other value, System.IO.FileSystemWatcher will use the default managed implementation (slow). If unset, mono will try to use inotify, FAM, Gamin, kevent under Unix systems and native API calls on Windows, falling back to the managed implementation on error.</dd>
</dl>
<dl>
<dt>
<b>MONO_MESSAGING_PROVIDER</b></dt>
<dd>
Mono supports a plugin model for its implementation of System.Messaging making it possible to support a variety of messaging implementations (e.g. AMQP, ActiveMQ). To specify which messaging implementation is to be used the evironement variable needs to be set to the full class name for the provider.  E.g. to use the RabbitMQ based AMQP implementation the variable should be set to:<div style="height: 1.00em;">
&#160;</div>
<br/>
Mono.Messaging.RabbitMQ.RabbitMQMessagingProvider,Mono.Messaging.RabbitMQ</dd>
</dl>
<dl>
<dt>
<b>MONO_NO_SMP</b></dt>
<dd>
If set causes the mono process to be bound to a single processor. This may be<br/>
useful when debugging or working around race conditions.</dd>
</dl>
<dl>
<dt>
<b>MONO_NO_TLS</b></dt>
<dd>
Disable inlining of thread local accesses. Try setting this if you get a segfault<br/>
early on in the execution of mono.</dd>
</dl>
<dl>
<dt>
<b>MONO_PATH</b></dt>
<dd>
Provides a search path to the runtime where to look for library<br/>
files.   This is a tool convenient for debugging applications, but<br/>
should not be used by deployed applications as it breaks the assembly<br/>
loader in subtle ways. <br/>
Directories are separated by the platform path separator (colons on unix). Example: <b>/home/username/lib:/usr/local/mono/lib</b><br/>
Relative paths are resolved based on the launch-time current directory.<br/>
Alternative solutions to MONO_PATH include: installing libraries into<br/>
the Global Assembly Cache (see gacutil(1)) or having the dependent<br/>
libraries side-by-side with the main executable.<br/>
For a complete description of recommended practices for application<br/>
deployment, see<br/>
http://www.mono-project.com/docs/getting-started/application-deployment/</dd>
</dl>
<dl>
<dt>
<b>MONO_RTC</b></dt>
<dd>
Experimental RTC support in the statistical profiler: if the user has<br/>
the permission, more accurate statistics are gathered.  The MONO_RTC<br/>
value must be restricted to what the Linux rtc allows: power of two<br/>
from 64 to 8192 Hz. To enable higher frequencies like 4096 Hz, run as root:<div class="spacer">
</div>
<br/>
	echo 4096 &gt; /proc/sys/dev/rtc/max-user-freq<div class="spacer">
</div>
<br/>
For example:<div class="spacer">
</div>
<br/>
	MONO_RTC=4096 mono --profiler=default:stat program.exe<div class="spacer">
</div>
<br/>
</dd>
</dl>
<dl>
<dt>
<b>MONO_SHARED_DIR</b></dt>
<dd>
If set its the directory where the &quot;.wapi&quot; handle state is stored. This is the directory where the Windows I/O Emulation layer stores its shared state data (files, events, mutexes, pipes).  By default Mono will store the &quot;.wapi&quot; directory in the users's home directory.</dd>
</dl>
<dl>
<dt>
<b>MONO_SHARED_HOSTNAME</b></dt>
<dd>
Uses the string value of this variable as a replacement for the host name when creating file names in the &quot;.wapi&quot; directory. This helps if the host name of your machine is likely to be changed when a mono application is running or if you have a .wapi directory shared among several different computers. Mono typically uses the hostname to create the files that are used to share state across multiple Mono processes.  This is done to support home directories that might be shared over the network.</dd>
</dl>
<dl>
<dt>
<b>MONO_STRICT_IO_EMULATION</b></dt>
<dd>
If set, extra checks are made during IO operations.  Currently, this includes only advisory locks around file writes.</dd>
</dl>
<dl>
<dt>
<b>MONO_THEME</b></dt>
<dd>
The name of the theme to be used by Windows.Forms.   Available themes today include &quot;clearlooks&quot;, &quot;nice&quot; and &quot;win32&quot;. The default is &quot;win32&quot;.</dd>
</dl>
<dl>
<dt>
<b>MONO_TLS_SESSION_CACHE_TIMEOUT</b></dt>
<dd>
The time, in seconds, that the SSL/TLS session cache will keep it's entry to avoid a new negotiation between the client and a server. Negotiation are very CPU intensive so an application-specific custom value may prove useful for small embedded systems. The default is 180 seconds.</dd>
</dl>
<dl>
<dt>
<b>MONO_THREADS_PER_CPU</b></dt>
<dd>
The minimum number of threads in the general threadpool will be MONO_THREADS_PER_CPU * number of CPUs. The default value for this variable is 1.</dd>
</dl>
<dl>
<dt>
<b>MONO_XMLSERIALIZER_THS</b></dt>
<dd>
Controls the threshold for the XmlSerializer to produce a custom serializer for a given class instead of using the Reflection-based interpreter.  The possible values are `no' to disable the use of a custom serializer or a number to indicate when the XmlSerializer should start serializing.   The default value is 50, which means that the a custom serializer will be produced on the 50th use.</dd>
</dl>
<dl>
<dt>
<b>MONO_X509_REVOCATION_MODE</b></dt>
<dd>
Sets the revocation mode used when validating a X509 certificate chain (https, ftps, smtps...).  The default is 'nocheck', which performs no revocation check at all. The other possible values are 'offline', which performs CRL check (not implemented yet) and 'online' which uses OCSP and CRL to verify the revocation status (not implemented yet).</dd>
</dl>
</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES FOR DEBUGGING</h1><dl>
<dt>
<b>MONO_ASPNET_NODELETE</b></dt>
<dd>
If set to any value, temporary source files generated by ASP.NET support classes will not be removed. They will be kept in the user's temporary directory.</dd>
</dl>
<dl>
<dt>
<b>MONO_DEBUG</b></dt>
<dd>
If set, enables some features of the runtime useful for debugging. This variable should contain a comma separated list of debugging options. Currently, the following options are supported:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>break-on-unverified</b></dt>
<dd>
If this variable is set, when the Mono VM runs into a verification problem, instead of throwing an exception it will break into the debugger.  This is useful when debugging verifier problems</dd>
</dl>
<dl>
<dt>
<b>casts</b></dt>
<dd>
This option can be used to get more detailed information from InvalidCast exceptions, it will provide information about the types involved.</dd>
</dl>
<dl>
<dt>
<b>collect-pagefault-stats</b></dt>
<dd>
Collects information about pagefaults.   This is used internally to track the number of page faults produced to load metadata.  To display this information you must use this option with &quot;--stats&quot; command line option.</dd>
</dl>
<dl>
<dt>
<b>dont-free-domains</b></dt>
<dd>
This is an Optimization for multi-AppDomain applications (most commonly ASP.NET applications).  Due to internal limitations Mono, Mono by default does not use typed allocations on multi-appDomain applications as they could leak memory when a domain is unloaded. Although this is a fine default, for applications that use more than on AppDomain heavily (for example, ASP.NET applications) it is worth trading off the small leaks for the increased performance (additionally, since ASP.NET applications are not likely going to unload the application domains on production systems, it is worth using this feature).</dd>
</dl>
<dl>
<dt>
<b>dyn-runtime-invoke</b></dt>
<dd>
Instructs the runtime to try to use a generic runtime-invoke wrapper instead of creating one invoke wrapper.</dd>
</dl>
<dl>
<dt>
<b>gdb</b></dt>
<dd>
Equivalent to setting the <b>MONO_XDEBUG</b> variable, this emits symbols into a shared library as the code is JITed that can be loaded into GDB to inspect symbols.</dd>
</dl>
<dl>
<dt>
<b>gen-seq-points</b></dt>
<dd>
Automatically generates sequence points where the IL stack is empty.  These are places where the debugger can set a breakpoint.</dd>
</dl>
<dl>
<dt>
<b>explicit-null-checks</b></dt>
<dd>
Makes the JIT generate an explicit NULL check on variable dereferences instead of depending on the operating system to raise a SIGSEGV or another form of trap event when an invalid memory location is accessed.</dd>
</dl>
<dl>
<dt>
<b>handle-sigint</b></dt>
<dd>
Captures the interrupt signal (Control-C) and displays a stack trace when pressed.  Useful to find out where the program is executing at a given point.  This only displays the stack trace of a single thread.</dd>
</dl>
<dl>
<dt>
<b>init-stacks</b></dt>
<dd>
Instructs the runtime to initialize the stack with some known values (0x2a on x86-64) at the start of a method to assist in debuggin the JIT engine.</dd>
</dl>
<dl>
<dt>
<b>keep-delegates</b></dt>
<dd>
This option will leak delegate trampolines that are no longer referenced as to present the user with more information about a delegate misuse.  Basically a delegate instance might be created, passed to unmanaged code, and no references kept in managed code, which will garbage collect the code.  With this option it is possible to track down the source of the problems.</dd>
</dl>
<dl>
<dt>
<b>reverse-pinvoke-exceptions</b></dt>
<dd>
This option will cause mono to abort with a descriptive message when during stack unwinding after an exception it reaches a native stack frame. This happens when a managed delegate is passed to native code, and the managed delegate throws an exception. Mono will normally try to unwind the stack to the first (managed) exception handler, and it will skip any native stack frames in the process. This leads to undefined behaviour (since mono doesn't know how to process native frames), leaks, and possibly crashes too.</dd>
</dl>
<dl>
<dt>
<b>no-gdb-backtrace</b></dt>
<dd>
This option will disable the GDB backtrace emitted by the runtime after a SIGSEGV or SIGABRT in unmanaged code.</dd>
</dl>
<dl>
<dt>
<b>suspend-on-sigsegv</b></dt>
<dd>
This option will suspend the program when a native SIGSEGV is received. This is useful for debugging crashes which do not happen under gdb, since a live process contains more information than a core file.</dd>
</dl>
<dl>
<dt>
<b>check-pinvoke-callconv</b></dt>
<dd>
This option causes the runtime to check for calling convention mismatches when using pinvoke, i.e. mixing cdecl/stdcall. It only works on windows. If a mismatch is detected, an ExecutionEngineException is thrown.</dd>
</dl>
</div>
<dl>
<dt>
<b>MONO_LOG_LEVEL</b></dt>
<dd>
The logging level, possible values are `error', `critical', `warning', `message', `info' and `debug'.  See the DEBUGGING section for more details.</dd>
</dl>
<dl>
<dt>
<b>MONO_LOG_MASK</b></dt>
<dd>
Controls the domain of the Mono runtime that logging will apply to. If set, the log mask is changed to the set value. Possible values are &quot;asm&quot; (assembly loader), &quot;type&quot;, &quot;dll&quot; (native library loader), &quot;gc&quot; (garbage collector), &quot;cfg&quot; (config file loader), &quot;aot&quot; (precompiler), &quot;security&quot; (e.g. Moonlight CoreCLR support) and &quot;all&quot;. The default value is &quot;all&quot;. Changing the mask value allows you to display only messages for a certain component. You can use multiple masks by comma separating them. For example to see config file messages and assembly loader messages set you mask to &quot;asm,cfg&quot;.</dd>
</dl>
<dl>
<dt>
<b>MONO_TRACE</b></dt>
<dd>
Used for runtime tracing of method calls. The format of the comma separated trace options is:<div class="spacer">
</div>
<br/>
	[-]M:method name<br/>
	[-]N:namespace<br/>
	[-]T:class name<br/>
	[-]all<br/>
	[-]program<br/>
	disabled		Trace output off upon start.<div class="spacer">
</div>
<br/>
You can toggle trace output on/off sending a SIGUSR2 signal to the program.</dd>
</dl>
<dl>
<dt>
<b>MONO_TRACE_LISTENER</b></dt>
<dd>
If set, enables the System.Diagnostics.DefaultTraceListener, which will print the output of the System.Diagnostics Trace and Debug classes. It can be set to a filename, and to Console.Out or Console.Error to display output to standard output or standard error, respectively. If it's set to Console.Out or Console.Error you can append an optional prefix that will be used when writing messages like this: Console.Error:MyProgramName. See the System.Diagnostics.DefaultTraceListener documentation for more information.</dd>
</dl>
<dl>
<dt>
<b>MONO_WCF_TRACE</b></dt>
<dd>
This eases WCF diagnostics functionality by simply outputs all log messages from WCF engine to &quot;stdout&quot;, &quot;stderr&quot; or any file passed to this environment variable. The log format is the same as usual diagnostic output.</dd>
</dl>
<dl>
<dt>
<b>MONO_XEXCEPTIONS</b></dt>
<dd>
This throws an exception when a X11 error is encountered; by default a message is displayed but execution continues</dd>
</dl>
<dl>
<dt>
<b>MONO_XMLSERIALIZER_DEBUG</b></dt>
<dd>
Set this value to 1 to prevent the serializer from removing the temporary files that are created for fast serialization;  This might be useful when debugging.</dd>
</dl>
<dl>
<dt>
<b>MONO_XSYNC</b></dt>
<dd>
This is used in the System.Windows.Forms implementation when running with the X11 backend.  This is used to debug problems in Windows.Forms as it forces all of the commands send to X11 server to be done synchronously.   The default mode of operation is asynchronous which makes it hard to isolate the root of certain problems.</dd>
</dl>
<dl>
<dt>
<b>MONO_GENERIC_SHARING</b></dt>
<dd>
This environment variable controls the kind of generic sharing used. This variable is used by internal JIT developers and should not be changed in production.  Do not use it. The variable controls which classes will have generic code sharing enabled. Permissible values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<i>all</i></dt>
<dd>
All generated code can be shared.</dd>
</dl>
<dl>
<dt>
<i>collections</i></dt>
<dd>
Only the classes in System.Collections.Generic will have its code shared (this is the default value).</dd>
</dl>
<dl>
<dt>
<i>corlib</i></dt>
<dd>
Only code in corlib will have its code shared.</dd>
</dl>
<dl>
<dt>
<i>none</i></dt>
<dd>
No generic code sharing will be performed.</dd>
</dl>
</div>
Generic code sharing by default only applies to collections.   The Mono JIT by default turns this on.<dl>
<dt>
<b>MONO_XDEBUG</b></dt>
<dd>
When the the MONO_XDEBUG env var is set, debugging info for JITted code is emitted into a shared library, loadable into gdb. This enables, for example, to see managed frame names on gdb backtraces.</dd>
</dl>
<dl>
<dt>
<b>MONO_VERBOSE_METHOD</b></dt>
<dd>
Enables the maximum JIT verbosity for the specified method. This is very helpfull to diagnose a miscompilation problems of a specific method.</dd>
</dl>
<dl>
<dt>
<b>MONO_VERBOSE_HWCAP</b></dt>
<dd>
If set, makes the JIT output information about detected CPU features (such as SSE, CMOV, FCMOV, etc) to stdout.</dd>
</dl>
<dl>
<dt>
<b>MONO_CONSERVATIVE_HWCAP</b></dt>
<dd>
If set, the JIT will not perform any hardware capability detection. This may be useful to pinpoint the cause of JIT issues. This is the default when Mono is built as an AOT cross compiler, so that the generated code will run on most hardware.</dd>
</dl>
</div>
<div class="section">
<h1>VALGRIND</h1> If you want to use Valgrind, you will find the file `mono.supp' useful, it contains the suppressions for the GC which trigger incorrect warnings.  Use it like this:<br/>
    valgrind --suppressions=mono.supp mono ...<br/>
</div>
<div class="section">
<h1>DTRACE</h1> On some platforms, Mono can expose a set of DTrace probes (also known as user-land statically defined, USDT Probes).<dl>
<dt>
They are defined in the file `mono.d'.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>ves-init-begin, ves-init-end</b></dt>
<dd>
Begin and end of runtime initialization.</dd>
</dl>
<dl>
<dt>
<b>method-compile-begin, method-compile-end</b></dt>
<dd>
Begin and end of method compilation. The probe arguments are class name, method name and signature, and in case of method-compile-end success or failure of compilation.</dd>
</dl>
<dl>
<dt>
<b>gc-begin, gc-end</b></dt>
<dd>
Begin and end of Garbage Collection.</dd>
</dl>
<dl>
<dt>
To verify the availability of the probes, run:</dt>
<dd>
<br/>
    dtrace -P mono'$target' -l -c mono<br/>
</dd>
</dl>
</div>
<div class="section">
<h1>PERMISSIONS</h1> Mono's Ping implementation for detecting network reachability can create the ICMP packets itself without requiring the system ping command to do the work.  If you want to enable this on Linux for non-root users, you need to give the Mono binary special permissions.<div class="spacer">
</div>
As root, run this command:<br/>
   # setcap cap_net_raw=+ep /usr/bin/mono<br/>
</div>
<div class="section">
<h1>FILES</h1> On Unix assemblies are loaded from the installation lib directory.  If you set `prefix' to /usr, the assemblies will be located in /usr/lib.  On Windows, the assemblies are loaded from the directory where mono and mint live.<dl>
<dt>
<b>~/.mono/aot-cache</b></dt>
<dd>
The directory for the ahead-of-time compiler demand creation assemblies are located.</dd>
</dl>
<dl>
<dt>
<b>/etc/mono/config, ~/.mono/config</b></dt>
<dd>
Mono runtime configuration file.  See the mono-config(5) manual page for more information.</dd>
</dl>
<dl>
<dt>
<b>~/.config/.mono/certs, /usr/share/.mono/certs</b></dt>
<dd>
Contains Mono certificate stores for users / machine. See the certmgr(1) manual page for more information on managing certificate stores and the mozroots(1) page for information on how to import the Mozilla root certificates into the Mono certificate store.</dd>
</dl>
<dl>
<dt>
<b>~/.mono/assemblies/ASSEMBLY/ASSEMBLY.config</b></dt>
<dd>
Files in this directory allow a user to customize the configuration for a given system assembly, the format is the one described in the mono-config(5) page.</dd>
</dl>
<dl>
<dt>
<b>~/.config/.mono/keypairs, /usr/share/.mono/keypairs</b></dt>
<dd>
Contains Mono cryptographic keypairs for users / machine. They can be accessed by using a CspParameters object with DSACryptoServiceProvider and RSACryptoServiceProvider classes.</dd>
</dl>
<dl>
<dt>
<b>~/.config/.isolatedstorage, ~/.local/share/.isolatedstorage, /usr/share/.isolatedstorage</b></dt>
<dd>
Contains Mono isolated storage for non-roaming users, roaming users and local machine. Isolated storage can be accessed using the classes from the System.IO.IsolatedStorage namespace.</dd>
</dl>
<dl>
<dt>
<b>&lt;assembly&gt;.config</b></dt>
<dd>
Configuration information for individual assemblies is loaded by the runtime from side-by-side files with the .config files, see the http://www.mono-project.com/Config for more information.</dd>
</dl>
<dl>
<dt>
<b>Web.config, web.config</b></dt>
<dd>
ASP.NET applications are configured through these files, the configuration is done on a per-directory basis.  For more information on this subject see the http://www.mono-project.com/Config_system.web page.</dd>
</dl>
</div>
<div class="section">
<h1>MAILING LISTS</h1> Mailing lists are listed at the http://www.mono-project.com/community/help/mailing-lists/</div>
<div class="section">
<h1>WEB SITE</h1> http://www.mono-project.com</div>
<div class="section">
<h1>SEE ALSO</h1> certmgr(1), csharp(1), mcs(1), mdb(1), monocov(1), monodis(1), mono-config(5), mozroots(1), mprof-report(1), pdb2mdb(1), xsp(1), mod_mono(8).<div class="spacer">
</div>
For more information on AOT: http://www.mono-project.com/docs/advanced/aot/<div class="spacer">
</div>
For ASP.NET-related documentation, see the xsp(1) manual page</div>
<table class="foot">
<tr>
<td class="foot-date">
</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

