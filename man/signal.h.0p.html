<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
signal.h(0P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
signal.h(0P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
signal.h(0P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>NAME</h1> signal.h &#8212; signals</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
#include &lt;signal.h&gt;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Some of the functionality described on this reference page extends the ISO&#160;C standard. Applications shall define the appropriate feature test macro (see the System Interfaces volume of POSIX.1&#8208;2008, <i>Section 2.2</i>, <i>The Compilation Environment</i>) to enable the visibility of these symbols in this header.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the following macros, which shall expand to constant expressions with distinct values that have a type compatible with the second argument to, and the return value of, the  <i>signal</i>() function, and whose values shall compare unequal to the address of any declarable function.<dl>
<dt>
SIG_DFL</dt>
<dd>
Request for default signal handling.</dd>
</dl>
<dl>
<dt>
SIG_ERR</dt>
<dd>
Return value from  <i>signal</i>() in case of error.</dd>
</dl>
<dl>
<dt>
SIG_HOLD</dt>
<dd>
Request that signal be held.</dd>
</dl>
<dl>
<dt>
SIG_IGN</dt>
<dd>
Request that signal be ignored.</dd>
</dl>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>pthread_t</b>, <b>size_t</b>, and <b>uid_t</b> types as described in <i>&lt;sys/types.h&gt;</i>.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>timespec</b> structure as described in <i>&lt;time.h&gt;</i>.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the following data types:<dl>
<dt>
<b>sig_atomic_t</b></dt>
<dd>
Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the presence of asynchronous interrupts.</dd>
</dl>
<dl>
<dt>
<b>sigset_t</b></dt>
<dd>
Integer or structure type of an object used to represent sets of signals.</dd>
</dl>
<dl>
<dt>
<b>pid_t</b></dt>
<dd>
As described in <i>&lt;sys/types.h&gt;</i>.</dd>
</dl>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>pthread_attr_t</b> type as described in <i>&lt;sys/types.h&gt;</i>.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>sigevent</b> structure, which shall include at least the following members:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>int              sigev_notify            </b>Notification type.<b></b><br/>
<b>int              sigev_signo             </b>Signal number.<b></b><br/>
<b>union sigval     sigev_value             </b>Signal value.<b></b><br/>
<b>void           (*sigev_notify_function)(union sigval)</b><br/>
<b>                                         </b>Notification function.<b></b><br/>
<b>pthread_attr_t *sigev_notify_attributes  </b>Notification attributes.<b></b><br/>
</div>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the following symbolic constants for the values of <i>sigev_notify</i>:<dl>
<dt>
SIGEV_NONE</dt>
<dd>
No asynchronous notification is delivered when the event of interest occurs.</dd>
</dl>
<dl>
<dt>
SIGEV_SIGNAL</dt>
<dd>
A queued signal, with an application-defined value, is generated when the event of interest occurs.</dd>
</dl>
<dl>
<dt>
SIGEV_THREAD</dt>
<dd>
A notification function is called to perform notification.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <b>sigval</b> union shall be defined as:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>int    sival_int    </b>Integer signal value.<b></b><br/>
<b>void  *sival_ptr    </b>Pointer signal value.<b></b><br/>
</div>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall declare the SIGRTMIN and SIGRTMAX macros, which shall expand to positive integer expressions with type <b>int</b>, but which need not be constant expressions. These macros specify a range of signal numbers that are reserved for application use and for which the realtime signal behavior specified in this volume of POSIX.1&#8208;2008 is supported. The signal numbers in this range do not overlap any of the signals specified in the following table.<div class="spacer">
</div>
The range SIGRTMIN through SIGRTMAX inclusive shall include at least {RTSIG_MAX} signal numbers.<div class="spacer">
</div>
It is implementation-defined whether realtime signal behavior is supported for other signals.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the following macros that are used to refer to the signals that occur in the system. Signals defined here begin with the letters SIG followed by an uppercase letter. The macros shall expand to positive integer constant expressions with type <b>int</b> and distinct values. The value 0 is reserved for use as the null signal (see  <i>kill</i>()). Additional implementation-defined signals may occur in the system.<div class="spacer">
</div>
The ISO&#160;C standard only requires the signal names SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, and SIGTERM to be defined.<div class="spacer">
</div>
The following signals shall be supported on all implementations (default actions are explained below the table):<table class="tbl">
<col style="width: 9.00ex;"/>
<col style="width: 16.00ex;"/>
<col style="width: 50.00ex;"/>
<tbody>
<tr>
<td>
Signal</td>
<td>
Default Action</td>
<td>
Description</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGABRT</td>
<td>
A</td>
<td>
Process abort signal.</td>
</tr>
<tr>
<td>
SIGALRM</td>
<td>
T</td>
<td>
Alarm clock.</td>
</tr>
<tr>
<td>
SIGBUS</td>
<td>
A</td>
<td>
Access to an undefined portion of a memory object.</td>
</tr>
<tr>
<td>
SIGCHLD</td>
<td>
I</td>
<td>
Child process terminated, stopped,</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
or continued.</td>
</tr>
<tr>
<td>
SIGCONT</td>
<td>
C</td>
<td>
Continue executing, if stopped.</td>
</tr>
<tr>
<td>
SIGFPE</td>
<td>
A</td>
<td>
Erroneous arithmetic operation.</td>
</tr>
<tr>
<td>
SIGHUP</td>
<td>
T</td>
<td>
Hangup.</td>
</tr>
<tr>
<td>
SIGILL</td>
<td>
A</td>
<td>
Illegal instruction.</td>
</tr>
<tr>
<td>
SIGINT</td>
<td>
T</td>
<td>
Terminal interrupt signal.</td>
</tr>
<tr>
<td>
SIGKILL</td>
<td>
T</td>
<td>
Kill (cannot be caught or ignored).</td>
</tr>
<tr>
<td>
SIGPIPE</td>
<td>
T</td>
<td>
Write on a pipe with no one to read it.</td>
</tr>
<tr>
<td>
SIGQUIT</td>
<td>
A</td>
<td>
Terminal quit signal.</td>
</tr>
<tr>
<td>
SIGSEGV</td>
<td>
A</td>
<td>
Invalid memory reference.</td>
</tr>
<tr>
<td>
SIGSTOP</td>
<td>
S</td>
<td>
Stop executing (cannot be caught or ignored).</td>
</tr>
<tr>
<td>
SIGTERM</td>
<td>
T</td>
<td>
Termination signal.</td>
</tr>
<tr>
<td>
SIGTSTP</td>
<td>
S</td>
<td>
Terminal stop signal.</td>
</tr>
<tr>
<td>
SIGTTIN</td>
<td>
S</td>
<td>
Background process attempting read.</td>
</tr>
<tr>
<td>
SIGTTOU</td>
<td>
S</td>
<td>
Background process attempting write.</td>
</tr>
<tr>
<td>
SIGUSR1</td>
<td>
T</td>
<td>
User-defined signal 1.</td>
</tr>
<tr>
<td>
SIGUSR2</td>
<td>
T</td>
<td>
User-defined signal 2.</td>
</tr>
<tr>
<td>
SIGPOLL</td>
<td>
T</td>
<td>
Pollable event.</td>
</tr>
<tr>
<td>
SIGPROF</td>
<td>
T</td>
<td>
Profiling timer expired.</td>
</tr>
<tr>
<td>
SIGSYS</td>
<td>
A</td>
<td>
Bad system call.</td>
</tr>
<tr>
<td>
SIGTRAP</td>
<td>
A</td>
<td>
Trace/breakpoint trap.</td>
</tr>
<tr>
<td>
SIGURG</td>
<td>
I</td>
<td>
High bandwidth data is available at a socket.</td>
</tr>
<tr>
<td>
SIGVTALRM</td>
<td>
T</td>
<td>
Virtual timer expired.</td>
</tr>
<tr>
<td>
SIGXCPU</td>
<td>
A</td>
<td>
CPU time limit exceeded.</td>
</tr>
<tr>
<td>
SIGXFSZ</td>
<td>
A</td>
<td>
File size limit exceeded.</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
The default actions are as follows:<dl>
<dt>
T</dt>
<dd>
Abnormal termination of the process.</dd>
</dl>
<dl>
<dt>
A</dt>
<dd>
Abnormal termination of the process with additional actions.</dd>
</dl>
<dl>
<dt>
I</dt>
<dd>
Ignore the signal.</dd>
</dl>
<dl>
<dt>
S</dt>
<dd>
Stop the process.</dd>
</dl>
<dl>
<dt>
C</dt>
<dd>
Continue the process, if it is stopped; otherwise, ignore the signal.</dd>
</dl>
<div class="spacer">
</div>
The effects on the process in each case are described in the System Interfaces volume of POSIX.1&#8208;2008, <i>Section 2.4.3</i>, <i>Signal Actions</i>.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall declare the <b>sigaction</b> structure, which shall include at least the following members:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>void   (*sa_handler)(int)  </b>Pointer to a signal-catching function<br/>
                           or one of the SIG_IGN or SIG_DFL.<br/>
sigset_t sa_mask           Set of signals to be blocked during execution<br/>
                           of the signal handling function.<br/>
int      sa_flags          Special flags.<br/>
void   (*sa_sigaction)(int, siginfo_t *, void *)<br/>
                           Pointer to a signal-catching function.<br/>
</div>
<div class="spacer">
</div>
The storage occupied by <i>sa_handler</i> and <i>sa_sigaction</i> may overlap, and a conforming application shall not use both simultaneously.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the following macros which shall expand to integer constant expressions that need not be usable in <b>#if</b> preprocessing directives:<dl>
<dt>
SIG_BLOCK</dt>
<dd>
The resulting set is the union of the current set and the signal set pointed to by the argument <i>set</i>.</dd>
</dl>
<dl>
<dt>
SIG_UNBLOCK</dt>
<dd>
The resulting set is the intersection of the current set and the complement of the signal set pointed to by the argument <i>set</i>.</dd>
</dl>
<dl>
<dt>
SIG_SETMASK</dt>
<dd>
The resulting set is the signal set pointed to by the argument <i>set</i>.</dd>
</dl>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall also define the following symbolic constants:<dl>
<dt>
SA_NOCLDSTOP</dt>
<dd>
Do not generate SIGCHLD when children stop<div style="height: 0.00em;">
&#160;</div>
or stopped children continue.</dd>
</dl>
<dl>
<dt>
SA_ONSTACK</dt>
<dd>
Causes signal delivery to occur on an alternate stack.</dd>
</dl>
<dl>
<dt>
SA_RESETHAND</dt>
<dd>
Causes signal dispositions to be set to SIG_DFL on entry to signal handlers.</dd>
</dl>
<dl>
<dt>
SA_RESTART</dt>
<dd>
Causes certain functions to become restartable.</dd>
</dl>
<dl>
<dt>
SA_SIGINFO</dt>
<dd>
Causes extra information to be passed to signal handlers at the time of receipt of a signal.</dd>
</dl>
<dl>
<dt>
SA_NOCLDWAIT</dt>
<dd>
Causes implementations not to create zombie processes on child death.</dd>
</dl>
<dl>
<dt>
SA_NODEFER</dt>
<dd>
Causes signal not to be automatically blocked on entry to signal handler.</dd>
</dl>
<dl>
<dt>
SS_ONSTACK</dt>
<dd>
Process is executing on an alternate signal stack.</dd>
</dl>
<dl>
<dt>
SS_DISABLE</dt>
<dd>
Alternate signal stack is disabled.</dd>
</dl>
<dl>
<dt>
MINSIGSTKSZ</dt>
<dd>
Minimum stack size for a signal handler.</dd>
</dl>
<dl>
<dt>
SIGSTKSZ</dt>
<dd>
Default size in bytes for the alternate signal stack.</dd>
</dl>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>mcontext_t</b> type through <b>typedef</b>.<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>ucontext_t</b> type as a structure that shall include at least the following members:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>ucontext_t *uc_link     </b>Pointer to the context that is resumed<br/>
                        when this context returns.<br/>
sigset_t    uc_sigmask  The set of signals that are blocked when this<br/>
                        context is active.<br/>
stack_t     uc_stack    The stack used by this context.<br/>
mcontext_t  uc_mcontext A machine-specific representation of the saved<br/>
                        context.<br/>
</div>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>stack_t</b> type as a structure, which shall include at least the following members:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>void     *ss_sp       </b>Stack base or pointer.<br/>
size_t    ss_size     Stack size.<br/>
int       ss_flags    Flags.<br/>
</div>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the <b>siginfo_t</b> type as a structure, which shall include at least the following members:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>int           si_signo  </b>Signal number.<br/>
int           si_code   Signal code.<br/>
int           si_errno  If non-zero, an <i>errno</i> value associated with<br/>
                        this signal, as described in <b>&lt;errno.h&gt;</b>.<br/>
pid_t         si_pid    Sending process ID.<br/>
uid_t         si_uid    Real user ID of sending process.<br/>
void         *si_addr   Address of faulting instruction.<br/>
int           si_status Exit value or signal.<br/>
long          si_band   Band event for SIGPOLL.<br/>
union sigval  si_value  Signal value.<br/>
</div>
<div class="spacer">
</div>
The <i>&lt;signal.h&gt;</i> header shall define the symbolic constants in the <b>Code</b> column of the following table for use as values of <i>si_code</i> that are signal-specific or non-signal-specific reasons why the signal was generated.<table class="tbl">
<col style="width: 7.00ex;"/>
<col style="width: 13.00ex;"/>
<col style="width: 75.00ex;"/>
<tbody>
<tr>
<td>
Signal</td>
<td>
Code</td>
<td>
Reason</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGILL</td>
<td>
ILL_ILLOPC</td>
<td>
Illegal opcode.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_ILLOPN</td>
<td>
Illegal operand.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_ILLADR</td>
<td>
Illegal addressing mode.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_ILLTRP</td>
<td>
Illegal trap.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_PRVOPC</td>
<td>
Privileged opcode.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_PRVREG</td>
<td>
Privileged register.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_COPROC</td>
<td>
Coprocessor error.</td>
</tr>
<tr>
<td>
</td>
<td>
ILL_BADSTK</td>
<td>
Internal stack error.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGFPE</td>
<td>
FPE_INTDIV</td>
<td>
Integer divide by zero.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_INTOVF</td>
<td>
Integer overflow.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTDIV</td>
<td>
Floating-point divide by zero.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTOVF</td>
<td>
Floating-point overflow.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTUND</td>
<td>
Floating-point underflow.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTRES</td>
<td>
Floating-point inexact result.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTINV</td>
<td>
Invalid floating-point operation.</td>
</tr>
<tr>
<td>
</td>
<td>
FPE_FLTSUB</td>
<td>
Subscript out of range.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGSEGV</td>
<td>
SEGV_MAPERR</td>
<td>
Address not mapped to object.</td>
</tr>
<tr>
<td>
</td>
<td>
SEGV_ACCERR</td>
<td>
Invalid permissions for mapped object.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGBUS</td>
<td>
BUS_ADRALN</td>
<td>
Invalid address alignment.</td>
</tr>
<tr>
<td>
</td>
<td>
BUS_ADRERR</td>
<td>
Nonexistent physical address.</td>
</tr>
<tr>
<td>
</td>
<td>
BUS_OBJERR</td>
<td>
Object-specific hardware error.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGTRAP</td>
<td>
TRAP_BRKPT</td>
<td>
Process breakpoint.</td>
</tr>
<tr>
<td>
</td>
<td>
TRAP_TRACE</td>
<td>
Process trace trap.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGCHLD</td>
<td>
CLD_EXITED</td>
<td>
Child has exited.</td>
</tr>
<tr>
<td>
</td>
<td>
CLD_KILLED</td>
<td>
Child has terminated abnormally and did not create a <b>core</b> file.</td>
</tr>
<tr>
<td>
</td>
<td>
CLD_DUMPED</td>
<td>
Child has terminated abnormally and created a <b>core</b> file.</td>
</tr>
<tr>
<td>
</td>
<td>
CLD_TRAPPED</td>
<td>
Traced child has trapped.</td>
</tr>
<tr>
<td>
</td>
<td>
CLD_STOPPED</td>
<td>
Child has stopped.</td>
</tr>
<tr>
<td>
</td>
<td>
CLD_CONTINUED</td>
<td>
Stopped child has continued.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGPOLL</td>
<td>
POLL_IN</td>
<td>
Data input available.</td>
</tr>
<tr>
<td>
</td>
<td>
POLL_OUT</td>
<td>
Output buffers available.</td>
</tr>
<tr>
<td>
</td>
<td>
POLL_MSG</td>
<td>
Input message available.</td>
</tr>
<tr>
<td>
</td>
<td>
POLL_ERR</td>
<td>
I/O error.</td>
</tr>
<tr>
<td>
</td>
<td>
POLL_PRI</td>
<td>
High priority input available.</td>
</tr>
<tr>
<td>
</td>
<td>
POLL_HUP</td>
<td>
Device disconnected.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
Any</td>
<td>
SI_USER</td>
<td>
Signal sent by <i>kill</i>().</td>
</tr>
<tr>
<td>
</td>
<td>
SI_QUEUE</td>
<td>
Signal sent by <i>sigqueue</i>().</td>
</tr>
<tr>
<td>
</td>
<td>
SI_TIMER</td>
<td>
Signal generated by expiration of a timer set by <i>timer_settime</i>().</td>
</tr>
<tr>
<td>
</td>
<td>
SI_ASYNCIO</td>
<td>
Signal generated by completion of an asynchronous I/O</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
request.</td>
</tr>
<tr>
<td>
</td>
<td>
SI_MESGQ</td>
<td>
Signal generated by arrival of a message on an empty message</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
queue.</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
Implementations may support additional <i>si_code</i> values not included in this list, may generate values included in this list under circumstances other than those described in this list, and may contain extensions or limitations that prevent some values from being generated. Implementations do not generate a different value from the ones described in this list for circumstances described in this list.<div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
In addition, the following signal-specific information shall be available:<table class="tbl">
<col style="width: 7.00ex;"/>
<col style="width: 20.00ex;"/>
<col style="width: 49.00ex;"/>
<tbody>
<tr>
<td>
Signal</td>
<td>
Member</td>
<td>
Value</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGILL</td>
<td>
void * <i>si_addr</i></td>
<td>
Address of faulting instruction.</td>
</tr>
<tr>
<td>
SIGFPE</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGSEGV</td>
<td>
void * <i>si_addr</i></td>
<td>
Address of faulting memory reference.</td>
</tr>
<tr>
<td>
SIGBUS</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGCHLD</td>
<td>
pid_t <i>si_pid</i></td>
<td>
Child process ID.</td>
</tr>
<tr>
<td>
</td>
<td>
int <i>si_status</i></td>
<td>
Exit value or signal.</td>
</tr>
<tr>
<td>
</td>
<td>
uid_t <i>si_uid</i></td>
<td>
Real user ID of the process that sent the signal.</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
SIGPOLL</td>
<td>
long <i>si_band</i></td>
<td>
Band event for POLL_IN, POLL_OUT, or POLL_MSG.</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
For some implementations, the value of <i>si_addr</i> may be inaccurate.<div class="spacer">
</div>
The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>int    kill(pid_t, int);</b><br/>
<b>int    killpg(pid_t, int);</b><br/>
<b>void   psiginfo(const siginfo_t *, const char *);</b><br/>
<b>void   psignal(int, const char *);</b><br/>
<b>int    pthread_kill(pthread_t, int);</b><br/>
<b>int    pthread_sigmask(int, const sigset_t *restrict,</b><br/>
<b>           sigset_t *restrict);</b><br/>
<b>int    raise(int);</b><br/>
<b>int    sigaction(int, const struct sigaction *restrict,</b><br/>
<b>           struct sigaction *restrict);</b><br/>
<b>int    sigaddset(sigset_t *, int);</b><br/>
<b>int    sigaltstack(const stack_t *restrict, stack_t *restrict);</b><br/>
<b>int    sigdelset(sigset_t *, int);</b><br/>
<b>int    sigemptyset(sigset_t *);</b><br/>
<b>int    sigfillset(sigset_t *);</b><br/>
<b>int    sighold(int);</b><br/>
<b>int    sigignore(int);</b><br/>
<b>int    siginterrupt(int, int);</b><br/>
<b>int    sigismember(const sigset_t *, int);</b><br/>
<b>void (*signal(int, void (*)(int)))(int);</b><br/>
<b>int    sigpause(int);</b><br/>
<b>int    sigpending(sigset_t *);</b><br/>
<b>int    sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);</b><br/>
<b>int    sigqueue(pid_t, int, const union sigval);</b><br/>
<b>int    sigrelse(int);</b><br/>
<b>void (*sigset(int, void (*)(int)))(int);</b><br/>
<b>int    sigsuspend(const sigset_t *);</b><br/>
<b>int    sigtimedwait(const sigset_t *restrict, siginfo_t *restrict,</b><br/>
<b>           const struct timespec *restrict);</b><br/>
<b>int    sigwait(const sigset_t *restrict, int *restrict);</b><br/>
<b>int    sigwaitinfo(const sigset_t *restrict, siginfo_t *restrict);</b><br/>
</div>
<div class="spacer">
</div>
Inclusion of the <i>&lt;signal.h&gt;</i> header may make visible all symbols from the <i>&lt;time.h&gt;</i> header.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>APPLICATION USAGE</h1> On systems not supporting the XSI option, the <i>si_pid</i> and <i>si_uid</i> members of <b>siginfo_t</b> are only required to be valid when <i>si_code</i> is SI_USER or SI_QUEUE. On XSI-conforming systems, they are also valid for all <i>si_code</i> values less than or equal to 0; however, it is unspecified whether SI_USER and SI_QUEUE have values less than or equal to zero, and therefore XSI applications should check whether <i>si_code</i> has the value SI_USER or SI_QUEUE or is less than or equal to 0 to tell whether <i>si_pid</i> and <i>si_uid</i> are valid.</div>
<div class="section">
<h1>RATIONALE</h1> None.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> The SIGPOLL and SIGPROF signals may be removed in a future version.</div>
<div class="section">
<h1>SEE ALSO</h1> <i><b>&lt;errno.h&gt;</b></i>, <i><b>&lt;stropts.h&gt;</b></i>, <i><b>&lt;sys_types.h&gt;</b></i>, <i><b>&lt;time.h&gt;</b></i><div class="spacer">
</div>
The System Interfaces volume of POSIX.1&#8208;2008, <i>Section 2.2</i>, <i>The Compilation Environment</i>, <i><i>alarm</i>()</i>, <i><i>ioctl</i>()</i>, <i><i>kill</i>()</i>, <i><i>killpg</i>()</i>, <i><i>psiginfo</i>()</i>, <i><i>pthread_kill</i>()</i>, <i><i>pthread_sigmask</i>()</i>, <i><i>raise</i>()</i>, <i><i>sigaction</i>()</i>, <i><i>sigaddset</i>()</i>, <i><i>sigaltstack</i>()</i>, <i><i>sigdelset</i>()</i>, <i><i>sigemptyset</i>()</i>, <i><i>sigfillset</i>()</i>, <i><i>sighold</i>()</i>, <i><i>siginterrupt</i>()</i>, <i><i>sigismember</i>()</i>, <i><i>signal</i>()</i>, <i><i>sigpending</i>()</i>, <i><i>sigqueue</i>()</i>, <i><i>sigsuspend</i>()</i>, <i><i>sigtimedwait</i>()</i>, <i><i>sigwait</i>()</i>, <i><i>timer_create</i>()</i>, <i><i>wait</i>()</i>, <i><i>waitid</i>()</i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2013 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 7, Copyright (C) 2013 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. (This is POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.) In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.unix.org/online.html .<div style="height: 1.00em;">
&#160;</div>
Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see https://www.kernel.org/doc/man-pages/reporting_bugs.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2013</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

