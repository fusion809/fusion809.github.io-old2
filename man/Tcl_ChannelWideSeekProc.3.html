<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
Tcl_CreateChannel(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Tcl_CreateChannel(3)</td>
<td class="head-vol">
Tcl Library Procedures</td>
<td class="head-rtitle">
Tcl_CreateChannel(3)</td>
</tr>
</tbody>
</table>
<br/>
<br/>
<div class="section">
<h1>NAME</h1> Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode, Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel, Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc, Tcl_ChannelCloseProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc, Tcl_ChannelOutputProc, Tcl_ChannelSeekProc, Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc, Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers, Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and manipulating channels</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<b>#include &lt;tcl.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_Channel<br/>
<b>Tcl_CreateChannel</b>(<i>typePtr, channelName, instanceData, mask</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
ClientData<br/>
<b>Tcl_GetChannelInstanceData</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_ChannelType *<br/>
<b>Tcl_GetChannelType</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
const char *<br/>
<b>Tcl_GetChannelName</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_GetChannelHandle</b>(<i>channel, direction, handlePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_ThreadId<br/>
<b>Tcl_GetChannelThread</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_GetChannelMode</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_GetChannelBufferSize</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
<b>Tcl_SetChannelBufferSize</b>(<i>channel, size</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
<b>Tcl_NotifyChannel</b>(<i>channel, mask</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_BadChannelOption</b>(<i>interp, optionName, optionList</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_IsChannelShared</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_IsChannelRegistered</b>(<i>interp, channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_IsChannelExisting</b>(<i>channelName</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
void<br/>
<b>Tcl_CutChannel</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
void<br/>
<b>Tcl_SpliceChannel</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
void<br/>
<b>Tcl_ClearChannelHandlers</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
int<br/>
<b>Tcl_ChannelBuffered</b>(<i>channel</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
const char *<br/>
<b>Tcl_ChannelName</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_ChannelTypeVersion<br/>
<b>Tcl_ChannelVersion</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverBlockModeProc *<br/>
<b>Tcl_ChannelBlockModeProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverCloseProc *<br/>
<b>Tcl_ChannelCloseProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverClose2Proc *<br/>
<b>Tcl_ChannelClose2Proc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverInputProc *<br/>
<b>Tcl_ChannelInputProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverOutputProc *<br/>
<b>Tcl_ChannelOutputProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverSeekProc *<br/>
<b>Tcl_ChannelSeekProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverWideSeekProc *<br/>
<b>Tcl_ChannelWideSeekProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverThreadActionProc *<br/>
<b>Tcl_ChannelThreadActionProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverTruncateProc *<br/>
<b>Tcl_ChannelTruncateProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverSetOptionProc *<br/>
<b>Tcl_ChannelSetOptionProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverGetOptionProc *<br/>
<b>Tcl_ChannelGetOptionProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverWatchProc *<br/>
<b>Tcl_ChannelWatchProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverGetHandleProc *<br/>
<b>Tcl_ChannelGetHandleProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverFlushProc *<br/>
<b>Tcl_ChannelFlushProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
<br/>
Tcl_DriverHandlerProc *<br/>
<b>Tcl_ChannelHandlerProc</b>(<i>typePtr</i>)<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>ARGUMENTS</h1><dl>
<dt>
const Tcl_ChannelType <i>*typePtr</i> (in)</dt>
<dd>
Points to a structure containing the addresses of procedures that can be called to perform I/O and other functions on the channel.</dd>
</dl>
<dl>
<dt>
const char <i>*channelName</i> (in)</dt>
<dd>
The name of this channel, such as <b>file3</b>; must not be in use by any other channel. Can be NULL, in which case the channel is created without a name.</dd>
</dl>
<dl>
<dt>
ClientData <i>instanceData</i> (in)</dt>
<dd>
Arbitrary one-word value to be associated with this channel.  This value is passed to procedures in  <i>typePtr</i> when they are invoked.</dd>
</dl>
<dl>
<dt>
int <i>mask</i> (in)</dt>
<dd>
OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> to indicate whether a channel is readable and writable.</dd>
</dl>
<dl>
<dt>
Tcl_Channel <i>channel</i> (in)</dt>
<dd>
The channel to operate on.</dd>
</dl>
<dl>
<dt>
int <i>direction</i> (in)</dt>
<dd>
<b>TCL_READABLE</b> means the input handle is wanted; <b>TCL_WRITABLE</b> means the output handle is wanted.</dd>
</dl>
<dl>
<dt>
ClientData <i>*handlePtr</i> (out)</dt>
<dd>
Points to the location where the desired OS-specific handle should be stored.</dd>
</dl>
<dl>
<dt>
int <i>size</i> (in)</dt>
<dd>
The size, in bytes, of buffers to allocate in this channel.</dd>
</dl>
<dl>
<dt>
int <i>mask</i> (in)</dt>
<dd>
An OR-ed combination of <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and  <b>TCL_EXCEPTION</b> that indicates events that have occurred on this channel.</dd>
</dl>
<dl>
<dt>
Tcl_Interp <i>*interp</i> (in)</dt>
<dd>
Current interpreter. (can be NULL)</dd>
</dl>
<dl>
<dt>
const char <i>*optionName</i> (in)</dt>
<dd>
Name of the invalid option.</dd>
</dl>
<dl>
<dt>
const char <i>*optionList</i> (in)</dt>
<dd>
Specific options list (space separated words, without &#8220;-&#8221;) to append to the standard generic options list. Can be NULL for generic options error message only.<div style="height: 1.00em;">
&#160;</div>
<br/>
<br/>
<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Tcl uses a two-layered channel architecture. It provides a generic upper layer to enable C and Tcl programs to perform input and output using the same APIs for a variety of files, devices, sockets etc. The generic C APIs are described in the manual entry for  <b>Tcl_OpenFileChannel</b>.<div class="spacer">
</div>
The lower layer provides type-specific channel drivers for each type of device supported on each platform.  This manual entry describes the C APIs used to communicate between the generic layer and the type-specific channel drivers.  It also explains how new types of channels can be added by providing new channel drivers.<div class="spacer">
</div>
Channel drivers consist of a number of components: First, each channel driver provides a  <b>Tcl_ChannelType</b> structure containing pointers to functions implementing the various operations used by the generic layer to communicate with the channel driver. The  <b>Tcl_ChannelType</b> structure and the functions referenced by it are described in the section  <b>TCL_CHANNELTYPE</b>, below.<div class="spacer">
</div>
Second, channel drivers usually provide a Tcl command to create instances of that type of channel. For example, the Tcl  <b>open</b> command creates channels that use the file and command channel drivers, and the Tcl  <b>socket</b> command creates channels that use TCP sockets for network communication.<div class="spacer">
</div>
Third, a channel driver optionally provides a C function to open channel instances of that type. For example,  <b>Tcl_OpenFileChannel</b> opens a channel that uses the file channel driver, and  <b>Tcl_OpenTcpClient</b> opens a channel that uses the TCP network protocol.  These creation functions typically use  <b>Tcl_CreateChannel</b> internally to open the channel.<div class="spacer">
</div>
To add a new type of channel you must implement a C API or a Tcl command that opens a channel by invoking  <b>Tcl_CreateChannel</b>. When your driver calls  <b>Tcl_CreateChannel</b> it passes in a  <b>Tcl_ChannelType</b> structure describing the driver's I/O procedures. The generic layer will then invoke the functions referenced in that structure to perform operations on the channel.<div class="spacer">
</div>
<b>Tcl_CreateChannel</b> opens a new channel and associates the supplied  <i>typePtr</i> and <i>instanceData</i> with it. The channel is opened in the mode indicated by  <i>mask</i>. For a discussion of channel drivers, their operations and the  <b>Tcl_ChannelType</b> structure, see the section <b>TCL_CHANNELTYPE</b>, below.<div class="spacer">
</div>
<b>Tcl_CreateChannel</b> interacts with the code managing the standard channels. Once a standard channel was initialized either through a call to  <b>Tcl_GetStdChannel</b> or a call to <b>Tcl_SetStdChannel</b> closing this standard channel will cause the next call to  <b>Tcl_CreateChannel</b> to make the new channel the new standard channel too. See  <b>Tcl_StandardChannels</b> for a general treatise about standard channels and the behaviour of the Tcl library with regard to them.<div class="spacer">
</div>
<b>Tcl_GetChannelInstanceData</b> returns the instance data associated with the channel in  <i>channel</i>. This is the same as the <i>instanceData</i> argument in the call to  <b>Tcl_CreateChannel</b> that created this channel.<div class="spacer">
</div>
<b>Tcl_GetChannelType</b> returns a pointer to the <b>Tcl_ChannelType</b> structure used by the channel in the  <i>channel</i> argument. This is the same as the  <i>typePtr</i> argument in the call to  <b>Tcl_CreateChannel</b> that created this channel.<div class="spacer">
</div>
<b>Tcl_GetChannelName</b> returns a string containing the name associated with the channel, or NULL if the  <i>channelName</i> argument to  <b>Tcl_CreateChannel</b> was NULL.<div class="spacer">
</div>
<b>Tcl_GetChannelHandle</b> places the OS-specific device handle associated with  <i>channel</i> for the given <i>direction</i> in the location specified by  <i>handlePtr</i> and returns <b>TCL_OK</b>.  If the channel does not have a device handle for the specified direction, then  <b>TCL_ERROR</b> is returned instead.  Different channel drivers will return different types of handle.  Refer to the manual entries for each driver to determine what type of handle is returned.<div class="spacer">
</div>
<b>Tcl_GetChannelThread</b> returns the id of the thread currently managing the specified  <i>channel</i>. This allows channel drivers to send their file events to the correct event queue even for a multi-threaded core.<div class="spacer">
</div>
<b>Tcl_GetChannelMode</b> returns an OR-ed combination of <b>TCL_READABLE</b> and  <b>TCL_WRITABLE</b>, indicating whether the channel is open for input and output.<div class="spacer">
</div>
<b>Tcl_GetChannelBufferSize</b> returns the size, in bytes, of buffers allocated to store input or output in  <i>channel</i>. If the value was not set by a previous call to  <b>Tcl_SetChannelBufferSize</b>, described below, then the default value of 4096 is returned.<div class="spacer">
</div>
<b>Tcl_SetChannelBufferSize</b> sets the size, in bytes, of buffers that will be allocated in subsequent operations on the channel to store input or output. The  <i>size</i> argument should be between ten and one million, allowing buffers of ten bytes to one million bytes. If  <i>size</i> is outside this range,  <b>Tcl_SetChannelBufferSize</b> sets the buffer size to 4096.<div class="spacer">
</div>
<b>Tcl_NotifyChannel</b> is called by a channel driver to indicate to the generic layer that the events specified by  <i>mask</i> have occurred on the channel.  Channel drivers are responsible for invoking this function whenever the channel handlers need to be called for the channel.  See  <b>WATCHPROC</b> below for more details.<div class="spacer">
</div>
<b>Tcl_BadChannelOption</b> is called from driver specific  <i>setOptionProc</i> or <i>getOptionProc</i> to generate a complete error message.<div class="spacer">
</div>
<b>Tcl_ChannelBuffered</b> returns the number of bytes of input currently buffered in the internal buffer (push back area) of the channel itself. It does not report about the data in the overall buffers for the stack of channels the supplied channel is part of.<div class="spacer">
</div>
<b>Tcl_IsChannelShared</b> checks the refcount of the specified  <i>channel</i> and returns whether the <i>channel</i> was shared among multiple interpreters (result == 1) or not (result == 0).<div class="spacer">
</div>
<b>Tcl_IsChannelRegistered</b> checks whether the specified <i>channel</i> is registered in the given  <i>interp</i>reter (result == 1) or not (result == 0).<div class="spacer">
</div>
<b>Tcl_IsChannelExisting</b> checks whether a channel with the specified name is registered in the (thread)-global list of all channels (result == 1) or not (result == 0).<div class="spacer">
</div>
<b>Tcl_CutChannel</b> removes the specified <i>channel</i> from the (thread)global list of all channels (of the current thread). Application to a channel still registered in some interpreter is not allowed. Also notifies the driver if the  <b>Tcl_ChannelType</b> version is  <b>TCL_CHANNEL_VERSION_4</b> (or higher), and  <b>Tcl_DriverThreadActionProc</b> is defined for it.<div class="spacer">
</div>
<b>Tcl_SpliceChannel</b> adds the specified <i>channel</i> to the (thread)global list of all channels (of the current thread). Application to a channel registered in some interpreter is not allowed. Also notifies the driver if the  <b>Tcl_ChannelType</b> version is  <b>TCL_CHANNEL_VERSION_4</b> (or higher), and  <b>Tcl_DriverThreadActionProc</b> is defined for it.<div class="spacer">
</div>
<b>Tcl_ClearChannelHandlers</b> removes all channel handlers and event scripts associated with the specified  <i>channel</i>, thus shutting down all event processing for this channel.</div>
<div class="section">
<h1>TCL_CHANNELTYPE</h1> A channel driver provides a  <b>Tcl_ChannelType</b> structure that contains pointers to functions that implement the various operations on a channel; these operations are invoked as needed by the generic layer.  The structure was versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked channel drivers.  See the  <b>OLD CHANNEL TYPES</b> section below for details about the old structure.<div class="spacer">
</div>
The <b>Tcl_ChannelType</b> structure contains the following fields:<div style="margin-left: 5.00ex;">
<br/>
typedef struct Tcl_ChannelType {<br/>
        char *<i>typeName</i>;<br/>
        Tcl_ChannelTypeVersion <i>version</i>;<br/>
        Tcl_DriverCloseProc *<i>closeProc</i>;<br/>
        Tcl_DriverInputProc *<i>inputProc</i>;<br/>
        Tcl_DriverOutputProc *<i>outputProc</i>;<br/>
        Tcl_DriverSeekProc *<i>seekProc</i>;<br/>
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;<br/>
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;<br/>
        Tcl_DriverWatchProc *<i>watchProc</i>;<br/>
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;<br/>
        Tcl_DriverClose2Proc *<i>close2Proc</i>;<br/>
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;<br/>
        Tcl_DriverFlushProc *<i>flushProc</i>;<br/>
        Tcl_DriverHandlerProc *<i>handlerProc</i>;<br/>
        Tcl_DriverWideSeekProc *<i>wideSeekProc</i>;<br/>
        Tcl_DriverThreadActionProc *<i>threadActionProc</i>;<br/>
        Tcl_DriverTruncateProc *<i>truncateProc</i>;<br/>
} Tcl_ChannelType;<br/>
</div>
<div class="spacer">
</div>
It is not necessary to provide implementations for all channel operations.  Those which are not necessary may be set to NULL in the struct:  <i>blockModeProc</i>, <i>seekProc</i>, <i>setOptionProc</i>,  <i>getOptionProc</i>, and <i>close2Proc</i>, in addition to  <i>flushProc</i>, <i>handlerProc</i>, <i>threadActionProc</i>, and  <i>truncateProc</i>.  Other functions that cannot be implemented in a meaningful way should return  <b>EINVAL</b> when called, to indicate that the operations they represent are not available. Also note that  <i>wideSeekProc</i> can be NULL if <i>seekProc</i> is.<div class="spacer">
</div>
The user should only use the above structure for <b>Tcl_ChannelType</b> instantiation.  When referencing fields in a  <b>Tcl_ChannelType</b> structure, the following functions should be used to obtain the values:  <b>Tcl_ChannelName</b>, <b>Tcl_ChannelVersion</b>,  <b>Tcl_ChannelBlockModeProc</b>, <b>Tcl_ChannelCloseProc</b>,  <b>Tcl_ChannelClose2Proc</b>, <b>Tcl_ChannelInputProc</b>,  <b>Tcl_ChannelOutputProc</b>, <b>Tcl_ChannelSeekProc</b>,  <b>Tcl_ChannelWideSeekProc</b>, <b>Tcl_ChannelThreadActionProc</b>,  <b>Tcl_ChannelTruncateProc</b>,  <b>Tcl_ChannelSetOptionProc</b>, <b>Tcl_ChannelGetOptionProc</b>,  <b>Tcl_ChannelWatchProc</b>, <b>Tcl_ChannelGetHandleProc</b>,  <b>Tcl_ChannelFlushProc</b>, or <b>Tcl_ChannelHandlerProc</b>.<div class="spacer">
</div>
The change to the structures was made in such a way that standard channel types are binary compatible.  However, channel types that use stacked channels (i.e. TLS, Trf) have new versions to correspond to the above change since the previous code for stacked channels had problems.<div class="subsection">
<h2>TYPENAME</h2> The  <i>typeName</i> field contains a null-terminated string that identifies the type of the device implemented by this driver, e.g.  <b>file</b> or <b>socket</b>.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelName</b>, which returns a pointer to the string.</div>
<div class="subsection">
<h2>VERSION</h2><div style="height: 1.00em;">
&#160;</div>
The <i>version</i> field should be set to the version of the structure that you require.  <b>TCL_CHANNEL_VERSION_2</b> is the minimum recommended.  <b>TCL_CHANNEL_VERSION_3</b> must be set to specify the <i>wideSeekProc</i> member.  <b>TCL_CHANNEL_VERSION_4</b> must be set to specify the <i>threadActionProc</i> member (includes  <i>wideSeekProc</i>).  <b>TCL_CHANNEL_VERSION_5</b> must be set to specify the  <i>truncateProc</i> members (includes  <i>wideSeekProc</i> and <i>threadActionProc</i>). If it is not set to any of these, then this  <b>Tcl_ChannelType</b> is assumed to have the original structure.  See  <b>OLD CHANNEL TYPES</b> for more details.  While Tcl will recognize and function with either structures, stacked channels must be of at least  <b>TCL_CHANNEL_VERSION_2</b> to function correctly.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelVersion</b>, which returns one of  <b>TCL_CHANNEL_VERSION_5</b>,  <b>TCL_CHANNEL_VERSION_4</b>,  <b>TCL_CHANNEL_VERSION_3</b>,  <b>TCL_CHANNEL_VERSION_2</b> or <b>TCL_CHANNEL_VERSION_1</b>.</div>
<div class="subsection">
<h2>BLOCKMODEPROC</h2> The  <i>blockModeProc</i> field contains the address of a function called by the generic layer to set blocking and nonblocking mode on the device.  <i>BlockModeProc</i> should match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverBlockModeProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        int <i>mode</i>);<br/>
</div>
<div class="spacer">
</div>
The <i>instanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when this channel was created.  The <i>mode</i> argument is either  <b>TCL_MODE_BLOCKING</b> or <b>TCL_MODE_NONBLOCKING</b> to set the device into blocking or nonblocking mode. The function should return zero if the operation was successful, or a nonzero POSIX error code if the operation failed.<div class="spacer">
</div>
If the operation is successful, the function can modify the supplied  <i>instanceData</i> to record that the channel entered blocking or nonblocking mode and to implement the blocking or nonblocking behavior. For some device types, the blocking and nonblocking behavior can be implemented by the underlying operating system; for other device types, the behavior must be emulated in the channel driver.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelBlockModeProc</b>, which returns a pointer to the function.<div class="spacer">
</div>
A channel driver <b>not</b> supplying a <i>blockModeProc</i> has to be very, very careful. It has to tell the generic layer exactly which blocking mode is acceptable to it, and should this also document for the user so that the blocking mode of the channel is not changed to an unacceptable value. Any confusion here may lead the interpreter into a (spurious and difficult to find) deadlock.</div>
<div class="subsection">
<h2>CLOSEPROC AND CLOSE2PROC</h2> The  <i>closeProc</i> field contains the address of a function called by the generic layer to clean up driver-related information when the channel is closed.  <i>CloseProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverCloseProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_Interp *<i>interp</i>);<br/>
</div>
<div class="spacer">
</div>
The <i>instanceData</i> argument is the same as the value provided to  <b>Tcl_CreateChannel</b> when the channel was created. The function should release any storage maintained by the channel driver for this channel, and close the input and output devices encapsulated by this channel. All queued output will have been flushed to the device before this function is called, and no further driver operations will be invoked on this instance after calling the  <i>closeProc</i>. If the close operation is successful, the procedure should return zero; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and  <i>interp</i> is not NULL, the procedure should store an error message in the interpreter's result.<div class="spacer">
</div>
Alternatively, channels that support closing the read and write sides independently may set  <i>closeProc</i> to <b>TCL_CLOSE2PROC</b> and set  <i>close2Proc</i> to the address of a function that matches the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverClose2Proc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        int <i>flags</i>);<br/>
</div>
<div class="spacer">
</div>
The <i>close2Proc</i> will be called with <i>flags</i> set to an OR'ed combination of  <b>TCL_CLOSE_READ</b> or <b>TCL_CLOSE_WRITE</b> to indicate that the driver should close the read and/or write side of the channel.  The channel driver may be invoked to perform additional operations on the channel after  <i>close2Proc</i> is called to close one or both sides of the channel.  If  <i>flags</i> is  <b>0</b> (zero), the driver should close the channel in the manner described above for  <i>closeProc</i>.  No further operations will be invoked on this instance after  <i>close2Proc</i> is called with all flags cleared.  In all cases, the  <i>close2Proc</i> function should return zero if the close operation was successful; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and  <i>interp</i> is not NULL, the procedure should store an error message in the interpreter's result.<div class="spacer">
</div>
The <i>closeProc</i> and <i>close2Proc</i> values can be retrieved with  <b>Tcl_ChannelCloseProc</b> or <b>Tcl_ChannelClose2Proc</b>, which return a pointer to the respective function.</div>
<div class="subsection">
<h2>INPUTPROC</h2> The  <i>inputProc</i> field contains the address of a function called by the generic layer to read data from the file or device and store it in an internal buffer.  <i>InputProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverInputProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        char *<i>buf</i>,<br/>
        int <i>bufSize</i>,<br/>
        int *<i>errorCodePtr</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when the channel was created.  The <i>buf</i> argument points to an array of bytes in which to store input from the device, and the  <i>bufSize</i> argument indicates how many bytes are available at  <i>buf</i>.<div class="spacer">
</div>
The <i>errorCodePtr</i> argument points to an integer variable provided by the generic layer. If an error occurs, the function should set the variable to a POSIX error code that identifies the error that occurred.<div class="spacer">
</div>
The function should read data from the input device encapsulated by the channel and store it at  <i>buf</i>.  On success, the function should return a nonnegative integer indicating how many bytes were read from the input device and stored at  <i>buf</i>. On error, the function should return -1. If an error occurs after some data has been read from the device, that data is lost.<div class="spacer">
</div>
If <i>inputProc</i> can determine that the input device has some data available but less than requested by the  <i>bufSize</i> argument, the function should only attempt to read as much data as is available and return without blocking. If the input device has no data available whatsoever and the channel is in nonblocking mode, the function should return an  <b>EAGAIN</b> error. If the input device has no data available whatsoever and the channel is in blocking mode, the function should block for the shortest possible time until at least one byte of data can be read from the device; then, it should return as much data as it can read without blocking.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelInputProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>OUTPUTPROC</h2> The  <i>outputProc</i> field contains the address of a function called by the generic layer to transfer data from an internal buffer to the output device.  <i>OutputProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverOutputProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        const char *<i>buf</i>,<br/>
        int <i>toWrite</i>,<br/>
        int *<i>errorCodePtr</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when the channel was created. The <i>buf</i> argument contains an array of bytes to be written to the device, and the  <i>toWrite</i> argument indicates how many bytes are to be written from the  <i>buf</i> argument.<div class="spacer">
</div>
The <i>errorCodePtr</i> argument points to an integer variable provided by the generic layer. If an error occurs, the function should set this variable to a POSIX error code that identifies the error.<div class="spacer">
</div>
The function should write the data at <i>buf</i> to the output device encapsulated by the channel. On success, the function should return a nonnegative integer indicating how many bytes were written to the output device.  The return value is normally the same as  <i>toWrite</i>, but may be less in some cases such as if the output operation is interrupted by a signal. If an error occurs the function should return -1.  In case of error, some data may have been written to the device.<div class="spacer">
</div>
If the channel is nonblocking and the output device is unable to absorb any data whatsoever, the function should return -1 with an  <b>EAGAIN</b> error without writing any data.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelOutputProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>SEEKPROC AND WIDESEEKPROC</h2> The  <i>seekProc</i> field contains the address of a function called by the generic layer to move the access point at which subsequent input or output operations will be applied.  <i>SeekProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverSeekProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        long <i>offset</i>,<br/>
        int <i>seekMode</i>,<br/>
        int *<i>errorCodePtr</i>);<br/>
</div>
<div class="spacer">
</div>
The <i>instanceData</i> argument is the same as the value given to  <b>Tcl_CreateChannel</b> when this channel was created.  <i>Offset</i> and  <i>seekMode</i> have the same meaning as for the <b>Tcl_Seek</b> procedure (described in the manual entry for  <b>Tcl_OpenFileChannel</b>).<div class="spacer">
</div>
The <i>errorCodePtr</i> argument points to an integer variable provided by the generic layer for returning  <b>errno</b> values from the function.  The function should set this variable to a POSIX error code if an error occurs. The function should store an  <b>EINVAL</b> error code if the channel type does not implement seeking.<div class="spacer">
</div>
The return value is the new access point or -1 in case of error. If an error occurred, the function should not move the access point.<div class="spacer">
</div>
If there is a non-NULL <i>seekProc</i> field, the <i>wideSeekProc</i> field may contain the address of an alternative function to use which handles wide (i.e. larger than 32-bit) offsets, so allowing seeks within files larger than 2GB.  The  <i>wideSeekProc</i> will be called in preference to the  <i>seekProc</i>, but both must be defined if the  <i>wideSeekProc</i> is defined.  <i>WideSeekProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef Tcl_WideInt Tcl_DriverWideSeekProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_WideInt <i>offset</i>,<br/>
        int <i>seekMode</i>,<br/>
        int *<i>errorCodePtr</i>);<br/>
</div>
<div class="spacer">
</div>
The arguments and return values mean the same thing as with  <i>seekProc</i> above, except that the type of offsets and the return type are different.<div class="spacer">
</div>
The <i>seekProc</i> value can be retrieved with  <b>Tcl_ChannelSeekProc</b>, which returns a pointer to the function, and similarly the  <i>wideSeekProc</i> can be retrieved with  <b>Tcl_ChannelWideSeekProc</b>.</div>
<div class="subsection">
<h2>SETOPTIONPROC</h2> The  <i>setOptionProc</i> field contains the address of a function called by the generic layer to set a channel type specific option on a channel.  <i>setOptionProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverSetOptionProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        const char *<i>optionName</i>,<br/>
        const char *<i>newValue</i>);<br/>
</div>
<div class="spacer">
</div>
<i>optionName</i> is the name of an option to set, and <i>newValue</i> is the new value for that option, as a string. The  <i>instanceData</i> is the same as the value given to  <b>Tcl_CreateChannel</b> when this channel was created. The function should do whatever channel type specific action is required to implement the new value of the option.<div class="spacer">
</div>
Some options are handled by the generic code and this function is never called to set them, e.g.  <b>-blockmode</b>. Other options are specific to each channel type and the  <i>setOptionProc</i> procedure of the channel driver will get called to implement them. The  <i>setOptionProc</i> field can be NULL, which indicates that this channel type supports no type specific options.<div class="spacer">
</div>
If the option value is successfully modified to the new value, the function returns  <b>TCL_OK</b>. It should call  <b>Tcl_BadChannelOption</b> which itself returns  <b>TCL_ERROR</b> if the <i>optionName</i> is unrecognized. If  <i>newValue</i> specifies a value for the option that is not supported or if a system call error occurs, the function should leave an error message in the  <i>result</i> field of <i>interp</i> if <i>interp</i> is not NULL. The function should also call  <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelSetOptionProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>GETOPTIONPROC</h2> The  <i>getOptionProc</i> field contains the address of a function called by the generic layer to get the value of a channel type specific option on a channel.  <i>getOptionProc</i> must match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverGetOptionProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_Interp *<i>interp</i>,<br/>
        const char *<i>optionName</i>,<br/>
        Tcl_DString *<i>optionValue</i>);<br/>
</div>
<div class="spacer">
</div>
<i>OptionName</i> is the name of an option supported by this type of channel. If the option name is not NULL, the function stores its current value, as a string, in the Tcl dynamic string  <i>optionValue</i>. If  <i>optionName</i> is NULL, the function stores in <i>optionValue</i> an alternating list of all supported options and their current values. On success, the function returns  <b>TCL_OK</b>. It should call  <b>Tcl_BadChannelOption</b> which itself returns  <b>TCL_ERROR</b> if the <i>optionName</i> is unrecognized. If a system call error occurs, the function should leave an error message in the result of  <i>interp</i> if <i>interp</i> is not NULL. The function should also call  <b>Tcl_SetErrno</b> to store an appropriate POSIX error code.<div class="spacer">
</div>
Some options are handled by the generic code and this function is never called to retrieve their value, e.g.  <b>-blockmode</b>. Other options are specific to each channel type and the  <i>getOptionProc</i> procedure of the channel driver will get called to implement them. The  <i>getOptionProc</i> field can be NULL, which indicates that this channel type supports no type specific options.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelGetOptionProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>WATCHPROC</h2> The  <i>watchProc</i> field contains the address of a function called by the generic layer to initialize the event notification mechanism to notice events of interest on this channel.  <i>WatchProc</i> should match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef void Tcl_DriverWatchProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        int <i>mask</i>);<br/>
</div>
<div class="spacer">
</div>
The <i>instanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when this channel was created. The <i>mask</i> argument is an OR-ed combination of  <b>TCL_READABLE</b>, <b>TCL_WRITABLE</b> and  <b>TCL_EXCEPTION</b>; it indicates events the caller is interested in noticing on this channel.<div class="spacer">
</div>
The function should initialize device type specific mechanisms to notice when an event of interest is present on the channel.  When one or more of the designated events occurs on the channel, the channel driver is responsible for calling  <b>Tcl_NotifyChannel</b> to inform the generic channel module.  The driver should take care not to starve other channel drivers or sources of callbacks by invoking Tcl_NotifyChannel too frequently.  Fairness can be insured by using the Tcl event queue to allow the channel event to be scheduled in sequence with other events.  See the description of  <b>Tcl_QueueEvent</b> for details on how to queue an event.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelWatchProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>GETHANDLEPROC</h2> The  <i>getHandleProc</i> field contains the address of a function called by the generic layer to retrieve a device-specific handle from the channel.  <i>GetHandleProc</i> should match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverGetHandleProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        int <i>direction</i>,<br/>
        ClientData *<i>handlePtr</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when this channel was created. The <i>direction</i> argument is either  <b>TCL_READABLE</b> to retrieve the handle used for input, or  <b>TCL_WRITABLE</b> to retrieve the handle used for output.<div class="spacer">
</div>
If the channel implementation has device-specific handles, the function should retrieve the appropriate handle associated with the channel, according the  <i>direction</i> argument.  The handle should be stored in the location referred to by  <i>handlePtr</i>, and  <b>TCL_OK</b> should be returned.  If the channel is not open for the specified direction, or if the channel implementation does not use device handles, the function should return  <b>TCL_ERROR</b>.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelGetHandleProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>FLUSHPROC</h2> The  <i>flushProc</i> field is currently reserved for future use. It should be set to NULL.  <i>FlushProc</i> should match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverFlushProc(<br/>
        ClientData <i>instanceData</i>);<br/>
</div>
<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelFlushProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>HANDLERPROC</h2> The  <i>handlerProc</i> field contains the address of a function called by the generic layer to notify the channel that an event occurred.  It should be defined for stacked channel drivers that wish to be notified of events that occur on the underlying (stacked) channel.  <i>HandlerProc</i> should match the following prototype:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverHandlerProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        int <i>interestMask</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to <b>Tcl_CreateChannel</b> when this channel was created.  The  <i>interestMask</i> is an OR-ed combination of  <b>TCL_READABLE</b> or <b>TCL_WRITABLE</b>; it indicates what type of event occurred on this channel.<div class="spacer">
</div>
This value can be retrieved with <b>Tcl_ChannelHandlerProc</b>, which returns a pointer to the function.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>THREADACTIONPROC</h2> The  <i>threadActionProc</i> field contains the address of the function called by the generic layer when a channel is created, closed, or going to move to a different thread, i.e. whenever thread-specific driver state might have to initialized or updated. It can be NULL. The action  <i>TCL_CHANNEL_THREAD_REMOVE</i> is used to notify the driver that it should update or remove any thread-specific data it might be maintaining for the channel.<div class="spacer">
</div>
The action <i>TCL_CHANNEL_THREAD_INSERT</i> is used to notify the driver that it should update or initialize any thread-specific data it might be maintaining using the calling thread as the associate. See  <b>Tcl_CutChannel</b> and <b>Tcl_SpliceChannel</b> for more detail.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef void Tcl_DriverThreadActionProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        int        <i>action</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when this channel was created.<div class="spacer">
</div>
These values can be retrieved with <b>Tcl_ChannelThreadActionProc</b>, which returns a pointer to the function.</div>
<div class="subsection">
<h2>TRUNCATEPROC</h2> The  <i>truncateProc</i> field contains the address of the function called by the generic layer when a channel is truncated to some length. It can be NULL.<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef int Tcl_DriverTruncateProc(<br/>
        ClientData <i>instanceData</i>,<br/>
        Tcl_WideInt <i>length</i>);<br/>
</div>
<div class="spacer">
</div>
<i>InstanceData</i> is the same as the value passed to  <b>Tcl_CreateChannel</b> when this channel was created, and  <i>length</i> is the new length of the underlying file, which should not be negative. The result should be 0 on success or an errno code (suitable for use with  <b>Tcl_SetErrno</b>) on failure.<div class="spacer">
</div>
These values can be retrieved with <b>Tcl_ChannelTruncateProc</b>, which returns a pointer to the function.</div>
</div>
<div class="section">
<h1>TCL_BADCHANNELOPTION</h1> This procedure generates a &#8220;bad option&#8221; error message in an (optional) interpreter.  It is used by channel drivers when an invalid Set/Get option is requested. Its purpose is to concatenate the generic options list to the specific ones and factorize the generic options error message string.<div class="spacer">
</div>
It always returns <b>TCL_ERROR</b><div class="spacer">
</div>
An error message is generated in <i>interp</i>'s result object to indicate that a command was invoked with a bad option. The message has the form<div style="margin-left: 5.00ex;">
<br/>
    bad option &quot;blah&quot;: should be one of <br/>
    &lt;...generic options...&gt;+&lt;...specific options...&gt;<br/>
</div>
so you get for instance:<div style="margin-left: 5.00ex;">
<br/>
    bad option &quot;-blah&quot;: should be one of -blocking,<br/>
    -buffering, -buffersize, -eofchar, -translation,<br/>
    -peername, or -sockname<br/>
</div>
when called with <i>optionList</i> equal to &#8220;peername sockname&#8221;<div class="spacer">
</div>
&#8220;blah&#8221; is the  <i>optionName</i> argument and &#8220;&lt;specific options&gt;&#8221; is a space separated list of specific option words. The function takes good care of inserting minus signs before each option, commas after, and an &#8220;or&#8221; before the last option.</div>
<div class="section">
<h1>OLD CHANNEL TYPES</h1> The original (8.3.1 and below)  <b>Tcl_ChannelType</b> structure contains the following fields:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef struct Tcl_ChannelType {<br/>
        char *<i>typeName</i>;<br/>
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;<br/>
        Tcl_DriverCloseProc *<i>closeProc</i>;<br/>
        Tcl_DriverInputProc *<i>inputProc</i>;<br/>
        Tcl_DriverOutputProc *<i>outputProc</i>;<br/>
        Tcl_DriverSeekProc *<i>seekProc</i>;<br/>
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;<br/>
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;<br/>
        Tcl_DriverWatchProc *<i>watchProc</i>;<br/>
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;<br/>
        Tcl_DriverClose2Proc *<i>close2Proc</i>;<br/>
} Tcl_ChannelType;<br/>
</div>
<div class="spacer">
</div>
It is still possible to create channel with the above structure.  The internal channel code will determine the version.  It is imperative to use the new  <b>Tcl_ChannelType</b> structure if you are creating a stacked channel driver, due to problems with the earlier stacked channel implementation (in 8.2.0 to 8.3.1).<div class="spacer">
</div>
Prior to 8.4.0 (i.e. during the later releases of 8.3 and early part of the 8.4 development cycle) the  <b>Tcl_ChannelType</b> structure contained the following fields:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef struct Tcl_ChannelType {<br/>
        char *<i>typeName</i>;<br/>
        Tcl_ChannelTypeVersion <i>version</i>;<br/>
        Tcl_DriverCloseProc *<i>closeProc</i>;<br/>
        Tcl_DriverInputProc *<i>inputProc</i>;<br/>
        Tcl_DriverOutputProc *<i>outputProc</i>;<br/>
        Tcl_DriverSeekProc *<i>seekProc</i>;<br/>
        Tcl_DriverSetOptionProc *<i>setOptionProc</i>;<br/>
        Tcl_DriverGetOptionProc *<i>getOptionProc</i>;<br/>
        Tcl_DriverWatchProc *<i>watchProc</i>;<br/>
        Tcl_DriverGetHandleProc *<i>getHandleProc</i>;<br/>
        Tcl_DriverClose2Proc *<i>close2Proc</i>;<br/>
        Tcl_DriverBlockModeProc *<i>blockModeProc</i>;<br/>
        Tcl_DriverFlushProc *<i>flushProc</i>;<br/>
        Tcl_DriverHandlerProc *<i>handlerProc</i>;<br/>
        Tcl_DriverTruncateProc *<i>truncateProc</i>;<br/>
} Tcl_ChannelType;<br/>
</div>
<div class="spacer">
</div>
When the above structure is registered as a channel type, the  <i>version</i> field should always be <b>TCL_CHANNEL_VERSION_2</b>.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3), Tcl_StackChannel(3), Tcl_GetStdChannel(3)<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>KEYWORDS</h1> blocking, channel driver, channel registration, channel type, nonblocking</div>
<table class="foot">
<tr>
<td class="foot-date">
8.4</td>
<td class="foot-os">
Tcl</td>
</tr>
</table>
</div>
</body>
</html>

