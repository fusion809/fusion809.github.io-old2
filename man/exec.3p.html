<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<title>
EXEC(3P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
EXEC(3P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
EXEC(3P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>NAME</h1> environ, execl, execle, execlp, execv, execve, execvp, fexecve &#8212; execute a file</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
#include &lt;unistd.h&gt;<div class="spacer">
</div>
extern char **environ;<br/>
int execl(const char *<i>path</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);<br/>
int execle(const char *<i>path</i>, const char *<i>arg0</i>, ... /*,<br/>
    (char *)0, char *const <i>envp</i>[]*/);<br/>
int execlp(const char *<i>file</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);<br/>
int execv(const char *<i>path</i>, char *const <i>argv</i>[]);<br/>
int execve(const char *<i>path</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);<br/>
int execvp(const char *<i>file</i>, char *const <i>argv</i>[]);<br/>
int fexecve(int <i>fd</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The <i>exec</i> family of functions shall replace the current process image with a new process image. The new image shall be constructed from a regular, executable file called the <i>new process image file</i>. There shall be no return from a successful <i>exec</i>, because the calling process image is overlaid by the new process image.<div class="spacer">
</div>
The  <i>fexecve</i>() function shall be equivalent to the  <i>execve</i>() function except that the file to be executed is determined by the file descriptor <i>fd</i> instead of a pathname. The file offset of <i>fd</i> is ignored.<div class="spacer">
</div>
When a C-language program is executed as a result of a call to one of the <i>exec</i> family of functions, it shall be entered as a C-language function call as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>int main (</b><i>int argc, char *argv</i><b>[]);</b><br/>
</div>
<div class="spacer">
</div>
where <i>argc</i> is the argument count and <i>argv</i> is an array of character pointers to the arguments themselves. In addition, the following variable, which must be declared by the user if it is to be used directly:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>extern char **environ;</b><br/>
</div>
<div class="spacer">
</div>
is initialized as a pointer to an array of character pointers to the environment strings. The <i>argv</i> and <i>environ</i> arrays are each terminated by a null pointer. The null pointer terminating the <i>argv</i> array is not counted in <i>argc</i>.<div class="spacer">
</div>
Applications can change the entire environment in a single operation by assigning the <i>environ</i> variable to point to an array of character pointers to the new environment strings. After assigning a new value to <i>environ</i>, applications should not rely on the new environment strings remaining part of the environment, as a call to  <i>getenv</i>(),  <i>putenv</i>(),  <i>setenv</i>(),  <i>unsetenv</i>(), or any function that is dependent on an environment variable may, on noticing that <i>environ</i> has changed, copy the environment strings to a new array and assign <i>environ</i> to point to it.<div class="spacer">
</div>
Any application that directly modifies the pointers to which the <i>environ</i> variable points has undefined behavior.<div class="spacer">
</div>
Conforming multi-threaded applications shall not use the <i>environ</i> variable to access or modify any environment variable while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment variable shall be considered a use of the <i>environ</i> variable to access that environment variable.<div class="spacer">
</div>
The arguments specified by a program with one of the <i>exec</i> functions shall be passed on to the new process image in the corresponding  <i>main</i>() arguments.<div class="spacer">
</div>
The argument <i>path</i> points to a pathname that identifies the new process image file.<div class="spacer">
</div>
The argument <i>file</i> is used to construct a pathname that identifies the new process image file. If the <i>file</i> argument contains a &lt;slash&gt; character, the <i>file</i> argument shall be used as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the environment variable <i>PATH</i> (see the Base Definitions volume of POSIX.1&#8208;2008, <i>Chapter 8</i>, <i>Environment Variables</i>). If this environment variable is not present, the results of the search are implementation-defined.<div class="spacer">
</div>
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by the setting of <i>errno</i> to either <b>[ENOEXEC]</b> or <b>[EINVAL]</b> (see the ERRORS section). In the cases where the other members of the <i>exec</i> family of functions would fail and set <i>errno</i> to <b>[ENOEXEC]</b>, the  <i>execlp</i>() and  <i>execvp</i>() functions shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the <i>sh</i> utility using  <i>execl</i>() as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);</b><br/>
</div>
<div class="spacer">
</div>
where &lt;<i>shell&#160;path</i>&gt; is an unspecified pathname for the <i>sh</i> utility, <i>file</i> is the process image file, and for  <i>execvp</i>(), where <i>arg</i>0, <i>arg</i>1, and so on correspond to the values passed to  <i>execvp</i>() in <i>argv</i>[0], <i>argv</i>[1], and so on.<div class="spacer">
</div>
The arguments represented by <i>arg0</i>,... are pointers to null-terminated character strings. These strings shall constitute the argument list available to the new process image. The list is terminated by a null pointer. The argument <i>arg0</i> should point to a filename string that is associated with the process being started by one of the <i>exec</i> functions.<div class="spacer">
</div>
The argument <i>argv</i> is an array of character pointers to null-terminated strings. The application shall ensure that the last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image. The value in <i>argv</i>[0] should point to a filename string that is associated with the process being started by one of the <i>exec</i> functions.<div class="spacer">
</div>
The argument <i>envp</i> is an array of character pointers to null-terminated strings. These strings shall constitute the environment for the new process image. The <i>envp</i> array is terminated by a null pointer.<div class="spacer">
</div>
For those forms not containing an <i>envp</i> pointer (<i>execl</i>(),  <i>execv</i>(),  <i>execlp</i>(), and  <i>execvp</i>()), the environment for the new process image shall be taken from the external variable <i>environ</i> in the calling process.<div class="spacer">
</div>
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.<div class="spacer">
</div>
File descriptors open in the calling process image shall remain open in the new process image, except for those whose close-on-<i>exec</i> flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file description remain unchanged. For any file descriptor that is closed for this reason, file locks are removed as a result of the close as described in  <i>close</i>(). Locks that are not removed by closing of file descriptors remain unchanged.<div class="spacer">
</div>
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the <i>exec</i> family of functions, implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described in this standard.<div class="spacer">
</div>
Directory streams open in the calling process image shall be closed in the new process image.<div class="spacer">
</div>
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.<div class="spacer">
</div>
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.<div class="spacer">
</div>
For the new process image, the equivalent of:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>setlocale(LC_ALL, &quot;C&quot;)</b><br/>
</div>
<div class="spacer">
</div>
shall be executed at start-up.<div class="spacer">
</div>
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image (see <i>&lt;signal.h&gt;</i>).<div class="spacer">
</div>
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to be ignored or to the default action in the new process image.<div class="spacer">
</div>
After a successful call to any of the <i>exec</i> functions, alternate signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for all signals.<div class="spacer">
</div>
After a successful call to any of the <i>exec</i> functions, any functions previously registered by the  <i>atexit</i>() or  <i>pthread_atfork</i>() functions are no longer registered.<div class="spacer">
</div>
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise, if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by  <i>setuid</i>().<div class="spacer">
</div>
Any shared memory segments attached to the calling process image shall not be attached to the new process image.<div class="spacer">
</div>
Any named semaphores open in the calling process shall be closed as if by appropriate calls to  <i>sem_close</i>().<div class="spacer">
</div>
Any blocks of typed memory that were mapped in the calling process are unmapped, as if  <i>munmap</i>() was implicitly called to unmap them.<div class="spacer">
</div>
Memory locks established by the calling process via calls to  <i>mlockall</i>() or  <i>mlock</i>() shall be removed. If locked pages in the address space of the calling process are also mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes shall be unaffected by the call by this process to the <i>exec</i> function. If the <i>exec</i> function fails, the effect on memory locks is unspecified.<div class="spacer">
</div>
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.<div class="spacer">
</div>
When the calling process image does not use the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the scheduling policy and parameters of the new process image and the initial thread in that new process image are implementation-defined.<div class="spacer">
</div>
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and scheduling parameter settings shall not be changed by a call to an <i>exec</i> function. The initial thread in the new process image shall inherit the process scheduling policy and parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process image.<div class="spacer">
</div>
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new process image.<div class="spacer">
</div>
All open message queue descriptors in the calling process shall be closed, as described in  <i>mq_close</i>().<div class="spacer">
</div>
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall complete as if the <i>exec</i> function had not yet occurred, but any associated signal notifications shall be suppressed. It is unspecified whether the <i>exec</i> function itself blocks awaiting such I/O completion. In no event, however, shall the new process image created by the <i>exec</i> function be affected by the presence of outstanding asynchronous I/O operations at the time the <i>exec</i> function is called. Whether any I/O is canceled, and which I/O may be canceled upon <i>exec</i>, is implementation-defined.<div class="spacer">
</div>
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process CPU-time clock of the process being <i>exec</i>-ed shall not be reinitialized or altered as a result of the <i>exec</i> function other than to reflect the time spent by the process executing the <i>exec</i> function itself.<div class="spacer">
</div>
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.<div class="spacer">
</div>
If the calling process is being traced, the new process image shall continue to be traced into the same trace stream as the original process image, but the new process image shall not inherit the mapping of trace event names to trace event type identifiers that was defined by calls to the  <i>posix_trace_eventid_open</i>() or the  <i>posix_trace_trid_eventid_open</i>() functions in the calling process image.<div class="spacer">
</div>
If the calling process is a trace controller process, any trace streams that were created by the calling process shall be shut down as described in the  <i>posix_trace_shutdown</i>() function.<div class="spacer">
</div>
The thread ID of the initial thread in the new process image is unspecified.<div class="spacer">
</div>
The size and location of the stack on which the initial thread in the new process image runs is unspecified.<div class="spacer">
</div>
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation state set to PTHREAD_CANCEL_ENABLED.<div class="spacer">
</div>
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data keys shall be removed by the call to <i>exec</i> without running destructors.<div class="spacer">
</div>
The initial thread in the new process image shall be joinable, as if created with the <i>detachstate</i> attribute set to PTHREAD_CREATE_JOINABLE.<div class="spacer">
</div>
The new process shall inherit at least the following attributes from the calling process image:<dl>
<dt>
 *</dt>
<dd>
Nice value (see  <i>nice</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
<i>semadj</i> values (see  <i>semop</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Parent process ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process group ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Session membership</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Real user ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Real group ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Supplementary group IDs</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Time left until an alarm clock signal (see  <i>alarm</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Current working directory</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Root directory</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
File mode creation mask (see  <i>umask</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
File size limit (see  <i>getrlimit</i>() and  <i>setrlimit</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process signal mask (see  <i>pthread_sigmask</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Pending signal (see  <i>sigpending</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
<i>tms_utime</i>, <i>tms_stime</i>, <i>tms_cutime</i>, and <i>tms_cstime</i> (see  <i>times</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Resource limits</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Controlling terminal</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Interval timers</dd>
</dl>
<div class="spacer">
</div>
The initial thread of the new process shall inherit at least the following attributes from the calling thread:<dl>
<dt>
 *</dt>
<dd>
Signal mask (see  <i>sigprocmask</i>() and  <i>pthread_sigmask</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Pending signals (see  <i>sigpending</i>())</dd>
</dl>
<div class="spacer">
</div>
All other process attributes defined in this volume of POSIX.1&#8208;2008 shall be inherited in the new process image from the old process image. All other thread attributes defined in this volume of POSIX.1&#8208;2008 shall be inherited in the initial thread in the new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by this volume of POSIX.1&#8208;2008 is implementation-defined.<div class="spacer">
</div>
A call to any <i>exec</i> function from a process with more than one thread shall result in all threads being terminated and the new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.<div class="spacer">
</div>
Upon successful completion, the <i>exec</i> functions shall mark for update the last data access timestamp of the file. If an <i>exec</i> function failed but was able to locate the process image file, whether the last data access timestamp is marked for update is unspecified. Should the <i>exec</i> function succeed, the process image file shall be considered to have been opened with  <i>open</i>(). The corresponding  <i>close</i>() shall be considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one of the <i>exec</i> functions,  <i>posix_spawn</i>(), or  <i>posix_spawnp</i>(). The <i>argv</i>[] and <i>envp</i>[] arrays of pointers and the strings to which those arrays point shall not be modified by a call to one of the <i>exec</i> functions, except as a consequence of replacing the process image.<div class="spacer">
</div>
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.</div>
<div class="section">
<h1>RETURN VALUE</h1> If one of the <i>exec</i> functions returns to the calling process image, an error has occurred; the return value shall be &#8722;1, and <i>errno</i> shall be set to indicate the error.</div>
<div class="section">
<h1>ERRORS</h1> The <i>exec</i> functions shall fail if:<dl>
<dt>
<b>E2BIG</b></dt>
<dd>
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit of {ARG_MAX} bytes.</dd>
</dl>
<dl>
<dt>
<b>EACCES</b></dt>
<dd>
The new process image file is not a regular file and the implementation does not support execution of files of its type.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not support execution of a file with this format.</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions, except for  <i>fexecve</i>(), shall fail if:<dl>
<dt>
<b>EACCES</b></dt>
<dd>
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file denies execution permission.</dd>
</dl>
<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
A loop exists in symbolic links encountered during resolution of the <i>path</i> or <i>file</i> argument.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
The length of a component of a pathname is longer than {NAME_MAX}.</dd>
</dl>
<dl>
<dt>
<b>ENOENT</b></dt>
<dd>
A component of <i>path</i> or <i>file</i> does not name an existing file or <i>path</i> or <i>file</i> is an empty string.</dd>
</dl>
<dl>
<dt>
<b>ENOTDIR</b></dt>
<dd>
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the new process image file's pathname contains at least one non-&lt;slash&gt; character and ends with one or more trailing &lt;slash&gt; characters and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions, except for  <i>execlp</i>() and  <i>execvp</i>(), shall fail if:<dl>
<dt>
<b>ENOEXEC</b></dt>
<dd>
The new process image file has the appropriate access permission but has an unrecognized format.</dd>
</dl>
<div class="spacer">
</div>
The  <i>fexecve</i>() function shall fail if:<dl>
<dt>
<b>EBADF</b></dt>
<dd>
The <i>fd</i> argument is not a valid file descriptor open for executing.</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions may fail if:<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
The new process image requires more memory than is allowed by the hardware or system-imposed memory management constraints.</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions, except for  <i>fexecve</i>(), may fail if:<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the <i>path</i> or <i>file</i> argument.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
The length of the <i>path</i> argument or the length of the pathname constructed from the <i>file</i> argument exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.</dd>
</dl>
<dl>
<dt>
<b>ETXTBSY</b></dt>
<dd>
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.</dd>
</dl>
<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>EXAMPLES</h1><div class="subsection">
<h2>Using execl()</h2> The following example executes the <i>ls</i> command, specifying the pathname of the executable (<b>/bin/ls</b>) and using arguments supplied directly to the command to produce single-column output.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
...<br/>
ret = execl (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-1&quot;, (char *)0);<br/>
</div>
</div>
<div class="subsection">
<h2>Using execle()</h2> The following example is similar to <i>Using execl()</i>. In addition, it specifies the environment for the new process image using the <i>env</i> argument.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };<br/>
...<br/>
ret = execle (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0, env);<br/>
</div>
</div>
<div class="subsection">
<h2>Using execlp()</h2> The following example searches for the location of the <i>ls</i> command among the directories specified by the <i>PATH</i> environment variable.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
...<br/>
ret = execlp (&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0);<br/>
</div>
</div>
<div class="subsection">
<h2>Using execv()</h2> The following example passes arguments to the <i>ls</i> command in the <i>cmd</i> array.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
...<br/>
ret = execv (&quot;/bin/ls&quot;, cmd);<br/>
</div>
</div>
<div class="subsection">
<h2>Using execve()</h2> The following example passes arguments to the <i>ls</i> command in the <i>cmd</i> array, and specifies the environment for the new process image using the <i>env</i> argument.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };<br/>
...<br/>
ret = execve (&quot;/bin/ls&quot;, cmd, env);<br/>
</div>
</div>
<div class="subsection">
<h2>Using execvp()</h2> The following example searches for the location of the <i>ls</i> command among the directories specified by the <i>PATH</i> environment variable, and passes arguments to the <i>ls</i> command in the <i>cmd</i> array.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>#include &lt;unistd.h&gt;</b><div class="spacer">
</div>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
...<br/>
ret = execvp (&quot;ls&quot;, cmd);<br/>
</div>
</div>
</div>
<div class="section">
<h1>APPLICATION USAGE</h1> As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming applications should not rely on their use and should close them prior to calling one of the <i>exec</i> functions.<div class="spacer">
</div>
Applications that require other than the default POSIX locale as the global locale in the new process image should call  <i>setlocale</i>() with the appropriate parameters.<div class="spacer">
</div>
When assigning a new value to the <i>environ</i> variable, applications should ensure that the environment to which it will point contains at least the following:<dl>
<dt>
 1.</dt>
<dd>
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V7_ENV entry in <i>&lt;unistd.h&gt;</i> and  <i>confstr</i>() for details.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
A value for <i>PATH</i> which finds conforming versions of all standard utilities before any other versions.</dd>
</dl>
<div class="spacer">
</div>
The same constraint applies to the <i>envp</i> array passed to  <i>execle</i>() or  <i>execve</i>(), in order to ensure that the new process image is invoked in a conforming environment.<div class="spacer">
</div>
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed program, applications should not just close them but should reopen them on, for example, <b>/dev/null</b>. Some implementations may reopen them automatically, but applications should not rely on this being done.<div class="spacer">
</div>
If an application wants to perform a checksum test of the file being executed before executing it, the file will need to be opened with read permission to perform the checksum test.<div class="spacer">
</div>
Since execute permission is checked by  <i>fexecve</i>(), the file description <i>fd</i> need not have been opened with the O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the <i>exec</i>, the only way to provide the <i>fd</i> to  <i>fexecve</i>() will be to use the O_EXEC flag when opening <i>fd</i>. In this case, the application will not be able to perform a checksum test since it will not be able to read the contents of the file.<div class="spacer">
</div>
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read, read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC open mode is different;  <i>fexecve</i>() will ignore the mode that was used when the file descriptor was opened and the <i>exec</i> will fail if the mode of the file associated with <i>fd</i> does not grant execute permission to the calling process at the time  <i>fexecve</i>() is called.</div>
<div class="section">
<h1>RATIONALE</h1> Early proposals required that the value of <i>argc</i> passed to  <i>main</i>() be ``one or greater''. This was driven by the same requirement in drafts of the ISO&#160;C standard. In fact, historical implementations have passed a value of zero when no arguments are supplied to the caller of the <i>exec</i> functions. This requirement was removed from the ISO&#160;C standard and subsequently removed from this volume of POSIX.1&#8208;2008 as well. The wording, in particular the use of the word  <i>should</i>, requires a Strictly Conforming POSIX Application to pass at least one argument to the <i>exec</i> function, thus guaranteeing that <i>argc</i> be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications reference <i>argv</i>[0] without first checking the value of <i>argc</i>.<div class="spacer">
</div>
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename string associated with the process being started. Although some existing applications pass a pathname rather than a filename string in some circumstances, a filename string is more generally useful, since the common usage of <i>argv</i>[0] is in printing diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the <i>login</i> utility use a convention of prefixing a &lt;hyphen&gt; (<b>'&#8208;'</b>) to the actual filename, which indicates to the command interpreter being invoked that it is a ``login shell''.<div class="spacer">
</div>
Historically, there have been two ways that implementations can <i>exec</i> shell scripts.<div class="spacer">
</div>
One common historical implementation is that the  <i>execl</i>(),  <i>execv</i>(),  <i>execle</i>(), and  <i>execve</i>() functions return an <b>[ENOEXEC]</b> error for any file not recognizable as executable, including a shell script. When the  <i>execlp</i>() and  <i>execvp</i>() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter to interpret such files. This is now required by POSIX.1&#8208;2008. These implementations of  <i>execvp</i>() and  <i>execlp</i>() only give the <b>[ENOEXEC]</b> error in the rare case of a problem with the command interpreter's executable file. Because of these implementations, the <b>[ENOEXEC]</b> error is not mentioned for  <i>execlp</i>() or  <i>execvp</i>(), although implementations can still give it.<div class="spacer">
</div>
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the character string <b>&quot;#!&quot;</b> and using the remainder of the first line of the file as the name of the command interpreter to execute.<div class="spacer">
</div>
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the behavior of the <i>exec</i> family of functions. The following is a description of the actions taken:<dl>
<dt>
 1.</dt>
<dd>
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for this system, then the system executes the file.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such as a recognized binary for another architecture), then this is an error and <i>errno</i> is set to <b>[EINVAL]</b> (see later RATIONALE on <b>[EINVAL]</b>).</dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
If the process image file has appropriate privileges but is not otherwise recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
 a.</dt>
<dd>
If this is a call to  <i>execlp</i>() or  <i>execvp</i>(), then they invoke a command interpreter assuming that the process image file is a shell script.</dd>
</dl>
<dl>
<dt>
 b.</dt>
<dd>
If this is not a call to  <i>execlp</i>() or  <i>execvp</i>(), then an error occurs and <i>errno</i> is set to <b>[ENOEXEC]</b>.</dd>
</dl>
</div>
<div class="spacer">
</div>
Applications that do not require to access their arguments may use the form:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
<b></b><br/>
<b>main(void)</b><br/>
</div>
<div class="spacer">
</div>
as specified in the ISO&#160;C standard. However, the implementation will always provide the two arguments <i>argc</i> and <i>argv</i>, even if they are not used.<div class="spacer">
</div>
Some implementations provide a third argument to  <i>main</i>() called <i>envp</i>. This is defined as a pointer to the environment. The ISO&#160;C standard specifies invoking  <i>main</i>() with two arguments, so implementations must support applications written this way. Since this volume of POSIX.1&#8208;2008 defines the global variable <i>environ</i>, which is also provided by historical implementations and can be used anywhere that <i>envp</i> could be used, there is no functional need for the <i>envp</i> argument. Applications should use the  <i>getenv</i>() function rather than accessing the environment directly via either <i>envp</i> or <i>environ</i>. Implementations are required to support the two-argument calling sequence, but this does not prohibit an implementation from supporting <i>envp</i> as an optional third argument.<div class="spacer">
</div>
This volume of POSIX.1&#8208;2008 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits the signal mask of the thread that called <i>exec</i> in the old process image. This is consistent with historical implementations, and it permits some useful functionality, such as the <i>nohup</i> command. However, it should be noted that many existing applications wrongly assume that they start with certain signals set to the default action and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such as the one in the ISO&#160;C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to block or ignore signals across <i>exec</i>s without explicit reason to do so, and especially not to block signals across <i>exec</i>s of arbitrary (not closely cooperating) programs.<div class="spacer">
</div>
The <i>exec</i> functions always save the value of the effective user ID and effective group ID of the process at the completion of the <i>exec</i>, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.<div class="spacer">
</div>
The statement about <i>argv</i>[] and <i>envp</i>[] being constants is included to make explicit to future writers of language bindings that these objects are completely constant. Due to a limitation of the ISO&#160;C standard, it is not possible to state that idea in standard C. Specifying two levels of <i>const</i>&#8722;<i>qualification</i> for the <i>argv</i>[] and <i>envp</i>[] parameters for the <i>exec</i> functions may seem to be the natural choice, given that these functions do not modify either the array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the array of pointers is noted as constant. The table of assignment compatibility for <i>dst</i>=<i>src</i> derived from the ISO&#160;C standard summarizes the compatibility:<table class="tbl">
<col style="width: 21.00ex;"/>
<col style="width: 10.00ex;"/>
<col style="width: 16.00ex;"/>
<col style="width: 15.00ex;"/>
<col style="width: 21.00ex;"/>
<tbody>
<tr>
<td>
<i>dst</i>:</td>
<td>
char *[]</td>
<td>
const char *[]</td>
<td>
char *const[]</td>
<td>
const char *const[]</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
<i>src</i>:</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
char *[]</td>
<td>
VALID</td>
<td>
&#8212;</td>
<td>
VALID</td>
<td>
&#8212;</td>
</tr>
<tr>
<td>
const char *[]</td>
<td>
&#8212;</td>
<td>
VALID</td>
<td>
&#8212;</td>
<td>
VALID</td>
</tr>
<tr>
<td>
char * const []</td>
<td>
&#8212;</td>
<td>
&#8212;</td>
<td>
VALID</td>
<td>
&#8212;</td>
</tr>
<tr>
<td>
const char *const[]</td>
<td>
&#8212;</td>
<td>
&#8212;</td>
<td>
&#8212;</td>
<td>
VALID</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
Since all existing code has a source type matching the first row, the column that gives the most valid combinations is the third column. The only other possibility is the fourth column, but using it would require a cast on the <i>argv</i> or <i>envp</i> arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would naturally use would be that in the second row.<div class="spacer">
</div>
The ISO&#160;C standard and this volume of POSIX.1&#8208;2008 do not conflict on the use of <i>environ</i>, but some historical implementations of <i>environ</i> may cause a conflict. As long as <i>environ</i> is treated in the same way as an entry point (for example,  <i>fork</i>()), it conforms to both standards. A library can contain  <i>fork</i>(), but if there is a user-provided  <i>fork</i>(), that  <i>fork</i>() is given precedence and no problem ensues. The situation is similar for <i>environ</i>: the definition in this volume of POSIX.1&#8208;2008 is to be used if there is no user-provided <i>environ</i> to take precedence. At least three implementations are known to exist that solve this problem.<dl>
<dt>
<b>E2BIG</b></dt>
<dd>
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment list.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
Some historical systems return <b>[EFAULT]</b> rather than <b>[ENOEXEC]</b> when the new process image file is corrupted. They are non-conforming.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
This error condition was added to POSIX.1&#8208;2008 to allow an implementation to detect executable files generated for different architectures, and indicate this situation to the application. Historical implementations of shells,  <i>execvp</i>(), and  <i>execlp</i>() that encounter an <b>[ENOEXEC]</b> error will execute a shell on the assumption that the file is a shell script. This will not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose to avoid this problem by returning <b>[EINVAL]</b> when a valid executable for a different architecture is encountered. Some historical implementations return <b>[EINVAL]</b> to indicate that the <i>path</i> argument contains a character with the high order bit set. The standard developers chose to deviate from historical practice for the following reasons:</dd>
</dl>
<div style="margin-left: 12.00ex;">
<dl>
<dt>
 1.</dt>
<dd>
The new utilization of <b>[EINVAL]</b> will provide some measure of utility to the user community.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
Historical use of <b>[EINVAL]</b> is not acceptable in an internationalized operating environment.</dd>
</dl>
</div>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Since the file pathname may be constructed by taking elements in the <i>PATH</i> variable and putting them together with the filename, the <b>[ENAMETOOLONG]</b> error condition could also be reached this way.</dd>
</dl>
<dl>
<dt>
<b>ETXTBSY</b></dt>
<dd>
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1&#8208;2008 neither requires nor prohibits this behavior.</dd>
</dl>
<div class="spacer">
</div>
Other systems (such as System V) may return <b>[EINTR]</b> from <i>exec</i>. This is not addressed by this volume of POSIX.1&#8208;2008, but implementations may have a window between the call to <i>exec</i> and the time that a signal could cause one of the <i>exec</i> calls to return with <b>[EINTR]</b>.<div class="spacer">
</div>
An explicit statement regarding the floating-point environment (as defined in the <i>&lt;fenv.h&gt;</i> header) was added to make it clear that the floating-point environment is set to its default when a call to one of the <i>exec</i> functions succeeds. The requirements for inheritance or setting to the default for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized as follows:<dl>
<dt>
<i>posix_spawn</i>()</dt>
<dd>
Set to default.</dd>
</dl>
<dl>
<dt>
<i>fork</i>()</dt>
<dd>
Inherit.</dd>
</dl>
<dl>
<dt>
<i>pthread_create</i>()</dt>
<dd>
Inherit.</dd>
</dl>
<div class="spacer">
</div>
The purpose of the  <i>fexecve</i>() function is to enable executing a file which has been verified to be the intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not exchanged for another between the reading and the execution. Alternatively, an function like  <i>openat</i>() can be used to open a file which has been found by reading the content of a directory using  <i>readdir</i>().</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1> <i><i>alarm</i>()</i>, <i><i>atexit</i>()</i>, <i><i>chmod</i>()</i>, <i><i>close</i>()</i>, <i><i>confstr</i>()</i>, <i><i>exit</i>()</i>, <i><i>fcntl</i>()</i>, <i><i>fork</i>()</i>, <i><i>fstatvfs</i>()</i>, <i><i>getenv</i>()</i>, <i><i>getitimer</i>()</i>, <i><i>getrlimit</i>()</i>, <i><i>mknod</i>()</i>, <i><i>mmap</i>()</i>, <i><i>nice</i>()</i>, <i><i>open</i>()</i>, <i><i>posix_spawn</i>()</i>, <i><i>posix_trace_create</i>()</i>, <i><i>posix_trace_event</i>()</i>, <i><i>posix_trace_eventid_equal</i>()</i>, <i><i>pthread_atfork</i>()</i>, <i><i>pthread_sigmask</i>()</i>, <i><i>putenv</i>()</i>, <i><i>readdir</i>()</i>, <i><i>semop</i>()</i>, <i><i>setlocale</i>()</i>, <i><i>shmat</i>()</i>, <i><i>sigaction</i>()</i>, <i><i>sigaltstack</i>()</i>, <i><i>sigpending</i>()</i>, <i><i>system</i>()</i>, <i><i>times</i>()</i>, <i><i>ulimit</i>()</i>, <i><i>umask</i>()</i><div class="spacer">
</div>
The Base Definitions volume of POSIX.1&#8208;2008, <i>Chapter 8</i>, <i>Environment Variables</i>, <i><b>&lt;unistd.h&gt;</b></i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2013 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 7, Copyright (C) 2013 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. (This is POSIX.1-2008 with the 2013 Technical Corrigendum 1 applied.) In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.unix.org/online.html .<div style="height: 1.00em;">
&#160;</div>
Any typographical or formatting errors that appear in this page are most likely to have been introduced during the conversion of the source files to man page format. To report such errors, see https://www.kernel.org/doc/man-pages/reporting_bugs.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2013</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

